{"version":3,"file":"debugging-standalone.js","mappings":";;;;;;;;;;;;;;AAAA;AACO,wBAAwB,eAAe,8BAA8B,IAAI,sCAAsC,IAAI,UAAU,GAAG,WAAW,gDAAgD,2BAA2B,YAAY,yBAAyB,8DAA8D,wBAAwB,GAAG,sBAAsB,sCAAsC,0EAA0E,6BAA6B,aAAa,EAAE,4BAA4B,EAAE,iBAAiB,IAAI;AAChkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACF6D;AAC6C;AAC1G;AACO;AACP;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,UAAU;AACtB;AACO;AACP,iBAAiB,iEAAkB;AACnC;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACO;AACP;AACA,MAAM,iEAAkB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,sDAAO;AACV;AACA;AACO;AACA;AACP;AACA;AACA,sCAAsC,kEAAe,mBAAmB,QAAQ;AAChF,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN,GAAG;AACH;AACA;AACO;AACP,qCAAqC,yDAAU,gJAAgJ,kDAAO;AACtM;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACO;AACP;AACA,MAAM,iEAAkB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,iCAAiC;AAC/C,cAAc,oBAAoB;AAClC,cAAc,sBAAsB;AACpC,cAAc,sBAAsB;AACpC,cAAc,0BAA0B;AACxC,cAAc,sBAAsB;AACpC,cAAc,sBAAsB;AACpC,SAAS;AACT;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B,cAAc,iBAAiB;AAC/B,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B,cAAc,WAAW;AACzB,cAAc,WAAW;AACzB,cAAc,iBAAiB;AAC/B,cAAc,eAAe;AAC7B,cAAc,UAAU;AACxB,cAAc,wBAAwB;AACtC,cAAc,QAAQ;AACtB,cAAc,WAAW;AACzB,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B,cAAc,iBAAiB;AAC/B,SAAS;AACT;;AAEA;AACA;AACA,WAAW,sBAAsB;AACjC,aAAa;AACb;;AAEA;AACA;AACA,WAAW,8BAA8B;AACzC;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7IwD;AAC0D;AACnE;;AAE/C;AACA,aAAa,sCAAsC;AACnD;;AAEO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,4BAA4B,yEAA0B;AACtD,4BAA4B,yDAAU;AACtC,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,SAAS;AACzB;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW,IAAI,YAAY;AAC3C,gBAAgB,YAAY;AAC5B,gBAAgB,aAAa;AAC7B;;AAEA;AACA,iBAAiB;AACjB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,GAAG;AACH;AACA,eAAe,UAAU;AACzB,aAAa,GAAG;AAChB,yDAAyD,wCAAwC;AACjG,aAAa,GAAG;AAChB,eAAe;AACf;AACA;;AAEA;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,OAAO;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA,6FAA6F,aAAa;AAC1G;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,eAAe,UAAU;AACzB,aAAa,GAAG;AAChB,aAAa,GAAG;AAChB,eAAe,GAAG;AAClB,mEAAmE,4CAA4C;AAC/G;AACA;;AAEA;AACA,aAAa,GAAG;AAChB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN,4FAA4F,OAAO;AACnG,wBAAwB;AACxB,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iGAAiG,eAAe;AAChH;AACA;AACA,MAAM,wDAAS;AACf;AACA,OAAO;AACP,uBAAuB,qDAAiB;AACxC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,6FAA6F,OAAO;AACpG;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ,sDAAM;AACzE;AACA;AACA,+BAA+B,sDAAM;AACrC;AACA,MAAM,gCAAgC,qDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,+FAA+F,eAAe;AAC9G;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE,mBAAmB,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ,MAAM,GAAG;AACT,MAAM,aAAa;AACnB;AACA,MAAM,YAAY;AAClB,eAAe,QAAQ,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAc;AACrC;AACA;AACA;AACA;AACA,0EAA0E,cAAc,yBAAyB,MAAM;AACvH;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,mBAAmB,wDAAS;AAC5B;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;ACpT+D;AACV;AACI;AACL;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE,uDAAW;AACb;AACA,GAAG;AACH,EAAE,oDAAQ;AACV;AACA;AACA,GAAG;AACH;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ,gCAAgC;AAChC;AACA;AACA,EAAE,uDAAW;AACb;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA,oBAAoB,wDAAS;AAC7B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,aAAa;AACxG;AACA;AACA;AACA,GAAG;AACH;AACO;AACP,eAAe,6DAAc;AAC7B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA,uBAAuB,GAAG;AAC1B;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,uBAAuB,8DAAc;AACrC;AACA,GAAG;AACH,4BAA4B,sEAAkB;AAC9C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtNO;AACA;AACA;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA,YAAY,mCAAmC;AAC/C,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA,mDAAmD,kBAAkB,GAAG,kBAAkB,IAAI,QAAQ,GAAG,KAAK,QAAQ,YAAY,WAAW,iBAAiB;AAC9J;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChH+D;AACxD;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,iBAAiB,6DAAc;AAC/B;AACA,0EAA0E,aAAa;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5DgE;AACf;AACkC;AACnF;AACA,iEAAe;AACf,GAAG,sDAAM;AACT;AACA;AACA,wCAAwC,KAAK;AAC7C,uEAAuE,UAAU,kEAAkE,SAAS,gEAAgE,qHAAqH,mBAAmB,OAAO,qBAAqB,OAAO;AACvY;AACA,GAAG;AACH,GAAG,qDAAK;AACR;AACA;AACA,6BAA6B,sDAAQ;AACrC;AACA,OAAO;AACP;AACA,yBAAyB,4FAA2B;AACpD;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;AACH,GAAG,sDAAM;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjGmD;AACQ;AACb;AACe;AAC7D,qBAAqB,2DAAS;AAC9B;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mDAAQ;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,kDAAO;AACf;AACA;AACA;AACA,MAAM,kDAAO,oGAAoG,WAAW;AAC5H;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,mCAAmC;AACnC,MAAM,gEAAkB,MAAM,sEAAkB;AAChD;AACA,GAAG,aAAa;AAChB;;AAEA;AACA,eAAe;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE,qDAAU,iCAAiC,IAAI,OAAO,UAAU;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,mDAAQ,kDAAkD,gBAAgB;AAChF;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACO;AACP;AACA;AACA,uEAAuE,wFAAwF;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;AC9DkD;AACE;;AAEpD;AACA;AACA;AACA;AACO,uBAAuB,iEAAqB,UAAU,0DAAc;AAC3E;;;;;;;;;;;;;;;;;;;;ACRO;AACA;AACA;AACA;AACA;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLkD;AAChB;;AAElC;AACA;AACA;AACA;AACO;AACA;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACO;;AAEP;AACA,kDAAkD;AAClD;AACA;AACO;;AAEP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACO;AACA;AACP;AACA;AACA;AACA;AACA,qCAAqC,WAAW,GAAG,WAAW;AAC9D;AACA,uBAAuB,2DAAkB;AACzC;AACA;AACA;AACA;AACA;AACO,4BAA4B,8CAAI;AACvC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EyC;AACH;AACkC;AAC+D;AAC5E;AACpD,sIAAsI,EAAE;AACxI;AACA;AACA;AACA;;AAEP;AACA;AACA,cAAc;AACd,cAAc,eAAe;AAC7B,cAAc,sBAAsB;AACpC;AACA,cAAc,MAAM,qBAAqB;AACzC;AACA;;AAEA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,YAAY;AACZ;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,2FAA2F,aAAa;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qDAAU;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,sFAAsF,wDAAiB;AACvG;AACA;AACA;AACA;AACA;AACA,sFAAsF,wDAAiB;AACvG;AACA,UAAU,kEAAsB;AAChC;AACA,uCAAuC,kEAAsB;AAC7D,GAAG;AACH,UAAU,iEAAqB;AAC/B;AACA,uCAAuC,iEAAqB;AAC5D,GAAG;AACH;AACO;AACP,sFAAsF,wDAAiB;AACvG;AACA,UAAU,kEAAsB;AAChC;AACA,uCAAuC,kEAAsB;AAC7D,GAAG;AACH,UAAU,kEAAsB;AAChC;AACA,uCAAuC,kEAAsB;AAC7D,GAAG;AACH,UAAU,yEAA6B;AACvC;AACA,uCAAuC,yEAA6B;AACpE;AACA;AACA;AACA,GAAG;AACH,UAAU,yEAA6B;AACvC;AACA,uCAAuC,yEAA6B;AACpE;AACA,aAAa,4DAAS;AACtB;AACA,GAAG;AACH,UAAU,yEAA6B;AACvC;AACA,uCAAuC,yEAA6B;AACpE;AACA,aAAa,4DAAS;AACtB;AACA,GAAG;AACH,UAAU,iEAAqB;AAC/B;AACA,uCAAuC,iEAAqB;AAC5D,GAAG;AACH;AACO;AACP,sFAAsF,wDAAiB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa,kBAAkB,KAAK,yBAAyB,QAAQ;AACrE;AACA;AACO;AACP;AACA,kEAAuB,CAAC,iEAAqB;AAC7C,OAAO,8CAAM;AACb;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;ACxMwC;AACe;;AAEvD;AACA;AACA,YAAY,8CAA8C,gCAAgC,kDAAkD;AAC5I;AACO;AACP,mFAAmF,oDAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,2CAA2C,MAAM,OAAO,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAwB;AAChD,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,mBAAmB,MAAM,EAAE,8BAA8B,GAAG,SAAS,SAAS,UAAU,GAAG,kBAAkB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,mBAAmB,kCAAkC;AAClE,wCAAwC,sBAAsB,cAAc;AAC5E;AACA;AACA,aAAa,aAAa,4FAA4F;AACtH,aAAa,cAAc,+EAA+E;AAC1G;AACA;AACA;AACA,aAAa,QAAQ,+BAA+B;AACpD,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,QAAQ;AACrB,iBAAiB,4BAA4B;AAC7C,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClH0I;AACpG;AAC6D;AAC9D;AAC+B;AAC5B;AACa;AACQ;AAC5B;AACgB;AACF;AACE;AACG;AACX;AACmD;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,iDAAM;AACV;AACA;AACA,EAAE,EAAE,kEAAuB;AACpB,uBAAuB,8CAAI;AAClC;AACA,qFAAqF,wDAAS;AAC9F,qCAAqC,8DAAc,oCAAoC;AACvF,CAAC;AACM,uBAAuB,8CAAI;AAClC,GAAG,qEAAkB,oBAAoB,6DAAc,IAAI,iEAAkB,wBAAwB,uDAAY;AACjH,EAAE,4CAAW;AACb,EAAE,8DAAc;AAChB,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,mDAAQ,4BAA4B,GAAG,KAAK,QAAQ;AACtD,EAAE,4CAAW;AACb;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE,0DAAc;AAChB,EAAE,4CAAW;AACb;AACO;AACP;AACA,SAAS,iDAAM;AACf;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,SAAS,iDAAM;AACf;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM,mDAAQ,mDAAmD,WAAW,YAAY,iBAAiB;AACzG;AACA;AACO;AACP;AACA;AACA,mBAAmB,0DAAkB;AACrC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,mDAAQ;AACX;AACA,IAAI,IAAI;AACR,WAAW,mDAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,8CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAa;AACrB,WAAW,wDAAa;AACxB;AACA;AACA;AACA;AACA,CAAC;AACM,iBAAiB,8CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAQ;AAClD,IAAI;AACJ,mBAAmB,KAAI,8BAA8B,iDAAK;AAC1D;AACA;AACA,cAAc,kEAAuB;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,MAAM,iEAAkB;AACxB,IAAI,8DAAe;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,gBAAgB,kEAAuB;AACvC,oCAAoC,KAAK;AACzC;AACA,OAAO;AACP;AACA;AACA,+BAA+B,qDAAU;AACzC,MAAM,kDAAO,UAAU,MAAM;AAC7B,MAAM,4CAAW;AACjB,UAAU,+CAAM;AAChB;AACA;AACA;AACA,SAAS,mDAAO;AAChB,MAAM,kDAAO,UAAU,MAAM;AAC7B,MAAM,4CAAW;AACjB,UAAU,+CAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA,gBAAgB,kEAAuB;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACO;AACP,kBAAkB,kEAAU;AAC5B;AACA;AACA;AACA;AACA,uBAAuB,qDAAU;AACjC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,MAAM,2EAAmB;AACzB;AACA,iBAAiB,mDAAY;AAC7B,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,0BAA0B,kEAAuB;AACjD,oBAAoB,mDAAQ;AAC5B,OAAO;AACP;AACA;AACA,+DAA+D,gBAAgB,YAAY,YAAY;AACvG,IAAI,wDAAa;AACjB;AACA;AACA;AACA,WAAW,kEAAuB,iCAAiC,sBAAsB;AACzF,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB,qDAAU;AAC/B;AACA;AACA,MAAM;AACN,oBAAoB,gEAAqB;AACzC,mBAAmB,qDAAU;AAC7B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACpXA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;AC5Ee;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;;AAE+R;AACjN;AACtB;AAChB;AACK;AACZ;AACqM;AAC/K;AAC4C;AAC7D;AACO;AACO;AACC;AACmD;AAC9C;AACkC;AACuB;AAC/D;AAC+C;AACK;AACjG;AACA;AACP;AACA;AACA;AACO;AACP,aAAa,mEAAiB;AAC9B,UAAU,6DAAQ;AAClB;AACA;AACA;AACA;AACA;AACA,8CAAM;AACN;AACA,kBAAkB,kDAAO;AACzB;AACA,CAAC;AACD,uBAAuB,4EAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,sEAAkB;AAC1C,KAAK,0EAAuB;AAC5B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,4BAA4B;AAC5B,kBAAkB,oDAAS,GAAG;AAC9B,OAAO,EAAE,2DAAgB;AACzB;AACA,UAAU,4DAAiB;AAC3B,8BAA8B;AAC9B;AACA,SAAS;AACT,QAAQ;AACR,QAAQ,mDAAQ,sDAAsD,YAAY;AAClF;AACA;AACA,QAAQ,2EAA8B;AACtC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,6BAA6B,iEAAsB;AACnD;AACA;AACA;AACA;AACA,uBAAuB,+DAAkB;AACzC,0BAA0B,+DAAkB;AAC5C,6BAA6B,qEAAwB;AACrD,yBAAyB,iEAAoB;AAC7C;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,GAAG,aAAa,8CAAO;AACvB;;AAEA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACO,4BAA4B,8CAAI;AACvC;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA,oBAAoB,oDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAS,GAAG;AACpC,MAAM;AACN,MAAM,kDAAO,yDAAyD;AACtE;AACA;AACA,mBAAmB,iEAAsB;AACzC;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAS;AACnC;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,8CAAI;AACzC;AACA,CAAC;;AAED;AACA,aAAa,SAAS,GAAG;AACzB,aAAa,aAAa;AAC1B;AACA;AACO;AACP,OAAO,kDAAO;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,SAAS,yDAAc;AACvB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACO,yBAAyB,8CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAI;AACvB;AACA;AACA,qBAAqB,kEAAU;AAC/B;AACA;AACA,aAAa;AACb;AACA,IAAI,6CAAW,CAAC,kDAAM;AACtB,QAAQ,IAAI;AACZ,MAAM,4EAA+B;AACrC;AACA,8CAA8C,8CAAO,UAAU,iEAAwB;AACvF;AACA,WAAW,wDAAa;AACxB;AACA;AACA;AACA,mEAAmE,2EAAmB,iBAAiB,sEAAkB;AACzH,MAAM,qEAAwB;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ,8CAAM,iCAAiC,8CAAM;AACrD,sBAAsB,kDAAO;AAC7B;AACA,wBAAwB,qEAAc;AACtC;AACA;AACA;AACA;AACA,+FAA+F,sEAAkB;AACjH,6CAA6C,oDAAS;AACtD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,0DAA0D,2EAAmB;AAC7E;AACA;AACA;AACA,UAAU;;AAEV;AACA,6BAA6B,uDAAY;AACzC;AACA,kCAAkC,iEAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAS;AAClC,mBAAmB,+CAAG;AACtB;AACA,aAAa;AACb;AACA;AACA,iBAAiB,+CAAG;AACpB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA,8BAA8B,iEAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAS;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ,mDAAQ,6DAA6D,WAAW;AACxF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,UAAU,+DAAe;AACzB,oCAAoC,+DAAe;AACnD;AACA,UAAU,8DAAc;AACxB,mCAAmC,8DAAc;AACjD;AACA,UAAU,8DAAc;AACxB,mCAAmC,8DAAc;AACjD;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM,kDAAO;AACb;AACA;AACA;AACA,oFAAoF,+CAAG;AACvF;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,sDAAW;AACnC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAS;AAC1C;AACA;AACA;AACA;AACA,uGAAuG,aAAa;AACpH;AACA;AACA;AACA;AACA,aAAa;AACb,4BAA4B,yDAAc;AAC1C,YAAY,qDAAU,oCAAoC,qGAAqG;;AAE/J;AACA;AACA;AACA,cAAc,6CAAW,CAAC,kDAAM;AAChC;AACA;AACA,eAAe;AACf,aAAa;;AAEb;AACA;AACA;AACA,UAAU;AACV,UAAU,mDAAQ;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,4BAA4B,oDAAS;AACrC;AACA,MAAM,8CAAM;AACZ,QAAQ,qDAAU;AAClB,QAAQ,6CAAW,CAAC,kDAAM;AAC1B,OAAO;AACP,mBAAmB,sDAAW;AAC9B;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ,8CAAM,iLAAiL,8CAAM;AACrM,QAAQ;AACR,QAAQ,mDAAQ,IAAI,0BAA0B;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ,2DAAW,UAAU,sEAAkB;AAC/C,YAAY,KAAI;AAChB;AACA;AACA,YAAY,KAAI;AAChB,UAAU,uDAAc;AACxB;AACA,QAAQ;AACR,QAAQ,mDAAQ;AAChB;AACA,MAAM;AACN,MAAM,mDAAQ;AACd;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,UAAU,mDAAQ;AAClB,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc,kDAAO,WAAW,MAAM,yDAAyD,UAAU,YAAY,WAAW;AAChI;AACA;AACA,yBAAyB,sEAAS,iBAAiB;AACnD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV,UAAU,mDAAQ;AAClB;AACA;AACA,MAAM;AACN,MAAM,qDAAU;AAChB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAW,UAAU,yEAAqB;AAClD,QAAQ;AACR,QAAQ,mDAAQ,yDAAyD,KAAK;AAC9E;AACA;AACA,MAAM;AACN,MAAM,mDAAQ;AACd;AACA,GAAG;AACH;AACA,SAAS,kDAAO;AAChB;AACA;AACA;AACA;AACA;AACA,0BAA0B,iFAAyB,iBAAiB,yEAAqB;AACzF,WAAW,4EAAyB;AACpC,SAAS;AACT;AACA;AACA,QAAQ;AACR,QAAQ,mDAAQ,8DAA8D,uBAAuB;AACrG;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B,kEAAuB;AACrD;AACA;AACA,KAAK;AACL,sBAAsB,kDAAO;AAC7B;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,iBAAiB,kEAAuB;AACxC,IAAI,uEAA0B;AAC9B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS,sEAAkB,oBAAoB,qEAAqB,IAAI,kEAAkB,wBAAwB,+CAAQ;AAC1H;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,2BAA2B,8CAAI;AAC/B,2EAA2E,eAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAc;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU,mDAAQ,kBAAkB,QAAQ,KAAK,KAAK;AACtD;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,MAAM,KAAI;AACV,MAAM,KAAI,IAAI,uDAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAO,aAAa,OAAO,GAAG,OAAO;AACzC,iGAAiG,eAAe;AAChH;AACA;AACA,IAAI,8CAAM;AACV,IAAI;AACJ,IAAI,kDAAO,kBAAkB,QAAQ,KAAK,OAAO;AACjD;AACA;AACA;AACA,wBAAwB,+CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,cAAc,EAAC;AAC9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9sBoC;AACc;AACZ;AACO;AACH;AACM;AACF;AACyB;AAChC;AAC2M;AAChN;AACoB;AACA;AACD;AACM;AACM;AACH;AAC8B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE,2DAA2D,8BAA8B;AACzF,sDAAsD;AACtD,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,GAAG;AACjB;AACA,eAAe,gCAAgC;AAC/C;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,oBAAoB;AAClC,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI,0DAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAa;AACvB;AACA;AACA;AACA;AACA,MAAM,0DAAc;AACpB,gCAAgC;AAChC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACO,kBAAkB,kDAAO;AAChC;AACA;AACA,IAAI;AACJ,MAAM,uEAAiB,CAAC,4EAAqB,EAAE,6EAAc,CAAC,sEAAkB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,kDAAO;AAC5B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACO;AACP,uBAAuB,uDAAO;AAC9B;AACA,2CAA2C;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAU;AAClC;AACA;AACA;AACA;AACA,UAAU;AACV,iDAAiD,2DAAgB;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd,UAAU,6CAAW,CAAC,iDAAM;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,6CAAW,CAAC,iDAAM;AACtD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ,YAAY,kDAAO;AACnB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAc;AACxB,UAAU,6CAAW,CAAC,iDAAM;AAC5B;AACA;AACA,WAAW;AACX,UAAU,mDAAQ,oBAAoB,WAAW,UAAU,cAAc,EAAE,aAAa;AACxF;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAO,IAAI,wBAAwB,iDAAiD,kBAAkB;AACpH,wEAAwE,2DAAgB;AACxF;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,4CAA4C,0DAAS,mBAAmB,+CAAI;AAC5E;AACA,YAAY;AACZ,YAAY,kDAAO,WAAW,WAAW,mCAAmC,sBAAsB;AAClG,qDAAqD,2DAAgB;AACrE;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,sCAAsC,+DAAc;AACpD,+BAA+B,+DAAc;AAC7C;AACA,6BAA6B,kDAAO,+GAA+G,8CAAO;AAC1J,wCAAwC,kDAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAO,+BAA+B,UAAU,IAAI,oBAAoB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,+CAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,mDAAQ,WAAW,WAAW;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU,kDAAO;AACjB;AACA;AACA;AACA,YAAY,kDAAO;AACnB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,6DAAkB,CAAC,qDAAU,8BAA8B,wDAAa;AAC9F;AACA;AACA;AACA,8FAA8F,+DAAc,4CAA4C,uEAAiB,CAAC,6EAAsB,EAAE,6EAAc,CAAC,sEAAkB;AACnO;AACA,OAAO;AACP;AACA;AACA;AACA,gBAAgB,YAAY,EAAE,kCAAkC;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,UAAU,kDAAO,kCAAkC,WAAW;AAC9D;AACA,mDAAmD,qEAA0B;AAC7E,UAAU,+DAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,QAAQ,kDAAO,kCAAkC,UAAU,iBAAiB,gBAAgB;AAC5F;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B,qEAA0B,cAAc;AACtF;AACA;AACA;AACA,GAAG;AACH,CAAC;AACM,0BAA0B,+CAAI;AACrC,2BAA2B,+CAAM;AACjC,iDAAiD,0DAAc;AAC/D;AACA,qBAAqB,mDAAQ;AAC7B,oBAAoB,mDAAQ;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB,OAAO;AACP,MAAM,mDAAQ;AACd;AACA;AACA,CAAC;AACM,uBAAuB,+CAAI,qCAAqC;AACvE;AACA;AACA;AACA,YAAY,+DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAe;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA,YAAY,+DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe,kBAAkB,IAAI;AACpE;AACA;AACA,IAAI,kDAAO;AACX;AACA;AACA;AACA,IAAI,kDAAO,mDAAmD,WAAW;AACzE;AACA;AACA;AACA,IAAI,mDAAQ,wBAAwB,gBAAgB;AACpD;AACA;AACA,MAAM,KAAI,mCAAmC,6DAAgB;AAC7D;AACA,GAAG;AACH,IAAI,mDAAQ;AACZ;AACA;AACA,MAAM,KAAI,kCAAkC,2DAAe;AAC3D;AACA,GAAG;AACH,IAAI,mDAAQ;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH,IAAI,mDAAQ;AACZ;AACA;AACA;AACA;AACO;AACP,SAAS,iEAAU,2DAA2D,EAAE,sBAAsB,yBAAyB,GAAG,EAAE;AACpI;AACA;;;;;;;;;;;;;;;;;;;;AC5hBkE;AACF;AACN;AACyB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ,qGAAqG;AACxH;AACO;AACP,OAAO,uEAAiB,CAAC,2EAAoB,EAAE,6EAAc;AAC7D;AACA;AACA;AACA,IAAI,mDAAQ;AACZ;AACA;AACA;AACA,IAAI,mDAAQ,IAAI,YAAY;AAC5B;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kDAAO,WAAW,YAAY;AAChC;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA,MAAM;AACN,MAAM,mDAAQ;AACd;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8DAAmB;AACzB;;AAEA;AACA,IAAI,wDAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpHiF;AACjB;AACN;AACrB;AACJ;AAC0C;AACpE;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mDAAQ,0BAA0B,QAAQ;AAChD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,8CAAI;AACzC;AACA;AACA;AACA;AACA,yDAAyD,uEAAiB,CAAC,0FAAmC,EAAE,6EAAc,4BAA4B,0DAAe;AACzK;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,oBAAoB,mDAAQ;AAC5B;AACA,UAAU,mDAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,uDAAuD,8CAAM;AAC7D;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,yFAAyF;AACzF,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAQ;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA,qBAAqB,mDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtNkI;AACrE;AACe;AACd;AACrB;AACJ;AACI;AACW;AACb;AACQ;AACM;AACA;AACf;AACW;AACiE;AAC5D;AACF;AACT;AACG;AACW;AACe;AACxE;AACA;AACA,EAAE,EAAE,kDAAQ;AACL;AACA;AACA;AACP;AACA,0CAAS,CAAC,iDAAM;AAChB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,qBAAqB,2DAAS;;AAE9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,YAAY,iEAAU;AACtB;AACA;AACA;AACA,kCAAkC,uDAAY;AAC9C;AACA;AACA,eAAe,wDAAK;AACpB,uBAAuB,wDAAK;AAC5B;AACA;AACA;AACA,wBAAwB,sEAAa;AACrC;AACA,gBAAgB,6DAAiB,6BAA6B,6DAAiB;AAC/E,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAsB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,4CAAW,CAAC,iDAAM;AACxB;AACA;AACA;AACA;AACA,QAAQ,qDAAU,YAAY,YAAY;AAC1C;AACA;AACA,UAAU,4CAAW,CAAC,iDAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4CAAW,CAAC,iDAAM;AACxB;AACA;AACA;AACA,iIAAiI;AACjI;AACA;AACA;AACA,UAAU;AACV,UAAU,mDAAQ;AAClB,UAAU;AACV;AACA;AACA,YAAY,0DAAc;AAC1B;AACA;AACA,iCAAiC,+CAAM;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI,+CAAM;AACV;AACA,IAAI,kDAAO,uCAAuC,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,0DAAc;AAC5F,IAAI,kDAAO,wCAAwC,WAAW;AAC9D;AACA;AACA,MAAM,kDAAO;AACb;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAW,CAAC,iDAAM;AAC1B;AACA,QAAQ,0DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,MAAM,kDAAO;AACb;AACA;AACA;AACA;AACA,0BAA0B,+CAAM;AAChC;AACA;AACA,mFAAmF,8CAAG;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAc;AAClB;AACA,MAAM,0DAAc;AACpB;AACA;AACA;AACA,IAAI,0DAAc;AAClB;AACA,EAAE,0CAAS,CAAC,iDAAM;AAClB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB,4DAAiB,CAAC,+CAAI;AACpD;AACA,WAAW,2DAAgB;AAC3B,IAAI;AACJ;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACO,uBAAuB,+CAAI;AAC3B,0BAA0B,+CAAI;AACrC;AACA,CAAC;AACM,yBAAyB,+CAAI;AACpC;AACA;AACA;AACA,CAAC;AACM;AACP;AACA,YAAY,+DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4CAAW,CAAC,iDAAM;AACxB,UAAU,KAAI,8BAA8B,kDAAK,IAAI,KAAI,8BAA8B,kDAAK;AAC5F;AACA,QAAQ;AACR,YAAY,KAAI,IAAI,6DAAgB;AACpC,UAAU,wEAA2B;AACrC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM,kDAAO,aAAa,gCAAgC,gBAAgB,OAAO;AACjF,MAAM,4CAAW,CAAC,iDAAM;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAM;AACvC;AACA,iCAAiC,kDAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAW,CAAC,iDAAM;AAC1B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,wDAAS;AAC9B;AACA;AACA;;AAEA;AACO;AACP;AACA,EAAE,iEAAU;AACZ;AACA,EAAE,4CAAW,CAAC,iDAAM;AACpB;;AAEA;AACA;AACA;AACA,YAAY,+DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE,+CAAM;AACZ;AACA;AACA,IAAI,6DAAY;AAChB,IAAI,iDAAiD,iDAAS;AAC9D;AACA;AACA;AACA,MAAM;AACN,MAAM,mDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,+CAAI;AACnC,MAAM,IAAY;AAClB,IAAI,8DAAa;AACjB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA,wDAAwD,oDAAS;AACjE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE,4CAAW,CAAC,iDAAM;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,mBAAmB,mDAAQ;AAC3B;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA;;AAEA;AACA,kFAAkF,+CAAM;AACxF,0BAA0B,2EAAoB,4EAA4E,+CAAM,iCAAiC,+CAAM;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAc;AACjC;AACA;AACA;;AAEA;AACA,+EAA+E;AAC/E;AACO;AACP;AACA,QAAQ,KAAI,kBAAkB,kDAAK;AACnC,mCAAmC,kDAAK;AACxC,uCAAuC,kDAAK,CAAC,GAAG,QAAQ;AACxD,4CAA4C,kDAAK,CAAC,GAAG,QAAQ;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA,YAAY,+DAAc;AAC1B,IAAI;AACJ;AACA,gGAAgG,+CAAM;AACtG,+JAA+J,+CAAM;AACrK;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA,2BAA2B,8DAAmB;AAC9C;AACA,MAAM,4BAA4B,8DAAmB;AACrD;AACA,MAAM,4BAA4B,8DAAmB;AACrD;AACA,MAAM,4BAA4B,8DAAmB;AACrD;AACA,MAAM,4BAA4B,8DAAmB;AACrD;AACA,MAAM,4BAA4B,8DAAmB;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAc,qCAAqC,yDAAc,8BAA8B,yDAAc,sDAAsD,yDAAc,6BAA6B,yDAAc,+BAA+B,yDAAc,iCAAiC,yDAAc,oCAAoC,yDAAc,+CAA+C,yDAAc,wCAAwC,yDAAc,8BAA8B,yDAAc;AAChiB;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,2CAA2C,EAAE,+DAAc;AAC3D,wBAAwB,uDAAY;AACpC,qBAAqB,uDAAY;AACjC;AACA,MAAM,KAAI;AACV,+CAA+C,uDAAY;AAC3D,qBAAqB,uDAAY;;AAEjC;AACA,KAAK,yDAAc,OAAO,yDAAc;AACxC;AACA;AACA;AACA,KAAK;;AAEL;AACA,QAAQ,+CAAM,2CAA2C,+DAAc;AACvE,sBAAsB,mDAAQ,CAAC,+CAAM;AACrC,mFAAmF,yDAAc;AACjG,4CAA4C,yDAAc;AAC1D,kDAAkD,yDAAc;AAChE,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,+DAAc,oBAAoB,uDAAY;AAClE,uBAAuB,+DAAc;AACrC,uCAAuC,+DAAc;AACrD;AACA;AACA;AACA;AACA,iCAAiC,uDAAY;AAC7C;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAO;AACb;AACA,QAAQ,gDAAI;AACZ;AACA;AACA,QAAQ;AACR,QAAQ,mDAAQ;AAChB;AACA;AACA,yHAAyH,yDAAc,iBAAiB,yDAAc,iBAAiB,yDAAc,gBAAgB,yDAAc;AACnO;;AAEA,IAAI,qDAAU;AACd,MAAM,kDAAO;AACb,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACO;AACP,2BAA2B,yDAAS;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,GAAG,KAAK,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,aAAa;AACb;AACA;AACA,sBAAsB,+CAAM;AAC5B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrxBA;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,WAAW,eAAe,MAAM;AAC9C,cAAc,WAAW,cAAc,MAAM;AAC7C;AACA,cAAc,WAAW,6BAA6B,MAAM;AAC5D;AACA;AACA,cAAc,WAAW,oCAAoC,MAAM;AACnE;AACA,cAAc,WAAW,oBAAoB,MAAM;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,yBAAyB;AACvC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,gCAAgC;AAC9C,cAAc,oBAAoB;AAClC,cAAc,0BAA0B;AACxC,cAAc,0BAA0B;AACxC,cAAc,oBAAoB;AAClC,cAAc,wBAAwB;AACtC,cAAc,kBAAkB;AAChC,cAAc,gBAAgB;AAC9B,cAAc,cAAc;AAC5B;;AAE8C;AAC0C;AACvC;AACS;AACN;AACK;AACe;;AAExE;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACO;AACP,oBAAoB,sEAAa;AACjC;AACA,eAAe,6DAAiB;AAChC,sBAAsB,6DAAiB;AACvC,KAAK;AACL,GAAG;AACH,EAAE,kEAAsB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,kDAAO;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA,8CAA8C,0DAAiB;AAC/D;AACA,KAAK;AACL;AACA,YAAY,8CAAO;AACnB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sEAAyB,GAAG,uDAAY;AACnD;AACA;AACA;AACA;AACA,0BAA0B,qDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;ACzIqC;AACC;AACtC;AACA;AACA;AACA;AACA,8CAAM;AACN;AACA;AACA,IAAI;AACJ,IAAI,mDAAQ;AACZ;AACA,CAAC;AACM;AACP;AACA;AACO;AACP;AACA;AACA,8CAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9BmD;AACL;AACA;;AAE9C;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAU,wBAAwB,MAAM,GAAG,KAAK;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oDAAS,GAAG;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACO,gDAAgD,2DAAS,uBAAuB,EAAE,uDAAY;AACrG;;;;;;;;;;;;;;;;;AC9DoD;;AAEpD;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,UAAU,iEAAsB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AAC+C,CAAC;;AAEzC;AACP,SAAS,yDAAY;AACrB;AACO;AACP,SAAS,yDAAY;AACrB;AACO;AACP,SAAS,yDAAY;AACrB;AACA;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;;AAE2D;AACgG;AAC/G;AAC5C,sBAAsB,6DAAkB,CAAC,qDAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kDAAO;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS,wDAAa;AAClC;AACA;AACA,YAAY,qDAAU;AACtB;AACA;AACA;AACA,KAAK;AACL,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,wDAAa;AACpC;AACA,cAAc,qDAAU,uCAAuC,KAAK;AACpE;AACA,YAAY;AACZ,YAAY,kDAAO,8CAA8C,KAAK;AACtE;AACA;AACA,SAAS,IAAI;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU,kDAAO,mBAAmB,IAAI;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mDAAQ;AACd;AACA;AACA;AACA;AACA,QAAQ,kDAAO;AACf;AACA,MAAM,SAAS,wDAAa;AAC5B,WAAW,wEAAkB;AAC7B,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wDAAa;AACtB,MAAM,kDAAO;AACb;AACA;AACA;AACA;AACA,QAAQ,kDAAO,8CAA8C,EAAE;AAC/D;AACA;AACA;AACA,aAAa,kDAAO;AACpB,UAAU,kDAAO,oBAAoB,GAAG;AACxC;AACA,UAAU,uBAAuB,4CAAK;AACtC,UAAU,kDAAO,oBAAoB,GAAG;AACxC;AACA;AACA,QAAQ;AACR,aAAa,oDAAS;AACtB,UAAU,kDAAO,oBAAoB,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,wDAAa,aAAa,oDAAS,GAAG;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAU;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAS;AACvB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,wDAAa;AACtB,MAAM,mDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAa,qBAAqB,wDAAa;AACzD,iCAAiC;AACjC;AACA;AACA;AACA,QAAQ;AACR,QAAQ,kDAAO,mCAAmC,OAAO;AACzD;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,SAAS,wDAAa;AACtB,MAAM,mDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,cAAc,wDAAa,sCAAsC,wDAAa;AAC9E,qCAAqC,gDAAS;AAC9C,iDAAiD,qBAAqB;AACtE,YAAY;AACZ;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN,MAAM,mDAAQ;AACd;AACA;AACA,WAAW,wDAAa;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,wDAAa;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS,wDAAa;AACtB,MAAM,mDAAQ;AACd;AACA;AACA,yBAAyB,oDAAS;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,aAAa;AAC3F;AACA;AACA;AACA,UAAU;AACV,UAAU,kDAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChf0D;AACJ;AACjB;AACrC;AACA;AACA;AACA;AACA;AACA;AACO,yCAAyC;AACzC;AACA;AACA;AACA;;AAEP;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,wDAAK;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,oDAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACP;AACA,aAAa,8CAAM;AACnB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,aAAa,wDAAS;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,aAAa,wDAAS;AACtB;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,aAAa,qDAAU;AACvB;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChOO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;ACjL8C;AACT;AACrC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAO;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAM;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,+BAA+B,sCAAsC;AACrE;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI,kDAAO;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACoD;AACpD;;;;;;;;;;;;;;;;;;;;;;AC/I+C;AACI;AAC2B;AAC7C;;AAEjC;AACO;AACA,kCAAkC,8CAAI;AAC7C,SAAS,sFAAQ;AACjB,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,2BAA2B,wDAAS;AACpC,uBAAuB,gEAAqB;AAC5C,mCAAmC,IAAI;AACvC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;ACzBO;AACA;AACA;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA,cAAc,iBAAiB;AAC/B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACoC;AACoB;AACC;AACpB;;AAErC;;AAEA;;AAEA;AACA;;AAEA;AACA,oBAAoB,sEAAa;AACjC;AACA;AACA,CAAC;AACD,8CAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,8BAA8B,iDAAM;AACpC,gBAAgB,yDAAc;AAC9B;AACA;AACA;AACA,IAAI,iDAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAuB;AAC1C,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,+CAAc;AACtB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR,QAAQ,+CAAc;AACtB;AACA,KAAK;AACL;AACA,6FAA6F,aAAa;AAC1G;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU,8CAAa,WAAW,8CAAa,eAAe,8CAAa;AAC3E;AACA;AACA,iBAAiB,8CAAa,eAAe,8CAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,CAAC;AACD,uDAAsB;AACf;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACK;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/JsC;;AAEtC;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA,UAAU,kDAAO,IAAI,WAAW,kBAAkB,MAAM,SAAS,QAAQ,GAAG;AAC5E;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBkD;AACP;AAC3C;AACA;AACA;AACA;;AAEO,aAAa,iEAAQ;AAC5B,SAAS,wEAAa,GAAG,yEAAc,GAAG,yEAAc;AACxD,CAAC;AACD,iBAAiB,wDAAK;AACtB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,UAAU;AACV;AACO;AACA;AACA;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG,aAAa;AAChB;AACO;AACP,yFAAyF,aAAa;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2EAA2E,eAAe;AAC1F;AACA;AACA,4BAA4B;AAC5B;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACA;AACA;AACA;AACA;AACA;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbqK;AAChH;AACkG;AAC9G;AACW;AACgC;AACkC;AAC/G;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,0EAA+B;AACvF,2CAA2C,6DAAkB;AACtD;AACP,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA,IAAI,mDAAQ;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAI,mDAAQ;AACZ;AACA;AACA;AACA,IAAI,mDAAQ;AACZ;AACA;AACA;AACA;AACA;AACA,OAAO,wDAAa;AACpB,IAAI,mDAAQ;AACZ;AACA;AACA;AACA,SAAS,mDAAQ,kBAAkB,mDAAQ;AAC3C,MAAM,mDAAQ;AACd;AACA;AACA,SAAS,mDAAQ,kBAAkB,mDAAQ;AAC3C,MAAM,mDAAQ;AACd;AACA;AACA,IAAI;AACJ,SAAS,mDAAQ;AACjB,MAAM,mDAAQ;AACd;AACA;AACA,IAAI;AACJ,SAAS,mDAAQ;AACjB,MAAM,mDAAQ;AACd;AACA;AACA,IAAI;AACJ,uFAAuF,mDAAQ,8BAA8B,mDAAQ;AACrI,MAAM,mDAAQ;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,mDAAQ,IAAI,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACA;;AAEP;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACO;AACP;AACA,YAAY,8DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,mDAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mDAAQ,iEAAiE,iBAAiB,kCAAkC,iBAAiB;AACjJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,gCAAgC,2BAA2B;AAC3D;AACA;AACA,qBAAqB;AACrB;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,+DAAoB;AAC5C,eAAe,mDAAY;AAC3B,IAAI;AACJ;AACA,KAAK,iEAAkB;AACvB,KAAK,gEAAiB;AACtB,IAAI,EAAE,qEAAkB,qCAAqC,oEAAqB;AAClF;AACA;AACA;AACA;AACA,2CAA2C,IAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,mDAAY;AAC3B,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM,gBAAgB,sDAAW;AACjC;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACO;AACP;AACA,OAAO,2DAAgB;AACvB;AACA,gBAAgB,sDAAW;AAC3B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA,mBAAmB,iEAAgB;AACnC;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mBAAmB,gFAAyB;AAC5C,0BAA0B,kEAAe;AACzC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,+DAA+D,sDAAW;AAC1E;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACO;AACP,8BAA8B,wDAAa;AAC3C,IAAI,mDAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAA+B;AACvC,SAAS,sDAAW;AACpB,MAAM,mDAAQ,oCAAoC,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAA+B;AAC9C;AACA,cAAc,6DAAkB,CAAC,0EAA+B;AAChE;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,+BAA+B,6DAAkB,QAAQ,6DAAkB;AAC3E;AACA;AACA;AACA,aAAa,kDAAO;AACpB,UAAU,mDAAQ;AAClB,UAAU;AACV,UAAU,mDAAQ;AAClB,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ,eAAe,oDAAS,eAAe,oDAAS;AAChD,YAAY,mDAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA,mHAAmH,kBAAkB,GAAG,mBAAmB;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,oDAAS,qBAAqB,oDAAS;AAChF,UAAU,mDAAQ;AAClB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,6DAAkB;AAC/C;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN,oCAAoC,6DAAkB,YAAY,6DAAkB;AACpF,0CAA0C,0EAA+B,YAAY,0EAA+B;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,MAAM,IAAI;AACV,yBAAyB,kDAAO;AAChC;AACA,qEAAqE,EAAE,kDAAM;AAC7E;AACA;AACA,4BAA4B,oDAAS;AACrC;AACA;AACA,yDAAyD,kDAAM,2BAA2B,kDAAM;AAChG,8BAA8B,kDAAM,kBAAkB,+CAAI,uBAAuB,kDAAM,GAAG,0EAA+B,+CAA+C,kDAAM;AAC9K,kFAAkF,kDAAM;AACxF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAqB;AACxC,oBAAoB,iEAAkB;AACtC;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4CAA4C,6DAAkB,QAAQ,6DAAkB;AACxF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,0EAA+B;AAClD,6EAA6E,6DAAkB,CAAC,0EAA+B;AAC/H;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,yEAAyE;AACzE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,iDAAiD,6DAAkB;AACnE;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAqB,4BAA4B,iEAAkB;AAClG;AACA;AACA,+BAA+B,oEAAqB,4BAA4B,gEAAiB;AACjG;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7uByE;AACzE;AACA,eAAe,oEAAkB,QAAQ;AACzC,qBAAqB,kEAAgB,YAAY,kEAAgB;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,kEAAgB;AAC1C;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;AACA;;AAErC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,cAAc,YAAY,IAAI,IAAI;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,UAAU;AACV,UAAU,kDAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,yBAAyB,8CAAM;AAC/B,eAAe,8CAAM;AACrB;AACA,gBAAgB,KAAK,EAAE,0CAA0C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,QAAQ;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnR2E;AACtB;AAC4B;AACE;AACwG;AAClF;AACpE;AACJ;AACgB;AACe;AACzD;AACA;AACA;;AAEP;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB,mEAAiB;AACjC,IAAI;AACJ;AACA;AACA,sBAAsB,8CAAM;AAC5B,oCAAoC,sEAAkB,IAAI,0DAAc;AACxE;AACA;AACA;AACA,OAAO,8EAA2B;AAClC,OAAO,+EAA4B;AACnC;AACA;AACA,aAAa,6EAA0B;AACvC;AACA;AACA,uBAAuB,6EAAsB,EAAE,6EAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,2DAA2D,SAAS,2BAA2B;AAC/F,8DAA8D,UAAU,QAAQ;AAChF;AACA,mCAAmC;AACnC,6BAA6B,IAAI,GAAG,0BAA0B,EAAE,iBAAiB,QAAQ,cAAc,EAAE,cAAc,WAAW,SAAS,OAAO,EAAE,OAAO;AAC3J;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA,kDAAkD,8BAA8B,SAAS;AACzF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe,6DAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,YAAY,mDAAQ,IAAI,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,UAAU,KAAK;AACf;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAe;AAC3B,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,6CAA6C;AACvD;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,qCAAqC,sEAAkB;AACvD,iBAAiB,sEAAkB;AACnC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,4GAA4G,+BAA+B;AAC3I;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA,gBAAgB,sEAAkB;AAClC,GAAG;AACH;;AAEA;AACA;AACA;AACO;AACP,OAAO,0DAAe;AACtB;AACA;AACA;AACA;AACA;AACA,6EAAuB,CAAC,6EAAsB;;AAE9C;AACA;AACA;AACA,6EAAuB,CAAC,0FAAmC;;AAE3D;AACA;AACA;AACA;AACA;AACO;AACP,+EAA+E,8DAAc;AAC7F,aAAa,gFAA6B,MAAM,sEAAkB;AAClE,4BAA4B,8EAA2B;AACvD;AACA;AACA,IAAI;AACJ,+BAA+B,8EAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAAuB,CAAC,6EAAsB;AACvC;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,2BAA2B,8CAAI,uCAAuC;AAC7E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChTqD;AACR;AACQ;AAChB;AACqE;AACpE;AACL;AACO;AACkJ;AAC9G;AAC5E;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB,QAAQ,uBAAuB;AAC/G,uCAAuC,yDAAc,aAAa,yDAAc;;AAEvF;AACA,uDAAuD,0DAAc,eAAe,oDAAS;;AAE7F;AACA,mDAAmD,qDAAU;AACtD;AACP;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO,qCAAqC,8CAAI;AAChD;AACA;AACA,sFAAsF,uDAAgB;AACtG;AACA;AACA,+BAA+B,8CAAM;AACrC;AACA,oBAAoB,kDAAO;AAC3B;AACA;AACA;AACA,2BAA2B,kDAAO;AAClC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,+CAAI;AAC5B,kCAAkC,+CAAI,8BAA8B,mEAAwB;AAC5F;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,6DAAa;AACxG,0FAA0F,uDAAgB;AAC1G;AACA;AACA,0BAA0B,8CAAM;AAChC,kCAAkC,8CAAM;AACxC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,sDAAsD,EAAE,iEAAsB;AAC9E,wBAAwB,8CAAM;AAC9B,wBAAwB,8CAAM;AAC9B;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAM;AACzC;AACA,QAAQ,kDAAO,+EAA+E,sBAAsB,sBAAsB;AAC1I;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,wBAAwB,8CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU,qDAAU,8CAA8C,yBAAyB;AAC3F,sDAAsD;AACtD,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,oFAAoF,qDAAU;AAC9F;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA,MAAM,4CAAW,CAAC,iDAAM;AACxB,KAAK;AACL,mBAAmB,8CAAI;AACvB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,6DAAa;AACxG,0FAA0F,uDAAgB;AAC1G;AACA;AACA,4FAA4F,8DAAc,kHAAkH,8CAAO,kGAAkG,6DAAa;AAClV,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,mDAAQ;AAChB;AACA;AACA,QAAQ,qDAAU,8CAA8C,UAAU,OAAO,KAAK,SAAS,4BAA4B;AAC3H;AACA,YAAY,gDAAK,iCAAiC,kDAAO;AACzD;AACA;AACA;AACA;AACA,YAAY;AACZ,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA,2BAA2B,+CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8CAAM;AAChD,gHAAgH,yDAAc;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,8CAAM;AACrC,8BAA8B,8CAAM;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,EAAE,yDAAc;AAC3D,oCAAoC,yDAAc;AAClD;AACA,IAAI,kDAAO,wCAAwC,oDAAoD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,IAAI,kDAAO,wCAAwC,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,sCAAsC,8CAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAAM;AACrC;AACA;AACA,yBAAyB,8DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,8CAAO;AACxE,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,8CAAM;AACR,QAAQ,qDAAU,8CAA8C,qDAAU;AAC1E,MAAM,mDAAQ;AACd;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,gCAAgC,IAAI,KAAK,gCAAgC;AACzE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0BAA0B,oDAAS;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAO,YAAY,KAAK,8BAA8B,WAAW,8CAA8C,eAAe,qBAAqB;AAC3J;AACA,QAAQ;AACR,QAAQ,kDAAO,uCAAuC,KAAK,0FAA0F,UAAU,oCAAoC,qBAAqB;AACxN;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6BAA6B;AACvE,SAAS;AACT;AACA,0CAA0C,iDAAiD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0CAA0C;AACnD;AACA,KAAK;AACL;AACA,yCAAyC;AACzC;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,kDAAO;AACtB;AACA;AACA;AACA;AACA;AACA,yFAAyF,sEAAsB;AAC/G;AACA;AACA,8BAA8B,8CAAM;AACpC,6BAA6B,8CAAM;AACnC;AACA;AACA;AACA;AACA,+CAA+C,kDAAK;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAc;AACpC,8CAA8C,IAAI,GAAG,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,uEAAuE,8CAAO,GAAG;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI,GAAG,eAAe;AACpC,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB,uDAAY;AAClC;AACA;AACA;AACA;AACA,YAAY,gDAAK;AACjB,aAAa,kDAAO;AACpB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACO,+BAA+B,+DAAc;AACpD;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzmBmK;AAC9H;AACuB;AACuB;AACnB;AACyF;AAC5F;AACG;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,8CAAM;AACN,cAAc,oDAAS;AACvB,CAAC;AACD,gBAAgB,yEAAqB;;AAErC;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE,8CAAM;AACR;AACA;AACA;AACA;AACA,UAAU,wDAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe,yEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAA6B,MAAM,sEAAkB;AACpE,8BAA8B,2EAAwB;AACtD,4BAA4B,gFAA6B;AACzD;AACA;AACA;AACA,qBAAqB,UAAU,4BAA4B,OAAO;AAClE;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,aAAa,mDAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAO;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qDAAU,+CAA+C,WAAW;AAC1E;AACA,MAAM,uDAAY;AAClB,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qDAAU,0CAA0C,WAAW;AACrE;AACA,MAAM,+DAAoB;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qDAAU,6BAA6B,OAAO;AAC3D;AACA,kCAAkC,kDAAO;AACzC,aAAa,kDAAO,oBAAoB,KAAK;AAC7C;AACA;AACA,aAAa,kDAAO;AACpB;AACA;AACA,aAAa,kDAAO,uCAAuC,OAAO;AAClE;AACA,uBAAuB,yEAAkB,EAAE,6EAAc,CAAC,sEAAkB;AAC5E,OAAO,2EAAwB;AAC/B,OAAO,0EAAuB;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ,2BAA2B;AAChD,aAAa,QAAQ;AACrB,eAAe,SAAS,2CAA2C;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ,2BAA2B;AAChD,eAAe,SAAS;AACxB;AACA;AACA;AACA,MAAM,kDAAO,sEAAsE,KAAK,yEAAyE;AACjK;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAO,6BAA6B,iBAAiB,oBAAoB,YAAY,yBAAyB;AACpH;AACA;AACA,+HAA+H,gDAAK;AACpI,MAAM,kDAAO,0DAA0D,iBAAiB,WAAW;AACnG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,UAAU,8CAAM;AAChB,aAAa,mEAAiB;AAC9B,WAAW,yEAAuB;AAClC,CAAC;AACD;AACA;AACA;AACA,cAAc,0DAAe;AAC7B;AACA;AACA,CAAC;;AAED;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB,cAAc,QAAQ;AACtB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzVqC;AACG;AACO;AACT;AACmC;AACnD;AACsB;AACT;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA,gDAAgD,IAAI,GAAG,mCAAmC;AAC1F,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,mCAAmC;AAC/C,YAAY,iBAAiB;AAC7B;AACO;AACP;AACA;AACO;AACP;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,+FAA+F,aAAa;AACrG;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0DAAO;AAChB;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA,GAAG;AACH;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA,0EAA0E,aAAa;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAM;AACvB;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA,mCAAmC,aAAa,cAAc,QAAQ,kBAAkB,mBAAmB;AAC3G;AACA;AACO;AACP;AACA;AACO;AACP,WAAW,8CAAM;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;AACO;AACP;AACA,MAAM,0DAAO,YAAY,wDAAK;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACO;AACP,SAAS,wDAAK;AACd;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa;AACb;AACO;AACP,MAAM,uDAAI;AACV,6BAA6B;AAC7B;AACA;AACA,GAAG;AACH;AACO;AACP,SAAS,uDAAI;AACb;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,YAAY;AACZ;AACO;AACP,MAAM,uDAAI;AACV,oCAAoC;AACpC;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,SAAS;AACnB,WAAW;AACX;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA,aAAa,wDAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,YAAY;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS,QAAQ,kBAAkB;AAC9E;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,MAAM,WAAW,cAAc;AACjF;AACA,YAAY;AACZ;AACO;AACP,8CAA8C,GAAG,GAAG;AACpD;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,YAAY;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA,oBAAoB,SAAS,MAAM,yBAAyB;AAC5D;AACA;AACA;AACA;AACA,wBAAwB,UAAU,aAAa;AAC/C;AACA,aAAa,IAAI;AACjB;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP,0BAA0B,uDAAI,6BAA6B,uDAAI;AAC/D;AACA;AACA;AACO;AACP,uBAAuB,uDAAI;AAC3B;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,GAAG;AACH;AACO;AACP;AACA;AACA,GAAG;AACH;AACO;AACP;AACA,yBAAyB,aAAa;AACtC;AACO;AACP;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP,SAAS,8CAAM;AACf;;AAEA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA;AACO;AACP;AACA,uEAAuE,iBAAiB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,SAAS,EAAE,UAAU,IAAI,aAAa,cAAc;AACjE;AACO;AACP;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,KAAI;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACO;AACP,yLAAyL;AACzL;;AAEA;AACA;AACA;AACO;AACP;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA,GAAG;AACH;AACA,MAAM,aAAa,OAAO,WAAW;AACrC,4CAA4C,UAAU,IAAI,OAAO;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACO;AACP,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG,IAAI;AACP;AACO;AACP,oFAAoF,EAAE,KAAK,EAAE,kBAAkB,EAAE,GAAG,SAAS;AAC7H;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wFAAwF,SAAS,oDAAoD,oCAAoC,0BAA0B,SAAS;AAC5N;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,wDAAwD;AAC1E;AACA,SAAS,gEAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gEAAa,aAAa,gEAAa;AAC9C;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAa;AACrB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,uDAAI;AACZ;AACA,MAAM;AACN,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA,IAAI;AACJ;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,6CAA6C;AACzF,UAAU,OAAO,GAAG,mBAAmB,GAAG,gBAAgB;AAC1D,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,aAAa,SAAS;AACtB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,eAAe;AAC5B;AACO;AACP,0BAA0B,uBAAuB;AACjD,aAAa,wDAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C,GAAG,OAAO,IAAI,QAAQ,EAAE;AACnE;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP,MAAM,wDAAK;AACX,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA;AACO;AACP,oBAAoB;;AAEpB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,CAAC;;AAED;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnwCsD;AACA;AACf;AAChC;AACP;AACA,YAAY,8DAAc;AAC1B,SAAS,8DAAc;AACvB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,MAAM;AACN,MAAM,mDAAQ;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtBA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,aAAa,oBAAoB;AACjC;AACO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;ACxDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCmC;AAC5B;AACP,SAAS,iDAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,GAAG,KAAK;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3DsC;AAC/B;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0EAA0E,aAAa;AACvF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAkB;AAClB,cAAc;AACd;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA,8CAAM;AACN;AACA,CAAC;;AAED;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,iGAAiG,eAAe;AAChH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACO;AACA;AACP;;;;;;;;;;;;;;;;;;;;ACtY0F;AAC3C;AACxC,qBAAqB,2DAAS,kBAAkB,MAAK,GAAG,CAAgB;AACxE,kBAAkB,2DAAS,eAAe,MAAK,GAAG,CAAa;AAC/D;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,eAAe,0BAA0B;AACzC;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9BO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,0EAA0E,aAAa;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACO;;AAEP;AACA;AACO;;AAEP;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;AC7CyC;AACuB;AACZ;AACpD;AACA;AACA;AACO;AACP;AACA,gBAAgB,gDAAS;AACzB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oGAAoG,uDAAY;AAChH;AACA;AACA;AACA;AACA,kBAAkB,oDAAS;AAC3B;AACA,aAAa,iEAAe;AAC5B,oBAAoB,oDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc,mDAAQ;AACtB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,kDAAS;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1I0F;AACrD;AACJ;AACoB;AACA;AAC9C;AACA;AACP,8IAA8I,gDAAS,mBAAmB,gDAAS,kBAAkB,gDAAS,cAAc,gDAAS,cAAc,gDAAS,iBAAiB,oDAAa,SAAS,gDAAS,SAAS,gDAAS,aAAa,4CAAK,cAAc,gDAAS,eAAe,oDAAa,iBAAiB,gDAAS;AAC7Z;AACA,UAAU,gDAAS,iBAAiB,gDAAS,0DAA0D,gDAAS,iBAAiB,gDAAS,gBAAgB,gDAAS;AACnK;AACA,cAAc,gDAAS,oBAAoB,+CAAQ,aAAa,oDAAa,mBAAmB,gDAAS,kBAAkB,gDAAS,kBAAkB,gDAAS,qBAAqB,gDAAS,sBAAsB,oDAAa,mBAAmB,gDAAS,gBAAgB,oDAAa,WAAW,gDAAS,WAAW,oDAAa,qBAAqB,oDAAa,iBAAiB,oDAAa;;AAErY;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,uBAAuB,wDAAa,8EAA8E,wDAAa;AAC/H,iBAAiB,mDAAQ,aAAa,mDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM,kDAAO,aAAa,aAAa;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA,YAAY,8DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO,2BAA2B,8CAAI;AACtC;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE,8CAAM;AACd;AACA,MAAM,mDAAQ;AACd;AACA,gDAAgD,kEAAgB,GAAG,aAAa,QAAQ,aAAa;AACrG,8BAA8B,kEAAgB,GAAG,aAAa,SAAS,iBAAiB;AACxF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACH;AACgB;AACQ;AACd;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,IAAI;AAC7F;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA,YAAY,8DAAc;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8CAAM;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA,6DAA6D,WAAW,IAAI,6BAA6B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oFAAoF,iDAAW;AAC/F;AACA;AACA;AACA,uBAAuB,8CAAM;AAC7B,OAAO,8CAAM;AACb;AACA;AACA,GAAG;AACH;AACO;AACP,YAAY,8CAAM,wBAAwB,QAAQ,GAAG;AACrD;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uCAAuC,uDAAY;AACnD;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA,IAAI,mDAAQ,uCAAuC,IAAI;AACvD;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,mDAAQ,aAAa,cAAc,iBAAiB,iBAAiB;AAC3E,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU,kDAAO,+DAA+D;AAChF,UAAU;AACV;AACA,UAAU,4DAAe;AACzB;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI,IAAY;AAChB,EAAE,8CAAM;AACR;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,uBAAuB,8DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;ACpOe;AACf;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B;AAC7B,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AC7TA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA,4HAA4H;AAC5H;AACA;;;;;;;;;;;;;;;;ACRO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;UC3BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNyC;AACzC;AACA;AACA,qCAAqC,kDAAO;AAC5C;AACA,CAAC;AACD","sources":["webpack://prebid.js/./libraries/creative-renderer-display/renderer.js","webpack://prebid.js/./libraries/gptUtils/gptUtils.js","webpack://prebid.js/./modules/debugging/bidInterceptor.js","webpack://prebid.js/./modules/debugging/debugging.js","webpack://prebid.js/./modules/debugging/legacy.js","webpack://prebid.js/./modules/debugging/pbsInterceptor.js","webpack://prebid.js/./modules/debugging/responses.js","webpack://prebid.js/./src/Renderer.js","webpack://prebid.js/./src/activities/activities.js","webpack://prebid.js/./src/activities/activityParams.js","webpack://prebid.js/./src/activities/modules.js","webpack://prebid.js/./src/activities/params.js","webpack://prebid.js/./src/activities/redactor.js","webpack://prebid.js/./src/activities/rules.js","webpack://prebid.js/./src/adRendering.js","webpack://prebid.js/./src/adUnits.js","webpack://prebid.js/./src/adapter.js","webpack://prebid.js/./src/adapterManager.js","webpack://prebid.js/./src/adapters/bidderFactory.js","webpack://prebid.js/./src/adloader.js","webpack://prebid.js/./src/ajax.js","webpack://prebid.js/./src/auction.js","webpack://prebid.js/./src/auctionIndex.js","webpack://prebid.js/./src/auctionManager.js","webpack://prebid.js/./src/bidTTL.js","webpack://prebid.js/./src/bidderSettings.js","webpack://prebid.js/./src/bidfactory.js","webpack://prebid.js/./src/buildOptions.js","webpack://prebid.js/./src/config.js","webpack://prebid.js/./src/consentHandler.js","webpack://prebid.js/./src/constants.js","webpack://prebid.js/./src/cpmBucketManager.js","webpack://prebid.js/./src/creativeRenderers.js","webpack://prebid.js/./src/eventTrackers.js","webpack://prebid.js/./src/events.js","webpack://prebid.js/./src/fpd/oneClient.js","webpack://prebid.js/./src/hook.js","webpack://prebid.js/./src/mediaTypes.js","webpack://prebid.js/./src/native.js","webpack://prebid.js/./src/prebidGlobal.js","webpack://prebid.js/./src/refererDetection.js","webpack://prebid.js/./src/storageManager.js","webpack://prebid.js/./src/targeting.js","webpack://prebid.js/./src/userSync.js","webpack://prebid.js/./src/utils.js","webpack://prebid.js/./src/utils/cpm.js","webpack://prebid.js/./src/utils/focusTimeout.js","webpack://prebid.js/./src/utils/ipUtils.js","webpack://prebid.js/./src/utils/objects.js","webpack://prebid.js/./src/utils/perfMetrics.js","webpack://prebid.js/./src/utils/promise.js","webpack://prebid.js/./src/utils/reducers.js","webpack://prebid.js/./src/utils/ttlCollection.js","webpack://prebid.js/./src/video.js","webpack://prebid.js/./src/videoCache.js","webpack://prebid.js/../../node_modules/dlv/index.js","webpack://prebid.js/../../node_modules/fun-hooks/no-eval/index.js","webpack://prebid.js/./buildOptions.mjs","webpack://prebid.js/../../node_modules/dset/dist/index.mjs","webpack://prebid.js/../../node_modules/klona/json/index.mjs","webpack://prebid.js/webpack/bootstrap","webpack://prebid.js/webpack/runtime/compat get default export","webpack://prebid.js/webpack/runtime/define property getters","webpack://prebid.js/webpack/runtime/hasOwnProperty shorthand","webpack://prebid.js/webpack/runtime/make namespace object","webpack://prebid.js/./modules/debugging/standalone.js"],"sourcesContent":["// this file is autogenerated, see creative/README.md\nexport const RENDERER = \"(()=>{\\\"use strict\\\";window.render=function(e,t,n){let{ad:r,adUrl:i,width:o,height:d,instl:h}=e,{mkFrame:l}=t;if(!r&&!i){const e=new Error(\\\"Missing ad markup or URL\\\");throw e.reason=\\\"noAd\\\",e}{if(null==d){const e=n.document?.body;[e,e?.parentElement].filter((e=>null!=e?.style)).forEach((e=>{e.style.height=\\\"100%\\\"}))}const e=n.document,t={width:o??\\\"100%\\\",height:d??\\\"100%\\\"};if(i&&!r?t.src=i:t.srcdoc=r,e.body.appendChild(l(e,t)),h&&n.frameElement){const e=n.frameElement.style;e.width=o?`${o}px`:\\\"100vw\\\",e.height=d?`${d}px`:\\\"100vh\\\"}}}})();\";\n//# sourceMappingURL=renderer.js.map\n","import { CLIENT_SECTIONS } from '../../src/fpd/oneClient.js';\nimport { compareCodeAndSlot, deepAccess, isGptPubadsDefined, uniques, isEmpty } from '../../src/utils.js';\nconst slotInfoCache = new Map();\nexport function clearSlotInfoCache() {\n  slotInfoCache.clear();\n}\n\n/**\n * Returns filter function to match adUnitCode in slot\n * @param {string} adUnitCode AdUnit code\n * @return {function} filter function\n */\nexport function isSlotMatchingAdUnitCode(adUnitCode) {\n  return slot => compareCodeAndSlot(slot, adUnitCode);\n}\n\n/**\n * @summary Export a k-v pair to GAM\n */\nexport function setKeyValue(key, value) {\n  if (!key || typeof key !== 'string') return false;\n  window.googletag = window.googletag || {\n    cmd: []\n  };\n  window.googletag.cmd = window.googletag.cmd || [];\n  window.googletag.cmd.push(() => {\n    window.googletag.pubads().setTargeting(key, value);\n  });\n}\n\n/**\n * @summary Uses the adUnit's code in order to find a matching gpt slot object on the page\n */\nexport function getGptSlotForAdUnitCode(adUnitCode) {\n  let matchingSlot;\n  if (isGptPubadsDefined()) {\n    // find the first matching gpt slot on the page\n    matchingSlot = window.googletag.pubads().getSlots().find(isSlotMatchingAdUnitCode(adUnitCode));\n  }\n  return matchingSlot;\n}\n\n/**\n * @summary Uses the adUnit's code in order to find a matching gptSlot on the page\n */\nexport function getGptSlotInfoForAdUnitCode(adUnitCode) {\n  if (slotInfoCache.has(adUnitCode)) {\n    return slotInfoCache.get(adUnitCode);\n  }\n  const matchingSlot = getGptSlotForAdUnitCode(adUnitCode);\n  let info = {};\n  if (matchingSlot) {\n    info = {\n      gptSlot: matchingSlot.getAdUnitPath(),\n      divId: matchingSlot.getSlotElementId()\n    };\n  }\n  !isEmpty(info) && slotInfoCache.set(adUnitCode, info);\n  return info;\n}\nexport const taxonomies = ['IAB_AUDIENCE_1_1', 'IAB_CONTENT_2_2'];\nexport function getSignals(fpd) {\n  const signals = Object.entries({\n    [taxonomies[0]]: getSegments(fpd, ['user.data'], 4),\n    [taxonomies[1]]: getSegments(fpd, CLIENT_SECTIONS.map(section => `${section}.content.data`), 6)\n  }).map(_ref => {\n    let [taxonomy, values] = _ref;\n    return values.length ? {\n      taxonomy,\n      values\n    } : null;\n  }).filter(ob => ob);\n  return signals;\n}\nexport function getSegments(fpd, sections, segtax) {\n  return sections.flatMap(section => deepAccess(fpd, section) || []).filter(datum => datum.ext?.segtax === segtax).flatMap(datum => datum.segment?.map(seg => seg.id)).filter(ob => ob).filter(uniques);\n}\n\n/**\n * Add an event listener on the given GAM event.\n * If GPT Pubads isn't defined, window.googletag is set to a new object.\n * @param {String} event\n * @param {Function} callback\n */\nexport function subscribeToGamEvent(event, callback) {\n  const register = () => window.googletag.pubads().addEventListener(event, callback);\n  if (isGptPubadsDefined()) {\n    register();\n    return;\n  }\n  window.googletag = window.googletag || {};\n  window.googletag.cmd = window.googletag.cmd || [];\n  window.googletag.cmd.push(register);\n}\n\n/**\n * @typedef {Object} Slot\n * @property {function(String): (String|null)} get\n * @property {function(): String} getAdUnitPath\n * @property {function(): String[]} getAttributeKeys\n * @property {function(): String[]} getCategoryExclusions\n * @property {function(String): String} getSlotElementId\n * @property {function(): String[]} getTargeting\n * @property {function(): String[]} getTargetingKeys\n * @see {@link https://developers.google.com/publisher-tag/reference#googletag.Slot GPT official docs}\n */\n\n/**\n * @typedef {Object} SlotRenderEndedEvent\n * @property {(String|null)} advertiserId\n * @property {(String|null)} campaignId\n * @property {(String[]|null)} companyIds\n * @property {(Number|null)} creativeId\n * @property {(Number|null)} creativeTemplateId\n * @property {(Boolean)} isBackfill\n * @property {(Boolean)} isEmpty\n * @property {(Number[]|null)} labelIds\n * @property {(Number|null)} lineItemId\n * @property {(String)} serviceName\n * @property {(string|Number[]|null)} size\n * @property {(Slot)} slot\n * @property {(Boolean)} slotContentChanged\n * @property {(Number|null)} sourceAgnosticCreativeId\n * @property {(Number|null)} sourceAgnosticLineItemId\n * @property {(Number[]|null)} yieldGroupIds\n * @see {@link https://developers.google.com/publisher-tag/reference#googletag.events.SlotRenderEndedEvent GPT official docs}\n */\n\n/**\n * @callback SlotRenderEndedEventCallback\n * @param {SlotRenderEndedEvent} event\n * @returns {void}\n */\n\n/**\n * Add an event listener on the GAM event 'slotRenderEnded'.\n * @param {SlotRenderEndedEventCallback} callback\n */\nexport function subscribeToGamSlotRenderEndedEvent(callback) {\n  subscribeToGamEvent('slotRenderEnded', callback);\n}\n//# sourceMappingURL=gptUtils.js.map\n","import { BANNER, VIDEO } from '../../src/mediaTypes.js';\nimport { deepAccess, deepClone, delayExecution, hasNonSerializableProperty, mergeDeep } from '../../src/utils.js';\nimport responseResolvers from './responses.js';\n\n/**\n * @typedef {Number|String|boolean|null|undefined} Scalar\n */\n\nexport function BidInterceptor() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  ({\n    setTimeout: this.setTimeout = window.setTimeout.bind(window)\n  } = opts);\n  this.logger = opts.logger;\n  this.rules = [];\n}\nObject.assign(BidInterceptor.prototype, {\n  DEFAULT_RULE_OPTIONS: {\n    delay: 0\n  },\n  serializeConfig(ruleDefs) {\n    const isSerializable = (ruleDef, i) => {\n      const serializable = !hasNonSerializableProperty(ruleDef);\n      if (!serializable && !deepAccess(ruleDef, 'options.suppressWarnings')) {\n        this.logger.logWarn(`Bid interceptor rule definition #${i + 1} contains non-serializable properties and will be lost after a refresh. Rule definition: `, ruleDef);\n      }\n      return serializable;\n    };\n    return ruleDefs.filter(isSerializable);\n  },\n  updateConfig(config) {\n    this.rules = (config.intercept || []).map((ruleDef, i) => this.rule(ruleDef, i + 1));\n  },\n  /**\n   * @typedef {Object} RuleOptions\n   * @property {Number} [delay=0] delay between bid interception and mocking of response (to simulate network delay)\n   * @property {boolean} [suppressWarnings=false] if enabled, do not warn about unserializable rules\n   *\n   * @typedef {Object} Rule\n   * @property {Number} no rule number (used only as an identifier for logging)\n   * @property {function({}, {}): boolean} match a predicate function that tests a bid against this rule\n   * @property {ReplacerFn} replacer generator function for mock bid responses\n   * @property {RuleOptions} options\n   */\n\n  /**\n   * @param {{}} ruleDef\n   * @param {Number} ruleNo\n   * @returns {Rule}\n   */\n  rule(ruleDef, ruleNo) {\n    return {\n      no: ruleNo,\n      match: this.matcher(ruleDef.when, ruleNo),\n      replace: this.replacer(ruleDef.then, ruleNo),\n      options: Object.assign({}, this.DEFAULT_RULE_OPTIONS, ruleDef.options),\n      paapi: this.paapiReplacer(ruleDef.paapi || [], ruleNo)\n    };\n  },\n  /**\n   * @typedef {Function} MatchPredicate\n   * @param {*} candidate a bid to match, or a portion of it if used inside an ObjectMather.\n   * e.g. matcher((bid, bidRequest) => ....) or matcher({property: (property, bidRequest) => ...})\n   * @param {*} bidRequest the request `candidate` belongs to\n   * @returns {boolean}\n   *\n   */\n\n  /**\n   * @param {*} matchDef matcher definition\n   * @param {Number} ruleNo\n   * @returns {MatchPredicate} a predicate function that matches a bid against the given `matchDef`\n   */\n  matcher(matchDef, ruleNo) {\n    if (typeof matchDef === 'function') {\n      return matchDef;\n    }\n    if (typeof matchDef !== 'object') {\n      this.logger.logError(`Invalid 'when' definition for debug bid interceptor (in rule #${ruleNo})`);\n      return () => false;\n    }\n    function matches(candidate, _ref) {\n      let {\n        ref = matchDef,\n        args = []\n      } = _ref;\n      return Object.entries(ref).map(_ref2 => {\n        let [key, val] = _ref2;\n        const cVal = candidate[key];\n        if (val instanceof RegExp) {\n          return val.exec(cVal) != null;\n        }\n        if (typeof val === 'function') {\n          return !!val(cVal, ...args);\n        }\n        if (typeof val === 'object') {\n          return matches(cVal, {\n            ref: val,\n            args\n          });\n        }\n        return cVal === val;\n      }).every(i => i);\n    }\n    return function (candidate) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return matches(candidate, {\n        args\n      });\n    };\n  },\n  /**\n   * @typedef {Function} ReplacerFn\n   * @param {*} bid a bid that was intercepted\n   * @param {*} bidRequest the request `bid` belongs to\n   * @returns {*} the response to mock for `bid`, or a portion of it if used inside an ObjectReplacer.\n   * e.g. replacer((bid, bidRequest) => mockResponse) or replacer({property: (bid, bidRequest) => mockProperty})\n   *\n   */\n\n  /**\n   * @param {*} replDef replacer definition\n   * @param ruleNo\n   * @return {ReplacerFn}\n   */\n  replacer(replDef, ruleNo) {\n    var _this = this;\n    if (replDef === null) {\n      return () => null;\n    }\n    replDef = replDef || {};\n    let replFn;\n    if (typeof replDef === 'function') {\n      replFn = _ref3 => {\n        let {\n          args\n        } = _ref3;\n        return replDef(...args);\n      };\n    } else if (typeof replDef !== 'object') {\n      this.logger.logError(`Invalid 'then' definition for debug bid interceptor (in rule #${ruleNo})`);\n      replFn = () => ({});\n    } else {\n      replFn = _ref4 => {\n        let {\n          args,\n          ref = replDef\n        } = _ref4;\n        const result = Array.isArray(ref) ? [] : {};\n        Object.entries(ref).forEach(_ref5 => {\n          let [key, val] = _ref5;\n          if (typeof val === 'function') {\n            result[key] = val(...args);\n          } else if (val != null && typeof val === 'object') {\n            result[key] = replFn({\n              args,\n              ref: val\n            });\n          } else {\n            result[key] = val;\n          }\n        });\n        return result;\n      };\n    }\n    return function (bid) {\n      const response = _this.responseDefaults(bid);\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      mergeDeep(response, replFn({\n        args: [bid, ...args]\n      }));\n      const resolver = responseResolvers[response.mediaType];\n      resolver && resolver(bid, response);\n      response.isDebug = true;\n      return response;\n    };\n  },\n  paapiReplacer(paapiDef, ruleNo) {\n    function wrap() {\n      let configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      return configs.map(config => {\n        return Object.keys(config).some(k => !['config', 'igb'].includes(k)) ? {\n          config\n        } : config;\n      });\n    }\n    if (Array.isArray(paapiDef)) {\n      return () => wrap(paapiDef);\n    } else if (typeof paapiDef === 'function') {\n      return function () {\n        return wrap(paapiDef(...arguments));\n      };\n    } else {\n      this.logger.logError(`Invalid 'paapi' definition for debug bid interceptor (in rule #${ruleNo})`);\n    }\n  },\n  responseDefaults(bid) {\n    const response = {\n      requestId: bid.bidId,\n      cpm: 3.5764,\n      currency: 'EUR',\n      ttl: 360,\n      creativeId: 'mock-creative-id',\n      netRevenue: false,\n      meta: {}\n    };\n    if (!bid.mediaType) {\n      response.mediaType = Object.keys(bid.mediaTypes ?? {})[0] ?? BANNER;\n    }\n    let size;\n    if (response.mediaType === BANNER) {\n      size = bid.mediaTypes?.banner?.sizes?.[0] ?? [300, 250];\n    } else if (response.mediaType === VIDEO) {\n      size = bid.mediaTypes?.video?.playerSize?.[0] ?? [600, 500];\n    }\n    if (Array.isArray(size)) {\n      [response.width, response.height] = size;\n    }\n    return response;\n  },\n  /**\n   * Match a candidate bid against all registered rules.\n   *\n   * @param {{}} candidate\n   * @param args\n   * @returns {Rule|undefined} the first matching rule, or undefined if no match was found.\n   */\n  match(candidate) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return this.rules.find(rule => rule.match(candidate, ...args));\n  },\n  /**\n   * Match a set of bids against all registered rules.\n   *\n   * @param bids\n   * @param bidRequest\n   * @returns {[{bid: *, rule: Rule}[], *[]]} a 2-tuple for matching bids (decorated with the matching rule) and\n   * non-matching bids.\n   */\n  matchAll(bids, bidRequest) {\n    const [matches, remainder] = [[], []];\n    bids.forEach(bid => {\n      const rule = this.match(bid, bidRequest);\n      if (rule != null) {\n        matches.push({\n          rule: rule,\n          bid: bid\n        });\n      } else {\n        remainder.push(bid);\n      }\n    });\n    return [matches, remainder];\n  },\n  /**\n   * Run a set of bids against all registered rules, filter out those that match,\n   * and generate mock responses for them.\n   *\n   * {{}[]} bids?\n   * {*} bidRequest\n   * {function(*)} addBid called once for each mock response\n   * addPaapiConfig called once for each mock PAAPI config\n   * {function()} done called once after all mock responses have been run through `addBid`\n   * returns {{bids: {}[], bidRequest: {}} remaining bids that did not match any rule (this applies also to\n   * bidRequest.bids)\n   */\n  intercept(_ref6) {\n    let {\n      bids,\n      bidRequest,\n      addBid,\n      addPaapiConfig,\n      done\n    } = _ref6;\n    if (bids == null) {\n      bids = bidRequest.bids;\n    }\n    const [matches, remainder] = this.matchAll(bids, bidRequest);\n    if (matches.length > 0) {\n      const callDone = delayExecution(done, matches.length);\n      matches.forEach(match => {\n        const mockResponse = match.rule.replace(match.bid, bidRequest);\n        const mockPaapi = match.rule.paapi(match.bid, bidRequest);\n        const delay = match.rule.options.delay;\n        this.logger.logMessage(`Intercepted bid request (matching rule #${match.rule.no}), mocking response in ${delay}ms. Request, response, PAAPI configs:`, match.bid, mockResponse, mockPaapi);\n        this.setTimeout(() => {\n          mockResponse && addBid(mockResponse, match.bid);\n          mockPaapi.forEach(cfg => addPaapiConfig(cfg, match.bid, bidRequest));\n          callDone();\n        }, delay);\n      });\n      bidRequest = deepClone(bidRequest);\n      bids = bidRequest.bids = remainder;\n    } else {\n      this.setTimeout(done, 0);\n    }\n    return {\n      bids,\n      bidRequest\n    };\n  }\n});\n//# sourceMappingURL=bidInterceptor.js.map\n","import { deepClone, delayExecution } from '../../src/utils.js';\nimport { BidInterceptor } from './bidInterceptor.js';\nimport { makePbsInterceptor } from './pbsInterceptor.js';\nimport { addHooks, removeHooks } from './legacy.js';\nconst interceptorHooks = [];\nlet bidInterceptor;\nlet enabled = false;\nfunction enableDebugging(debugConfig, _ref) {\n  let {\n    fromSession = false,\n    config,\n    hook,\n    logger\n  } = _ref;\n  config.setConfig({\n    debug: true\n  });\n  bidInterceptor.updateConfig(debugConfig);\n  resetHooks(true);\n  // also enable \"legacy\" overrides\n  removeHooks({\n    hook\n  });\n  addHooks(debugConfig, {\n    hook,\n    logger\n  });\n  if (!enabled) {\n    enabled = true;\n    logger.logMessage(`Debug overrides enabled${fromSession ? ' from session' : ''}`);\n  }\n}\nexport function disableDebugging(_ref2) {\n  let {\n    hook,\n    logger\n  } = _ref2;\n  bidInterceptor.updateConfig({});\n  resetHooks(false);\n  // also disable \"legacy\" overrides\n  removeHooks({\n    hook\n  });\n  if (enabled) {\n    enabled = false;\n    logger.logMessage('Debug overrides disabled');\n  }\n}\n\n// eslint-disable-next-line no-restricted-properties\nfunction saveDebuggingConfig(debugConfig) {\n  let {\n    sessionStorage = window.sessionStorage,\n    DEBUG_KEY\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!debugConfig.enabled) {\n    try {\n      sessionStorage.removeItem(DEBUG_KEY);\n    } catch (e) {}\n  } else {\n    if (debugConfig.intercept) {\n      debugConfig = deepClone(debugConfig);\n      debugConfig.intercept = bidInterceptor.serializeConfig(debugConfig.intercept);\n    }\n    try {\n      sessionStorage.setItem(DEBUG_KEY, JSON.stringify(debugConfig));\n    } catch (e) {}\n  }\n}\n\n// eslint-disable-next-line no-restricted-properties\nexport function getConfig(debugging) {\n  let {\n    getStorage = () => window.sessionStorage,\n    DEBUG_KEY,\n    config,\n    hook,\n    logger\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (debugging == null) return;\n  let sessionStorage;\n  try {\n    sessionStorage = getStorage();\n  } catch (e) {\n    logger.logError(`sessionStorage is not available: debugging configuration will not persist on page reload`, e);\n  }\n  if (sessionStorage != null) {\n    saveDebuggingConfig(debugging, {\n      sessionStorage,\n      DEBUG_KEY\n    });\n  }\n  if (!debugging.enabled) {\n    disableDebugging({\n      hook,\n      logger\n    });\n  } else {\n    enableDebugging(debugging, {\n      config,\n      hook,\n      logger\n    });\n  }\n}\nexport function sessionLoader(_ref3) {\n  let {\n    DEBUG_KEY,\n    storage,\n    config,\n    hook,\n    logger\n  } = _ref3;\n  let overrides;\n  try {\n    // eslint-disable-next-line no-restricted-properties\n    storage = storage || window.sessionStorage;\n    overrides = JSON.parse(storage.getItem(DEBUG_KEY));\n  } catch (e) {}\n  if (overrides) {\n    enableDebugging(overrides, {\n      fromSession: true,\n      config,\n      hook,\n      logger\n    });\n  }\n}\nfunction resetHooks(enable) {\n  interceptorHooks.forEach(_ref4 => {\n    let [getHookFn, interceptor] = _ref4;\n    getHookFn().getHooks({\n      hook: interceptor\n    }).remove();\n  });\n  if (enable) {\n    interceptorHooks.forEach(_ref5 => {\n      let [getHookFn, interceptor] = _ref5;\n      getHookFn().before(interceptor);\n    });\n  }\n}\nfunction registerBidInterceptor(getHookFn, interceptor) {\n  const interceptBids = function () {\n    return bidInterceptor.intercept(...arguments);\n  };\n  interceptorHooks.push([getHookFn, function (next) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    interceptor(next, interceptBids, ...args);\n  }]);\n}\nexport function bidderBidInterceptor(next, interceptBids, spec, bids, bidRequest, ajax, wrapCallback, cbs) {\n  const done = delayExecution(cbs.onCompletion, 2);\n  ({\n    bids,\n    bidRequest\n  } = interceptBids({\n    bids,\n    bidRequest,\n    addBid: wrapCallback(cbs.onBid),\n    addPaapiConfig: wrapCallback((config, bidRequest) => cbs.onPaapi({\n      bidId: bidRequest.bidId,\n      ...config\n    })),\n    done\n  }));\n  if (bids.length === 0) {\n    cbs.onResponse?.({}); // trigger onResponse so that the bidder may be marked as \"timely\" if necessary\n    done();\n  } else {\n    next(spec, bids, bidRequest, ajax, wrapCallback, {\n      ...cbs,\n      onCompletion: done\n    });\n  }\n}\nexport function install(_ref6) {\n  let {\n    DEBUG_KEY,\n    config,\n    hook,\n    createBid,\n    logger\n  } = _ref6;\n  bidInterceptor = new BidInterceptor({\n    logger\n  });\n  const pbsBidInterceptor = makePbsInterceptor({\n    createBid\n  });\n  registerBidInterceptor(() => hook.get('processBidderRequests'), bidderBidInterceptor);\n  registerBidInterceptor(() => hook.get('processPBSRequest'), pbsBidInterceptor);\n  sessionLoader({\n    DEBUG_KEY,\n    config,\n    hook,\n    logger\n  });\n  config.getConfig('debugging', _ref7 => {\n    let {\n      debugging\n    } = _ref7;\n    return getConfig(debugging, {\n      DEBUG_KEY,\n      config,\n      hook,\n      logger\n    });\n  }, {\n    init: true\n  });\n}\n//# sourceMappingURL=debugging.js.map\n","export let addBidResponseBound;\nexport let addBidderRequestsBound;\nexport function addHooks(overrides, _ref) {\n  let {\n    hook,\n    logger\n  } = _ref;\n  addBidResponseBound = addBidResponseHook.bind({\n    overrides,\n    logger\n  });\n  hook.get('addBidResponse').before(addBidResponseBound, 5);\n  addBidderRequestsBound = addBidderRequestsHook.bind({\n    overrides,\n    logger\n  });\n  hook.get('addBidderRequests').before(addBidderRequestsBound, 5);\n}\nexport function removeHooks(_ref2) {\n  let {\n    hook\n  } = _ref2;\n  hook.get('addBidResponse').getHooks({\n    hook: addBidResponseBound\n  }).remove();\n  hook.get('addBidderRequests').getHooks({\n    hook: addBidderRequestsBound\n  }).remove();\n}\n\n/**\n * @param {{bidder:string, adUnitCode:string}} overrideObj\n * @param {string} bidderCode\n * @param {string} adUnitCode\n * @returns {boolean}\n */\nexport function bidExcluded(overrideObj, bidderCode, adUnitCode) {\n  if (overrideObj.bidder && overrideObj.bidder !== bidderCode) {\n    return true;\n  }\n  if (overrideObj.adUnitCode && overrideObj.adUnitCode !== adUnitCode) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {string[]} bidders\n * @param {string} bidderCode\n * @returns {boolean}\n */\nexport function bidderExcluded(bidders, bidderCode) {\n  return Array.isArray(bidders) && bidders.indexOf(bidderCode) === -1;\n}\n\n/**\n * @param {Object} overrideObj\n * @param {Object} bidObj\n * @param {Object} bidType\n * @returns {Object} bidObj with overridden properties\n */\nexport function applyBidOverrides(overrideObj, bidObj, bidType, logger) {\n  return Object.keys(overrideObj).filter(key => ['adUnitCode', 'bidder'].indexOf(key) === -1).reduce(function (result, key) {\n    logger.logMessage(`bidder overrides changed '${result.adUnitCode}/${result.bidderCode}' ${bidType}.${key} from '${result[key]}.js' to '${overrideObj[key]}'`);\n    result[key] = overrideObj[key];\n    result.isDebug = true;\n    return result;\n  }, bidObj);\n}\nexport function addBidResponseHook(next, adUnitCode, bid, reject) {\n  const {\n    overrides,\n    logger\n  } = this;\n  if (bidderExcluded(overrides.bidders, bid.bidderCode)) {\n    logger.logWarn(`bidder '${bid.bidderCode}' excluded from auction by bidder overrides`);\n    return;\n  }\n  if (Array.isArray(overrides.bids)) {\n    overrides.bids.forEach(function (overrideBid) {\n      if (!bidExcluded(overrideBid, bid.bidderCode, adUnitCode)) {\n        applyBidOverrides(overrideBid, bid, 'bidder', logger);\n      }\n    });\n  }\n  next(adUnitCode, bid, reject);\n}\nexport function addBidderRequestsHook(next, bidderRequests) {\n  const {\n    overrides,\n    logger\n  } = this;\n  const includedBidderRequests = bidderRequests.filter(function (bidderRequest) {\n    if (bidderExcluded(overrides.bidders, bidderRequest.bidderCode)) {\n      logger.logWarn(`bidRequest '${bidderRequest.bidderCode}' excluded from auction by bidder overrides`);\n      return false;\n    }\n    return true;\n  });\n  if (Array.isArray(overrides.bidRequests)) {\n    includedBidderRequests.forEach(function (bidderRequest) {\n      overrides.bidRequests.forEach(function (overrideBid) {\n        bidderRequest.bids.forEach(function (bid) {\n          if (!bidExcluded(overrideBid, bidderRequest.bidderCode, bid.adUnitCode)) {\n            applyBidOverrides(overrideBid, bid, 'bidRequest', logger);\n          }\n        });\n      });\n    });\n  }\n  next(includedBidderRequests);\n}\n//# sourceMappingURL=legacy.js.map\n","import { deepClone, delayExecution } from '../../src/utils.js';\nexport function makePbsInterceptor(_ref) {\n  let {\n    createBid\n  } = _ref;\n  return function pbsBidInterceptor(next, interceptBids, s2sBidRequest, bidRequests, ajax, _ref2) {\n    let {\n      onResponse,\n      onError,\n      onBid,\n      onFledge\n    } = _ref2;\n    let responseArgs;\n    const done = delayExecution(() => onResponse(...responseArgs), bidRequests.length + 1);\n    function signalResponse() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      responseArgs = args;\n      done();\n    }\n    function addBid(bid, bidRequest) {\n      onBid({\n        adUnit: bidRequest.adUnitCode,\n        bid: Object.assign(createBid(bidRequest), {\n          requestBidder: bidRequest.bidder\n        }, bid)\n      });\n    }\n    bidRequests = bidRequests.map(req => interceptBids({\n      bidRequest: req,\n      addBid,\n      addPaapiConfig(config, bidRequest, bidderRequest) {\n        onFledge({\n          adUnitCode: bidRequest.adUnitCode,\n          ortb2: bidderRequest.ortb2,\n          ortb2Imp: bidRequest.ortb2Imp,\n          ...config\n        });\n      },\n      done\n    }).bidRequest).filter(req => req.bids.length > 0);\n    if (bidRequests.length > 0) {\n      const bidIds = new Set();\n      bidRequests.forEach(req => req.bids.forEach(bid => bidIds.add(bid.bidId)));\n      s2sBidRequest = deepClone(s2sBidRequest);\n      s2sBidRequest.ad_units.forEach(unit => {\n        unit.bids = unit.bids.filter(bid => bidIds.has(bid.bid_id));\n      });\n      s2sBidRequest.ad_units = s2sBidRequest.ad_units.filter(unit => unit.bids.length > 0);\n      next(s2sBidRequest, bidRequests, ajax, {\n        onResponse: signalResponse,\n        onError,\n        onBid\n      });\n    } else {\n      signalResponse(true, []);\n    }\n  };\n}\n//# sourceMappingURL=pbsInterceptor.js.map\n","import { BANNER, NATIVE, VIDEO } from '../../src/mediaTypes.js';\nimport { Renderer } from '../../src/Renderer.js';\nimport { getGptSlotInfoForAdUnitCode } from '../../libraries/gptUtils/gptUtils.js';\nconst ORTB_NATIVE_ASSET_TYPES = ['img', 'video', 'link', 'data', 'title'];\nexport default {\n  [BANNER]: (bid, bidResponse) => {\n    if (!bidResponse.hasOwnProperty('ad') && !bidResponse.hasOwnProperty('adUrl')) {\n      let [size, repeat] = (bidResponse.width ?? bidResponse.wratio) < (bidResponse.height ?? bidResponse.hratio) ? [bidResponse.width, 'repeat-y'] : [bidResponse.height, 'repeat-x'];\n      size = size == null ? '100%' : `${size}px`;\n      bidResponse.ad = `<html><body><div style=\"display: inline-block; height: ${bidResponse.height == null ? '100%' : bidResponse.height + 'px'}; width: ${bidResponse.width == null ? '100%' : bidResponse.width + 'px'}; background-image: url(https://vcdn.adnxs.com/p/creative-image/27/c0/52/67/27c05267-5a6d-4874-834e-18e218493c32.png); background-size: ${size}; background-repeat: ${repeat}\"></div></body></html>`;\n    }\n  },\n  [VIDEO]: (bid, bidResponse) => {\n    if (!bidResponse.hasOwnProperty('vastXml') && !bidResponse.hasOwnProperty('vastUrl')) {\n      bidResponse.vastXml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version=\"3.0\"><Ad><InLine><AdSystem>GDFP</AdSystem><AdTitle>Demo</AdTitle><Description><![CDATA[Demo]]></Description><Creatives><Creative><Linear ><Duration>00:00:11</Duration><VideoClicks><ClickThrough><![CDATA[https://prebid.org/]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery=\"progressive\" width=\"640\" height=\"360\" type=\"video/mp4\" scalable=\"true\" maintainAspectRatio=\"true\"><![CDATA[https://s3.amazonaws.com/files.prebid.org/creatives/PrebidLogo.mp4]]></MediaFile></MediaFiles></Linear></Creative></Creatives></InLine></Ad></VAST>';\n      bidResponse.renderer = Renderer.install({\n        url: 'https://cdn.jwplayer.com/libraries/l5MchIxB.js'\n      });\n      bidResponse.renderer.setRender(function (bid, doc) {\n        const parentId = getGptSlotInfoForAdUnitCode(bid.adUnitCode).divId ?? bid.adUnitCode;\n        const div = doc.createElement('div');\n        div.id = `${parentId}-video-player`;\n        doc.getElementById(parentId).appendChild(div);\n        const player = window.jwplayer(div.id).setup({\n          debug: true,\n          width: bidResponse.width,\n          height: bidResponse.height,\n          advertising: {\n            client: 'vast',\n            outstream: true,\n            endstate: 'close'\n          }\n        });\n        player.on('ready', async function () {\n          if (bid.vastUrl) {\n            player.loadAdTag(bid.vastUrl);\n          } else {\n            player.loadAdXml(bid.vastXml);\n          }\n        });\n      });\n    }\n  },\n  [NATIVE]: (bid, bidResponse) => {\n    if (!bidResponse.hasOwnProperty('native')) {\n      bidResponse.native = {\n        ortb: {\n          link: {\n            url: 'https://www.link.example',\n            clicktrackers: ['https://impression.example']\n          },\n          assets: bid.nativeOrtbRequest.assets.map(mapDefaultNativeOrtbAsset)\n        }\n      };\n    }\n  }\n};\nfunction mapDefaultNativeOrtbAsset(asset) {\n  const assetType = ORTB_NATIVE_ASSET_TYPES.find(type => asset.hasOwnProperty(type));\n  switch (assetType) {\n    case 'img':\n      return {\n        ...asset,\n        img: {\n          type: 3,\n          w: 600,\n          h: 500,\n          url: 'https://vcdn.adnxs.com/p/creative-image/27/c0/52/67/27c05267-5a6d-4874-834e-18e218493c32.png'\n        }\n      };\n    case 'video':\n      return {\n        ...asset,\n        video: {\n          vasttag: '<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version=\"3.0\"><Ad><InLine><AdSystem>GDFP</AdSystem><AdTitle>Demo</AdTitle><Description><![CDATA[Demo]]></Description><Creatives><Creative><Linear ><Duration>00:00:11</Duration><VideoClicks><ClickThrough><![CDATA[https://prebid.org/]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery=\"progressive\" width=\"640\" height=\"360\" type=\"video/mp4\" scalable=\"true\" maintainAspectRatio=\"true\"><![CDATA[https://s3.amazonaws.com/files.prebid.org/creatives/PrebidLogo.mp4]]></MediaFile></MediaFiles></Linear></Creative></Creatives></InLine></Ad></VAST>'\n        }\n      };\n    case 'data':\n      {\n        return {\n          ...asset,\n          data: {\n            value: '5 stars'\n          }\n        };\n      }\n    case 'title':\n      {\n        return {\n          ...asset,\n          title: {\n            text: 'Prebid Native Example'\n          }\n        };\n      }\n  }\n}\n//# sourceMappingURL=responses.js.map\n","import { loadExternalScript } from './adloader.js';\nimport { logError, logWarn, logMessage } from './utils.js';\nimport { getGlobal } from './prebidGlobal.js';\nimport { MODULE_TYPE_PREBID } from './activities/modules.js';\nconst pbjsInstance = getGlobal();\nconst moduleCode = 'outstream';\n\n/**\n * @typedef {object} Renderer\n *\n * A Renderer stores some functions which are used to render a particular Bid.\n * These are used in Outstream Video Bids, returned on the Bid by the adapter, and will\n * be used to render that bid unless the Publisher overrides them.\n */\n\nexport function Renderer(options) {\n  const {\n    url,\n    config,\n    id,\n    callback,\n    loaded,\n    adUnitCode,\n    renderNow\n  } = options;\n  this.url = url;\n  this.config = config;\n  this.handlers = {};\n  this.id = id;\n  this.renderNow = renderNow;\n  this.adUnitCode = adUnitCode;\n\n  // a renderer may push to the command queue to delay rendering until the\n  // render function is loaded by loadExternalScript, at which point the the command\n  // queue will be processed\n  this.loaded = loaded;\n  this.cmd = [];\n  this.push = func => {\n    if (typeof func !== 'function') {\n      logError('Commands given to Renderer.push must be wrapped in a function');\n      return;\n    }\n    this.loaded ? func.call() : this.cmd.push(func);\n  };\n\n  // bidders may override this with the `callback` property given to `install`\n  this.callback = callback || (() => {\n    this.loaded = true;\n    this.process();\n  });\n\n  // use a function, not an arrow, in order to be able to pass \"arguments\" through\n  this.render = function () {\n    const renderArgs = arguments;\n    const runRender = () => {\n      if (this._render) {\n        this._render.apply(this, renderArgs);\n      } else {\n        logWarn(`No render function was provided, please use .setRender on the renderer`);\n      }\n    };\n    if (isRendererPreferredFromAdUnit(adUnitCode)) {\n      logWarn(`External Js not loaded by Renderer since renderer url and callback is already defined on adUnit ${adUnitCode}`);\n      runRender();\n    } else if (renderNow) {\n      runRender();\n    } else {\n      // we expect to load a renderer url once only so cache the request to load script\n      this.cmd.unshift(runRender); // should render run first ?\n      loadExternalScript(url, MODULE_TYPE_PREBID, moduleCode, this.callback, this.documentContext);\n    }\n  }.bind(this); // bind the function to this object to avoid 'this' errors\n}\n\n/**\n * @param {{}} options\n * @return {Renderer}\n */\nRenderer.install = function (_ref) {\n  let {\n    url,\n    config,\n    id,\n    callback,\n    loaded,\n    adUnitCode,\n    renderNow\n  } = _ref;\n  return new Renderer({\n    url,\n    config,\n    id,\n    callback,\n    loaded,\n    adUnitCode,\n    renderNow\n  });\n};\nRenderer.prototype.getConfig = function () {\n  return this.config;\n};\nRenderer.prototype.setRender = function (fn) {\n  this._render = fn;\n};\nRenderer.prototype.setEventHandlers = function (handlers) {\n  this.handlers = handlers;\n};\nRenderer.prototype.handleVideoEvent = function (_ref2) {\n  let {\n    id,\n    eventName\n  } = _ref2;\n  if (typeof this.handlers[eventName] === 'function') {\n    this.handlers[eventName]();\n  }\n  logMessage(`Prebid Renderer event for id ${id} type ${eventName}`);\n};\n\n/*\n * Calls functions that were pushed to the command queue before the\n * renderer was loaded by `loadExternalScript`\n */\nRenderer.prototype.process = function () {\n  while (this.cmd.length > 0) {\n    try {\n      this.cmd.shift().call();\n    } catch (error) {\n      logError(`Error processing Renderer command on ad unit '${this.adUnitCode}':`, error);\n    }\n  }\n};\n\n/**\n * Checks whether creative rendering should be done by Renderer or not.\n * @param {Object} renderer Renderer object installed by adapter\n * @returns {Boolean}\n */\nexport function isRendererRequired(renderer) {\n  return !!(renderer && (renderer.url || renderer.renderNow));\n}\n\n/**\n * Render the bid returned by the adapter\n * @param {Object} renderer Renderer object installed by adapter\n * @param {Object} bid Bid response\n * @param {Document} doc context document of bid\n */\nexport function executeRenderer(renderer, bid, doc) {\n  let docContext = null;\n  if (renderer.config && renderer.config.documentResolver) {\n    docContext = renderer.config.documentResolver(bid, document, doc); // a user provided callback, which should return a Document, and expect the parameters; bid, sourceDocument, renderDocument\n  }\n  if (!docContext) {\n    docContext = document;\n  }\n  renderer.documentContext = docContext;\n  renderer.render(bid, renderer.documentContext);\n}\nfunction isRendererPreferredFromAdUnit(adUnitCode) {\n  const adUnits = pbjsInstance.adUnits;\n  const adUnit = adUnits.find(adUnit => {\n    return adUnit.code === adUnitCode;\n  });\n  if (!adUnit) {\n    return false;\n  }\n\n  // renderer defined at adUnit level\n  const adUnitRenderer = adUnit?.renderer;\n  const hasValidAdUnitRenderer = !!(adUnitRenderer && adUnitRenderer.url && adUnitRenderer.render);\n\n  // renderer defined at adUnit.mediaTypes level\n  const mediaTypeRenderer = adUnit?.mediaTypes?.video?.renderer;\n  const hasValidMediaTypeRenderer = !!(mediaTypeRenderer && mediaTypeRenderer.url && mediaTypeRenderer.render);\n  return !!(hasValidAdUnitRenderer && !(adUnitRenderer.backupOnly === true) || hasValidMediaTypeRenderer && !(mediaTypeRenderer.backupOnly === true));\n}\n//# sourceMappingURL=Renderer.js.map\n","/**\n * Activity (that are relevant for privacy) definitions\n *\n * ref. https://docs.google.com/document/d/1dRxFUFmhh2jGanzGZvfkK_6jtHPpHXWD7Qsi6KEugeE\n * & https://github.com/prebid/Prebid.js/issues/9546\n */\n\n/**\n * accessDevice: some component wants to read or write to localStorage or cookies.\n */\nexport const ACTIVITY_ACCESS_DEVICE = 'accessDevice';\n/**\n * syncUser: A bid adapter wants to run a user sync.\n */\nexport const ACTIVITY_SYNC_USER = 'syncUser';\n/**\n * enrichUfpd: some component wants to add user first-party data to bid requests.\n */\nexport const ACTIVITY_ENRICH_UFPD = 'enrichUfpd';\n/**\n * enrichEids: some component wants to add user IDs to bid requests.\n */\nexport const ACTIVITY_ENRICH_EIDS = 'enrichEids';\n/**\n * fetchBid: a bidder wants to bid.\n */\nexport const ACTIVITY_FETCH_BIDS = 'fetchBids';\n\n/**\n * reportAnalytics: some component wants to phone home with analytics data.\n */\nexport const ACTIVITY_REPORT_ANALYTICS = 'reportAnalytics';\n\n/**\n * some component wants access to (and send along) user IDs\n */\nexport const ACTIVITY_TRANSMIT_EIDS = 'transmitEids';\n\n/**\n * transmitUfpd: some component wants access to (and send along) user FPD\n */\nexport const ACTIVITY_TRANSMIT_UFPD = 'transmitUfpd';\n\n/**\n * transmitPreciseGeo: some component wants access to (and send along) geolocation info\n */\nexport const ACTIVITY_TRANSMIT_PRECISE_GEO = 'transmitPreciseGeo';\n\n/**\n * transmit TID: some component wants access ot (and send along) transaction IDs\n */\nexport const ACTIVITY_TRANSMIT_TID = 'transmitTid';\n\n/**\n * loadExternalScript: adLoader.js is allowed to load external script\n */\nexport const LOAD_EXTERNAL_SCRIPT = 'loadExternalScript';\n\n/**\n * accessRequestCredentials: setting withCredentials flag in ajax request config\n */\nexport const ACTIVITY_ACCESS_REQUEST_CREDENTIALS = 'accessRequestCredentials';\n//# sourceMappingURL=activities.js.map\n","import adapterManager from '../adapterManager.js';\nimport { activityParamsBuilder } from './params.js';\n\n/**\n * Utility function for building common activity parameters - broken out to its own\n * file to avoid circular imports.\n */\nexport const activityParams = activityParamsBuilder(alias => adapterManager.resolveAlias(alias));\n//# sourceMappingURL=activityParams.js.map\n","export const MODULE_TYPE_PREBID = 'prebid';\nexport const MODULE_TYPE_BIDDER = 'bidder';\nexport const MODULE_TYPE_UID = 'userId';\nexport const MODULE_TYPE_RTD = 'rtd';\nexport const MODULE_TYPE_ANALYTICS = 'analytics';\n//# sourceMappingURL=modules.js.map\n","import { MODULE_TYPE_BIDDER } from './modules.js';\nimport { hook } from '../hook.js';\n\n/**\n * Component ID - who is trying to perform the activity?\n * Relevant for all activities.\n */\nexport const ACTIVITY_PARAM_COMPONENT = 'component';\nexport const ACTIVITY_PARAM_COMPONENT_TYPE = ACTIVITY_PARAM_COMPONENT + 'Type';\nexport const ACTIVITY_PARAM_COMPONENT_NAME = ACTIVITY_PARAM_COMPONENT + 'Name';\n\n/**\n * Code of the bid adapter that `componentName` is an alias of.\n * May be the same as the component name.\n *\n * relevant for all activities, but only when componentType is 'bidder'.\n */\nexport const ACTIVITY_PARAM_ADAPTER_CODE = 'adapterCode';\n\n/**\n * Storage type - either 'html5' or 'cookie'.\n * Relevant for: accessDevice\n */\nexport const ACTIVITY_PARAM_STORAGE_TYPE = 'storageType';\n\n/**\n * Storage key - cookie name or localStorage key.\n * Relevant for: accessDevice\n */\nexport const ACTIVITY_PARAM_STORAGE_KEY = 'storageKey';\n\n/**\n * True if attempting to write to device storage; false otherwise (e.g. when reading from or checking availability of storage).\n * Relevant for: accessDevice\n */\nexport const ACTIVITY_PARAM_STORAGE_WRITE = 'write';\n\n/**\n * s2sConfig[].configName, used to identify a particular s2s instance\n * relevant for: fetchBids, but only when component is 'prebid.pbsBidAdapter'\n */\nexport const ACTIVITY_PARAM_S2S_NAME = 'configName';\n/**\n * user sync type - 'iframe' or 'pixel'\n * relevant for: syncUser\n */\nexport const ACTIVITY_PARAM_SYNC_TYPE = 'syncType';\n/**\n * user sync URL\n * relevant for: syncUser\n */\nexport const ACTIVITY_PARAM_SYNC_URL = 'syncUrl';\n/**\n * Configuration options for analytics adapter - the argument passed to `enableAnalytics`.\n * Relevant for: reportAnalytics\n * @private\n * @constant\n * @type {string}\n */\nexport const ACTIVITY_PARAM_ANL_CONFIG = '_config';\nexport function activityParamsBuilder(resolveAlias) {\n  return function activityParams(moduleType, moduleName, params) {\n    const defaults = {\n      [ACTIVITY_PARAM_COMPONENT_TYPE]: moduleType,\n      [ACTIVITY_PARAM_COMPONENT_NAME]: moduleName,\n      [ACTIVITY_PARAM_COMPONENT]: `${moduleType}.${moduleName}`\n    };\n    if (moduleType === MODULE_TYPE_BIDDER) {\n      defaults[ACTIVITY_PARAM_ADAPTER_CODE] = resolveAlias(moduleName);\n    }\n    return buildActivityParams(Object.assign(defaults, params));\n  };\n}\nexport const buildActivityParams = hook('sync', params => params);\n//# sourceMappingURL=params.js.map\n","import { deepAccess } from '../utils.js';\nimport { config } from '../config.js';\nimport { isActivityAllowed, registerActivityControl } from './rules.js';\nimport { ACTIVITY_TRANSMIT_EIDS, ACTIVITY_TRANSMIT_PRECISE_GEO, ACTIVITY_TRANSMIT_TID, ACTIVITY_TRANSMIT_UFPD } from './activities.js';\nimport { scrubIPv4, scrubIPv6 } from '../utils/ipUtils.js';\nexport const ORTB_UFPD_PATHS = ['data', 'ext.data', 'yob', 'gender', 'keywords', 'kwarray', 'id', 'buyeruid', 'customdata'].map(f => `user.${f}`).concat('device.ext.cdep');\nexport const ORTB_EIDS_PATHS = ['user.eids', 'user.ext.eids'];\nexport const ORTB_GEO_PATHS = ['user.geo.lat', 'user.geo.lon', 'device.geo.lat', 'device.geo.lon'];\nexport const ORTB_IPV4_PATHS = ['device.ip'];\nexport const ORTB_IPV6_PATHS = ['device.ipv6'];\n\n/**\n * @typedef TransformationRuleDef\n * @property {name}\n * @property {Array[string]} paths dot-separated list of paths that this rule applies to.\n * @property {function(*): boolean} applies a predicate that should return true if this rule applies\n * (and the transformation defined herein should be applied). The arguments are those passed to the transformation function.\n * @property {name} a name for the rule; used to debounce calls to `applies` (and avoid excessive logging):\n * if a rule with the same name was already found to apply (or not), this one will (or won't) as well.\n */\n\n/**\n * @typedef RedactRuleDef A rule that removes, or replaces, values from an object (modifications are done in-place).\n * @augments TransformationRuleDef\n * @property {function(*): *} get? substitution functions for values that should be redacted;\n *  takes in the original (unredacted) value as an input, and returns a substitute to use in the redacted\n *  version. If it returns undefined, or this option is omitted, protected paths will be removed\n *  from the redacted object.\n */\n\n/**\n * @param {RedactRuleDef} ruleDef\n * @return {TransformationRule}\n */\nexport function redactRule(ruleDef) {\n  return Object.assign({\n    get() {},\n    run(root, path, object, property, applies) {\n      const val = object && object[property];\n      if (isData(val) && applies()) {\n        const repl = this.get(val);\n        if (repl === undefined) {\n          delete object[property];\n        } else {\n          object[property] = repl;\n        }\n      }\n    }\n  }, ruleDef);\n}\n\n/**\n * @typedef TransformationRule\n * @augments TransformationRuleDef\n * @property {function} run rule logic - see `redactRule` for an example.\n */\n\n/**\n * @typedef {Function} TransformationFunction\n * @param object object to transform\n * @param ...args arguments to pass down to rule's `apply` methods.\n */\n\n/**\n * Return a transformation function that will apply the given rules to an object.\n *\n * @param {Array[TransformationRule]} rules\n * @return {TransformationFunction}\n */\nexport function objectTransformer(rules) {\n  rules.forEach(rule => {\n    rule.paths = rule.paths.map(path => {\n      const parts = path.split('.');\n      const tail = parts.pop();\n      return [parts.length > 0 ? parts.join('.') : null, tail];\n    });\n  });\n  return function applyTransform(session, obj) {\n    const result = [];\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    const applies = sessionedApplies(session, ...args);\n    rules.forEach(rule => {\n      if (session[rule.name] === false) return;\n      for (const [head, tail] of rule.paths) {\n        const parent = head == null ? obj : deepAccess(obj, head);\n        result.push(rule.run(obj, head, parent, tail, applies.bind(null, rule)));\n        if (session[rule.name] === false) return;\n      }\n    });\n    return result.filter(el => el != null);\n  };\n}\nexport function sessionedApplies(session) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  return function applies(rule) {\n    if (!session.hasOwnProperty(rule.name)) {\n      session[rule.name] = !!rule.applies(...args);\n    }\n    return session[rule.name];\n  };\n}\nexport function isData(val) {\n  return val != null && (typeof val !== 'object' || Object.keys(val).length > 0);\n}\nexport function appliesWhenActivityDenied(activity) {\n  let isAllowed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isActivityAllowed;\n  return function applies(params) {\n    return !isAllowed(activity, params);\n  };\n}\nfunction bidRequestTransmitRules() {\n  let isAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : isActivityAllowed;\n  return [{\n    name: ACTIVITY_TRANSMIT_EIDS,\n    paths: ['userId', 'userIdAsEids'],\n    applies: appliesWhenActivityDenied(ACTIVITY_TRANSMIT_EIDS, isAllowed)\n  }, {\n    name: ACTIVITY_TRANSMIT_TID,\n    paths: ['ortb2Imp.ext.tid'],\n    applies: appliesWhenActivityDenied(ACTIVITY_TRANSMIT_TID, isAllowed)\n  }].map(redactRule);\n}\nexport function ortb2TransmitRules() {\n  let isAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : isActivityAllowed;\n  return [{\n    name: ACTIVITY_TRANSMIT_UFPD,\n    paths: ORTB_UFPD_PATHS,\n    applies: appliesWhenActivityDenied(ACTIVITY_TRANSMIT_UFPD, isAllowed)\n  }, {\n    name: ACTIVITY_TRANSMIT_EIDS,\n    paths: ORTB_EIDS_PATHS,\n    applies: appliesWhenActivityDenied(ACTIVITY_TRANSMIT_EIDS, isAllowed)\n  }, {\n    name: ACTIVITY_TRANSMIT_PRECISE_GEO,\n    paths: ORTB_GEO_PATHS,\n    applies: appliesWhenActivityDenied(ACTIVITY_TRANSMIT_PRECISE_GEO, isAllowed),\n    get(val) {\n      return Math.round((val + Number.EPSILON) * 100) / 100;\n    }\n  }, {\n    name: ACTIVITY_TRANSMIT_PRECISE_GEO,\n    paths: ORTB_IPV4_PATHS,\n    applies: appliesWhenActivityDenied(ACTIVITY_TRANSMIT_PRECISE_GEO, isAllowed),\n    get(val) {\n      return scrubIPv4(val);\n    }\n  }, {\n    name: ACTIVITY_TRANSMIT_PRECISE_GEO,\n    paths: ORTB_IPV6_PATHS,\n    applies: appliesWhenActivityDenied(ACTIVITY_TRANSMIT_PRECISE_GEO, isAllowed),\n    get(val) {\n      return scrubIPv6(val);\n    }\n  }, {\n    name: ACTIVITY_TRANSMIT_TID,\n    paths: ['source.tid'],\n    applies: appliesWhenActivityDenied(ACTIVITY_TRANSMIT_TID, isAllowed)\n  }].map(redactRule);\n}\nexport function redactorFactory() {\n  let isAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : isActivityAllowed;\n  const redactOrtb2 = objectTransformer(ortb2TransmitRules(isAllowed));\n  const redactBidRequest = objectTransformer(bidRequestTransmitRules(isAllowed));\n  return function redactor(params) {\n    const session = {};\n    return {\n      ortb2(obj) {\n        redactOrtb2(session, obj, params);\n        return obj;\n      },\n      bidRequest(obj) {\n        redactBidRequest(session, obj, params);\n        return obj;\n      }\n    };\n  };\n}\n\n/**\n * Returns an object that can redact other privacy-sensitive objects according\n * to activity rules.\n *\n * @param {{}} params activity parameters to use for activity checks\n * @return {{ortb2: function({}): {}, bidRequest: function({}): {}}} methods\n *  that can redact disallowed data from ORTB2 and/or bid request objects.\n */\nexport const redactor = redactorFactory();\n// by default, TIDs are off since version 8\nregisterActivityControl(ACTIVITY_TRANSMIT_TID, 'enableTIDs config', () => {\n  if (!config.getConfig('enableTIDs')) {\n    return {\n      allow: false,\n      reason: 'TIDs are disabled'\n    };\n  }\n});\n//# sourceMappingURL=redactor.js.map\n","import { prefixLog } from '../utils.js';\nimport { ACTIVITY_PARAM_COMPONENT } from './params.js';\n\n/**\n * @param logger\n * @return {((function(string, string, function(Object): {allow: boolean, reason?: string}, number=): function(): void)|(function(string, {}): boolean)|*)[]}\n */\nexport function ruleRegistry() {\n  let logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : prefixLog('Activity control:');\n  const registry = {};\n  function getRules(activity) {\n    registry[activity] = registry[activity] || [];\n    return registry[activity];\n  }\n  function runRule(activity, name, rule, params) {\n    let res;\n    try {\n      res = rule(params);\n    } catch (e) {\n      logger.logError(`Exception in rule ${name} for '${activity}'`, e);\n      res = {\n        allow: false,\n        reason: e\n      };\n    }\n    return res && Object.assign({\n      activity,\n      name,\n      component: params[ACTIVITY_PARAM_COMPONENT]\n    }, res);\n  }\n  const dupes = {};\n  const DEDUPE_INTERVAL = 1000;\n\n  // eslint-disable-next-line no-restricted-syntax\n  function logResult(_ref) {\n    let {\n      activity,\n      name,\n      allow,\n      reason,\n      component\n    } = _ref;\n    const msg = `${name} ${allow ? 'allowed' : 'denied'} '${activity}' for '${component}'${reason ? ':' : ''}`;\n    const deduping = dupes.hasOwnProperty(msg);\n    if (deduping) {\n      clearTimeout(dupes[msg]);\n    }\n    dupes[msg] = setTimeout(() => delete dupes[msg], DEDUPE_INTERVAL);\n    if (!deduping) {\n      const parts = [msg];\n      reason && parts.push(reason);\n      (allow ? logger.logInfo : logger.logWarn).apply(logger, parts);\n    }\n  }\n  return [\n  /**\n   * Register an activity control rule.\n   *\n   * @param {string} activity - Activity name, as defined in `activities.js`.\n   * @param {string} ruleName - A name for this rule, used for logging.\n   * @param {function(Object): {allow: boolean, reason?: string}} rule - Rule definition function. Takes in activity\n   *        parameters as a single map; MAY return an object {allow, reason}, where allow is true/false,\n   *        and reason is an optional message used for logging.\n   *\n   *        {allow: true} will allow this activity AS LONG AS no other rules with the same or higher priority return {allow: false};\n   *        {allow: false} will deny this activity AS LONG AS no other rules with higher priority return {allow: true};\n   *        Returning null/undefined has no effect - the decision is left to other rules.\n   *        If no rule returns an allow value, the default is to allow the activity.\n   *\n   * @param {number} [priority=10] - Rule priority; lower number means higher priority.\n   * @returns {function(): void} - A function that unregisters the rule when called.\n   */\n  function registerActivityControl(activity, ruleName, rule) {\n    let priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n    const rules = getRules(activity);\n    const pos = rules.findIndex(_ref2 => {\n      let [itemPriority] = _ref2;\n      return priority < itemPriority;\n    });\n    const entry = [priority, ruleName, rule];\n    rules.splice(pos < 0 ? rules.length : pos, 0, entry);\n    return function () {\n      const idx = rules.indexOf(entry);\n      if (idx >= 0) rules.splice(idx, 1);\n    };\n  },\n  /**\n   * Test whether an activity is allowed.\n   *\n   * @param {string} activity activity name\n   * @param {{}} params activity parameters; should be generated through the `activityParams` utility.\n   * @return {boolean} true for allow, false for deny.\n   */\n  function isActivityAllowed(activity, params) {\n    let lastPriority, foundAllow;\n    for (const [priority, name, rule] of getRules(activity)) {\n      if (lastPriority !== priority && foundAllow) break;\n      lastPriority = priority;\n      const ruleResult = runRule(activity, name, rule, params);\n      if (ruleResult) {\n        if (!ruleResult.allow) {\n          logResult(ruleResult);\n          return false;\n        } else {\n          foundAllow = ruleResult;\n        }\n      }\n    }\n    foundAllow && logResult(foundAllow);\n    return true;\n  }];\n}\nexport const [registerActivityControl, isActivityAllowed] = ruleRegistry();\n//# sourceMappingURL=rules.js.map\n","import { createIframe, createInvisibleIframe, inIframe, insertElement, logError, logWarn, replaceMacros, triggerPixel } from './utils.js';\nimport * as events from './events.js';\nimport { AD_RENDER_FAILED_REASON, BID_STATUS, EVENTS, MESSAGES, PB_LOCATOR } from './constants.js';\nimport { config } from './config.js';\nimport { executeRenderer, isRendererRequired } from './Renderer.js';\nimport { VIDEO } from './mediaTypes.js';\nimport { auctionManager } from './auctionManager.js';\nimport { getCreativeRenderer } from './creativeRenderers.js';\nimport { hook } from './hook.js';\nimport { fireNativeTrackers } from './native.js';\nimport { PbPromise } from './utils/promise.js';\nimport adapterManager from './adapterManager.js';\nimport { useMetrics } from './utils/perfMetrics.js';\nimport { filters } from './targeting.js';\nimport { EVENT_TYPE_WIN, parseEventTrackers, TRACKER_METHOD_IMG } from './eventTrackers.js';\nconst {\n  AD_RENDER_FAILED,\n  AD_RENDER_SUCCEEDED,\n  STALE_RENDER,\n  BID_WON,\n  EXPIRED_RENDER\n} = EVENTS;\nconst {\n  EXCEPTION\n} = AD_RENDER_FAILED_REASON;\nexport const getBidToRender = hook('sync', function (adId) {\n  let forRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PbPromise.resolve();\n  return override.then(bid => bid ?? auctionManager.findBidByAdId(adId)).catch(() => {});\n});\nexport const markWinningBid = hook('sync', function (bid) {\n  (parseEventTrackers(bid.eventtrackers)[EVENT_TYPE_WIN]?.[TRACKER_METHOD_IMG] || []).forEach(url => triggerPixel(url));\n  events.emit(BID_WON, bid);\n  auctionManager.addWinningBid(bid);\n});\n/**\n * Emit the AD_RENDER_FAILED event.\n */\nexport function emitAdRenderFail(_ref) {\n  let {\n    reason,\n    message,\n    bid,\n    id\n  } = _ref;\n  const data = {\n    reason,\n    message\n  };\n  if (bid) {\n    data.bid = bid;\n    data.adId = bid.adId;\n  }\n  if (id) data.adId = id;\n  logError(`Error rendering ad (id: ${id}): ${message}`);\n  events.emit(AD_RENDER_FAILED, data);\n}\n/**\n * Emit the AD_RENDER_SUCCEEDED event.\n * (Note: Invocation of this function indicates that the render function did not generate an error, it does not guarantee that tracking for this event has occurred yet.)\n */\nexport function emitAdRenderSucceeded(_ref2) {\n  let {\n    doc,\n    bid,\n    id\n  } = _ref2;\n  const data = {\n    doc,\n    bid,\n    adId: id\n  };\n  adapterManager.callAdRenderSucceededBidder(bid.adapterCode || bid.bidder, bid);\n  events.emit(AD_RENDER_SUCCEEDED, data);\n}\nexport function handleCreativeEvent(data, bidResponse) {\n  switch (data.event) {\n    case EVENTS.AD_RENDER_FAILED:\n      emitAdRenderFail({\n        bid: bidResponse,\n        id: bidResponse.adId,\n        reason: data.info.reason,\n        message: data.info.message\n      });\n      break;\n    case EVENTS.AD_RENDER_SUCCEEDED:\n      emitAdRenderSucceeded({\n        doc: null,\n        bid: bidResponse,\n        id: bidResponse.adId\n      });\n      break;\n    default:\n      logError(`Received event request for unsupported event: '${data.event}' (adId: '${bidResponse.adId}')`);\n  }\n}\nexport function handleNativeMessage(data, bidResponse, _ref3) {\n  let {\n    resizeFn,\n    fireTrackers = fireNativeTrackers\n  } = _ref3;\n  switch (data.action) {\n    case 'resizeNativeHeight':\n      resizeFn(data.width, data.height);\n      break;\n    default:\n      fireTrackers(data, bidResponse);\n  }\n}\nconst HANDLERS = {\n  [MESSAGES.EVENT]: handleCreativeEvent\n};\nif (true) {\n  HANDLERS[MESSAGES.NATIVE] = handleNativeMessage;\n}\nfunction creativeMessageHandler(deps) {\n  return function (type, data, bidResponse) {\n    if (HANDLERS.hasOwnProperty(type)) {\n      HANDLERS[type](data, bidResponse, deps);\n    }\n  };\n}\nexport const getRenderingData = hook('sync', function (bidResponse, options) {\n  const {\n    ad,\n    adUrl,\n    cpm,\n    originalCpm,\n    width,\n    height,\n    instl\n  } = bidResponse;\n  const repl = {\n    AUCTION_PRICE: originalCpm || cpm,\n    CLICKTHROUGH: options?.clickUrl || ''\n  };\n  return {\n    ad: replaceMacros(ad, repl),\n    adUrl: replaceMacros(adUrl, repl),\n    width,\n    height,\n    instl\n  };\n});\nexport const doRender = hook('sync', function (_ref4) {\n  let {\n    renderFn,\n    resizeFn,\n    bidResponse,\n    options,\n    doc,\n    isMainDocument = doc === document && !inIframe()\n  } = _ref4;\n  const videoBid = true && bidResponse.mediaType === VIDEO;\n  if (isMainDocument || videoBid) {\n    emitAdRenderFail({\n      reason: AD_RENDER_FAILED_REASON.PREVENT_WRITING_ON_MAIN_DOCUMENT,\n      message: videoBid ? 'Cannot render video ad without a renderer' : `renderAd was prevented from writing to the main document.`,\n      bid: bidResponse,\n      id: bidResponse.adId\n    });\n    return;\n  }\n  const data = getRenderingData(bidResponse, options);\n  renderFn(Object.assign({\n    adId: bidResponse.adId\n  }, data));\n  const {\n    width,\n    height\n  } = data;\n  if ((width ?? height) != null) {\n    resizeFn(width, height);\n  }\n});\ndoRender.before(function (next, args) {\n  // run renderers from a high priority hook to allow the video module to insert itself between this and \"normal\" rendering.\n  const {\n    bidResponse,\n    doc\n  } = args;\n  if (isRendererRequired(bidResponse.renderer)) {\n    executeRenderer(bidResponse.renderer, bidResponse, doc);\n    emitAdRenderSucceeded({\n      doc,\n      bid: bidResponse,\n      id: bidResponse.adId\n    });\n    next.bail();\n  } else {\n    next(args);\n  }\n}, 100);\nexport function handleRender(_ref5) {\n  let {\n    renderFn,\n    resizeFn,\n    adId,\n    options,\n    bidResponse,\n    doc\n  } = _ref5;\n  deferRendering(bidResponse, () => {\n    if (bidResponse == null) {\n      emitAdRenderFail({\n        reason: AD_RENDER_FAILED_REASON.CANNOT_FIND_AD,\n        message: `Cannot find ad '${adId}'`,\n        id: adId\n      });\n      return;\n    }\n    if (bidResponse.status === BID_STATUS.RENDERED) {\n      logWarn(`Ad id ${adId} has been rendered before`);\n      events.emit(STALE_RENDER, bidResponse);\n      if (config.getConfig('auctionOptions')?.suppressStaleRender) {\n        return;\n      }\n    }\n    if (!filters.isBidNotExpired(bidResponse)) {\n      logWarn(`Ad id ${adId} has been expired`);\n      events.emit(EXPIRED_RENDER, bidResponse);\n      if (config.getConfig('auctionOptions')?.suppressExpiredRender) {\n        return;\n      }\n    }\n    try {\n      doRender({\n        renderFn,\n        resizeFn,\n        bidResponse,\n        options,\n        doc\n      });\n    } catch (e) {\n      emitAdRenderFail({\n        reason: AD_RENDER_FAILED_REASON.EXCEPTION,\n        message: e.message,\n        id: adId,\n        bid: bidResponse\n      });\n    }\n  });\n}\nexport function markBidAsRendered(bidResponse) {\n  const metrics = useMetrics(bidResponse.metrics);\n  metrics.checkpoint('bidRender');\n  metrics.timeBetween('bidWon', 'bidRender', 'render.deferred');\n  metrics.timeBetween('auctionEnd', 'bidRender', 'render.pending');\n  metrics.timeBetween('requestBids', 'bidRender', 'render.e2e');\n  bidResponse.status = BID_STATUS.RENDERED;\n}\nconst DEFERRED_RENDER = new WeakMap();\nconst WINNERS = new WeakSet();\nexport function deferRendering(bidResponse, renderFn) {\n  if (bidResponse == null) {\n    // if the bid is missing, let renderFn deal with it now\n    renderFn();\n    return;\n  }\n  DEFERRED_RENDER.set(bidResponse, renderFn);\n  if (!bidResponse.deferRendering) {\n    renderIfDeferred(bidResponse);\n  }\n  markWinner(bidResponse);\n}\nexport function markWinner(bidResponse) {\n  if (!WINNERS.has(bidResponse)) {\n    WINNERS.add(bidResponse);\n    markWinningBid(bidResponse);\n  }\n}\nexport function renderIfDeferred(bidResponse) {\n  const renderFn = DEFERRED_RENDER.get(bidResponse);\n  if (renderFn) {\n    renderFn();\n    markBidAsRendered(bidResponse);\n    DEFERRED_RENDER.delete(bidResponse);\n  }\n}\nexport function renderAdDirect(doc, adId, options) {\n  let bid;\n  function fail(reason, message) {\n    emitAdRenderFail(Object.assign({\n      id: adId,\n      bid\n    }, {\n      reason,\n      message\n    }));\n  }\n  function resizeFn(width, height) {\n    const frame = doc.defaultView?.frameElement;\n    if (frame) {\n      if (width) {\n        frame.width = width;\n        frame.style.width && (frame.style.width = `${width}px`);\n      }\n      if (height) {\n        frame.height = height;\n        frame.style.height && (frame.style.height = `${height}px`);\n      }\n    }\n  }\n  const messageHandler = creativeMessageHandler({\n    resizeFn\n  });\n  function renderFn(adData) {\n    if (adData.ad) {\n      doc.write(adData.ad);\n      doc.close();\n      emitAdRenderSucceeded({\n        doc,\n        bid,\n        id: bid.adId\n      });\n    } else {\n      getCreativeRenderer(bid).then(render => render(adData, {\n        sendMessage: (type, data) => messageHandler(type, data, bid),\n        mkFrame: createIframe\n      }, doc.defaultView)).then(() => emitAdRenderSucceeded({\n        doc,\n        bid,\n        id: bid.adId\n      }), e => {\n        fail(e?.reason || AD_RENDER_FAILED_REASON.EXCEPTION, e?.message);\n        e?.stack && logError(e);\n      });\n    }\n    // TODO: this is almost certainly the wrong way to do this\n    const creativeComment = document.createComment(`Creative ${bid.creativeId} served by ${bid.bidder} Prebid.js Header Bidding`);\n    insertElement(creativeComment, doc, 'html');\n  }\n  try {\n    if (!adId || !doc) {\n      fail(AD_RENDER_FAILED_REASON.MISSING_DOC_OR_ADID, `missing ${adId ? 'doc' : 'adId'}`);\n    } else {\n      getBidToRender(adId).then(bidResponse => {\n        bid = bidResponse;\n        handleRender({\n          renderFn,\n          resizeFn,\n          adId,\n          options: {\n            clickUrl: options?.clickThrough\n          },\n          bidResponse,\n          doc\n        });\n      });\n    }\n  } catch (e) {\n    fail(EXCEPTION, e.message);\n  }\n}\n\n/**\n * Insert an invisible, named iframe that can be used by creatives to locate the window Prebid is running in\n * (by looking for one that has `.frames[PB_LOCATOR]` defined).\n * This is necessary because in some situations creatives may be rendered inside nested iframes - Prebid is not necessarily\n * in the immediate parent window.\n */\nexport function insertLocatorFrame() {\n  if (!window.frames[PB_LOCATOR]) {\n    if (!document.body) {\n      window.requestAnimationFrame(insertLocatorFrame);\n    } else {\n      const frame = createInvisibleIframe();\n      frame.name = PB_LOCATOR;\n      document.body.appendChild(frame);\n    }\n  }\n}\n//# sourceMappingURL=adRendering.js.map\n","// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\n/**\n * Ad unit objects generated by Prebid (as opposed to the definitions provided by the publisher)\n * can have a placeholder \"null\" bidder to represent s2s-only stored requests.\n */\n\nconst REQUESTS = 'requests';\nconst WINS = 'wins';\nconst AUCTIONS = 'auctions';\nlet adUnits = {};\nexport function reset() {\n  adUnits = {};\n}\nfunction ensureAdUnit(adunit, bidderCode) {\n  const adUnit = adUnits[adunit] = adUnits[adunit] || {\n    bidders: {}\n  };\n  if (bidderCode) {\n    adUnit.bidders[bidderCode] = adUnit.bidders[bidderCode] || {};\n    return adUnit.bidders[bidderCode];\n  }\n  return adUnit;\n}\nfunction incrementer(counter, byBidder) {\n  return function (adUnit, bidder) {\n    const counters = ensureAdUnit(adUnit, byBidder && bidder);\n    counters[counter] = (counters[counter] ?? 0) + 1;\n    return counters[counter];\n  };\n}\nfunction getter(counter, byBidder) {\n  return function (adUnit, bidder) {\n    return ensureAdUnit(adUnit, byBidder && bidder)[counter] ?? 0;\n  };\n}\n\n/**\n * Increments and returns current Adunit counter\n */\nexport const incrementRequestsCounter = incrementer(REQUESTS, false);\n\n/**\n * Increments and returns current Adunit requests counter for a bidder\n */\nexport const incrementBidderRequestsCounter = incrementer(REQUESTS, true);\n\n/**\n * Increments and returns current Adunit wins counter for a bidder\n */\nexport const incrementBidderWinsCounter = incrementer(WINS, true);\n\n/**\n * Increments and returns current Adunit auctions counter\n */\nexport const incrementAuctionsCounter = incrementer(AUCTIONS, false);\n\n/**\n * Returns current Adunit counter\n */\nexport const getRequestsCounter = getter(REQUESTS, false);\n\n/**\n * Returns current Adunit requests counter for a specific bidder code\n */\nexport const getBidderRequestsCounter = getter(REQUESTS, true);\n\n/**\n * Returns current Adunit requests counter for a specific bidder code\n */\nexport const getBidderWinsCounter = getter(WINS, true);\n\n/**\n * Returns current Adunit auctions counter\n */\nexport const getAuctionsCounter = getter(AUCTIONS, false);\n//# sourceMappingURL=adUnits.js.map\n","export default function Adapter(code) {\n  var bidderCode = code;\n  function setBidderCode(code) {\n    bidderCode = code;\n  }\n  function getBidderCode() {\n    return bidderCode;\n  }\n  function callBids() {}\n  return {\n    callBids: callBids,\n    setBidderCode: setBidderCode,\n    getBidderCode: getBidderCode\n  };\n}\n//# sourceMappingURL=adapter.js.map\n","/** @module adaptermanger */\n\nimport { deepClone, flatten, generateUUID, getBidderCodes, getDefinedParams, getUniqueIdentifierStr, getUserConfiguredParams, groupBy, internal, isArray, isPlainObject, isValidMediaTypes, logError, logInfo, logMessage, logWarn, mergeDeep, shuffle, timestamp, uniques } from './utils.js';\nimport { decorateAdUnitsWithNativeParams, nativeAdapters } from './native.js';\nimport { newBidder } from './adapters/bidderFactory.js';\nimport { ajaxBuilder } from './ajax.js';\nimport { config, RANDOM } from './config.js';\nimport { hook } from './hook.js';\nimport { getAuctionsCounter, getBidderRequestsCounter, getBidderWinsCounter, getRequestsCounter, incrementAuctionsCounter, incrementBidderRequestsCounter, incrementBidderWinsCounter, incrementRequestsCounter } from './adUnits.js';\nimport { getRefererInfo } from './refererDetection.js';\nimport { GDPR_GVLIDS, gdprDataHandler, gppDataHandler, uspDataHandler } from './consentHandler.js';\nimport * as events from './events.js';\nimport { EVENTS, S2S } from './constants.js';\nimport { useMetrics } from './utils/perfMetrics.js';\nimport { auctionManager } from './auctionManager.js';\nimport { MODULE_TYPE_ANALYTICS, MODULE_TYPE_BIDDER, MODULE_TYPE_PREBID } from './activities/modules.js';\nimport { isActivityAllowed } from './activities/rules.js';\nimport { ACTIVITY_FETCH_BIDS, ACTIVITY_REPORT_ANALYTICS } from './activities/activities.js';\nimport { ACTIVITY_PARAM_ANL_CONFIG, ACTIVITY_PARAM_S2S_NAME, activityParamsBuilder } from './activities/params.js';\nimport { redactor } from './activities/redactor.js';\nimport { EVENT_TYPE_IMPRESSION, parseEventTrackers, TRACKER_METHOD_IMG } from './eventTrackers.js';\nexport { gdprDataHandler, gppDataHandler, uspDataHandler, coppaDataHandler } from './consentHandler.js';\nexport const PBS_ADAPTER_NAME = 'pbsBidAdapter';\nexport const PARTITIONS = {\n  CLIENT: 'client',\n  SERVER: 'server'\n};\nexport const dep = {\n  isAllowed: isActivityAllowed,\n  redact: redactor\n};\nconst _bidderRegistry = {};\nconst _aliasRegistry = {};\nconst _analyticsRegistry = {};\nlet _s2sConfigs = [];\nconfig.getConfig('s2sConfig', config => {\n  if (config && config.s2sConfig) {\n    _s2sConfigs = isArray(config.s2sConfig) ? config.s2sConfig : [config.s2sConfig];\n  }\n});\nconst activityParams = activityParamsBuilder(alias => adapterManager.resolveAlias(alias));\nfunction getConfigName(s2sConfig) {\n  // According to our docs, \"module\" bid (stored impressions)\n  // have params.configName referring to s2sConfig.name,\n  // but for a long while this was checking against s2sConfig.configName.\n  // Keep allowing s2sConfig.configName to avoid the breaking change\n  return s2sConfig.configName ?? s2sConfig.name;\n}\nexport function s2sActivityParams(s2sConfig) {\n  return activityParams(MODULE_TYPE_PREBID, PBS_ADAPTER_NAME, {\n    [ACTIVITY_PARAM_S2S_NAME]: getConfigName(s2sConfig)\n  });\n}\nconst ADUNIT_BID_PROPERTIES = ['nativeParams', 'nativeOrtbRequest', 'renderer'];\nfunction getBids(_ref) {\n  let {\n    bidderCode,\n    auctionId,\n    bidderRequestId,\n    adUnits,\n    src,\n    metrics\n  } = _ref;\n  return adUnits.reduce((result, adUnit) => {\n    const bids = adUnit.bids.filter(bid => bid.bidder === bidderCode);\n    if (bidderCode == null && bids.length === 0 && adUnit.s2sBid != null) {\n      bids.push({\n        bidder: null\n      });\n    }\n    result.push(bids.reduce((bids, bid) => {\n      bid = Object.assign({}, bid, {\n        ortb2Imp: mergeDeep({}, adUnit.ortb2Imp, bid.ortb2Imp)\n      }, getDefinedParams(adUnit, ADUNIT_BID_PROPERTIES));\n      const mediaTypes = bid.mediaTypes == null ? adUnit.mediaTypes : bid.mediaTypes;\n      if (isValidMediaTypes(mediaTypes)) {\n        bid = Object.assign({}, bid, {\n          mediaTypes\n        });\n      } else {\n        logError(`mediaTypes is not correctly configured for adunit ${adUnit.code}`);\n      }\n      if (src === 'client') {\n        incrementBidderRequestsCounter(adUnit.code, bidderCode);\n      }\n      bids.push(Object.assign({}, bid, {\n        adUnitCode: adUnit.code,\n        transactionId: adUnit.transactionId,\n        adUnitId: adUnit.adUnitId,\n        sizes: mediaTypes?.banner?.sizes || mediaTypes?.video?.playerSize || [],\n        bidId: bid.bid_id || getUniqueIdentifierStr(),\n        bidderRequestId,\n        auctionId,\n        src,\n        metrics,\n        auctionsCount: getAuctionsCounter(adUnit.code),\n        bidRequestsCount: getRequestsCounter(adUnit.code),\n        bidderRequestsCount: getBidderRequestsCounter(adUnit.code, bid.bidder),\n        bidderWinsCount: getBidderWinsCounter(adUnit.code, bid.bidder),\n        deferBilling: !!adUnit.deferBilling\n      }));\n      return bids;\n    }, []));\n    return result;\n  }, []).reduce(flatten, []).filter(val => val !== '');\n}\n\n/**\n * Filter an adUnit's  bids for building client and/or server requests\n *\n * @param bids an array of bids as defined in an adUnit\n * @param s2sConfig null if the adUnit is being routed to a client adapter; otherwise the s2s adapter's config\n * @returns the subset of `bids` that are pertinent for the given `s2sConfig`\n */\nexport const filterBidsForAdUnit = hook('sync', function (bids, s2sConfig) {\n  let {\n    getS2SBidders = getS2SBidderSet\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (s2sConfig == null) {\n    return bids;\n  } else {\n    const serverBidders = getS2SBidders(s2sConfig);\n    return bids.filter(bid => {\n      if (!serverBidders.has(bid.bidder)) return false;\n      if (bid.s2sConfigName == null) return true;\n      const configName = getConfigName(s2sConfig);\n      const allowedS2SConfigs = Array.isArray(bid.s2sConfigName) ? bid.s2sConfigName : [bid.s2sConfigName];\n      return allowedS2SConfigs.includes(configName);\n    });\n  }\n}, 'filterBidsForAdUnit');\nfunction getAdUnitCopyForPrebidServer(adUnits, s2sConfig) {\n  let adUnitsCopy = deepClone(adUnits);\n  let hasModuleBids = false;\n  adUnitsCopy.forEach(adUnit => {\n    // filter out client side bids\n    const s2sBids = adUnit.bids.filter(b => b.module === PBS_ADAPTER_NAME && b.params?.configName === getConfigName(s2sConfig));\n    if (s2sBids.length === 1) {\n      adUnit.s2sBid = s2sBids[0];\n      hasModuleBids = true;\n      adUnit.ortb2Imp = mergeDeep({}, adUnit.s2sBid.ortb2Imp, adUnit.ortb2Imp);\n    } else if (s2sBids.length > 1) {\n      logWarn('Multiple \"module\" bids for the same s2s configuration; all will be ignored', s2sBids);\n    }\n    adUnit.bids = filterBidsForAdUnit(adUnit.bids, s2sConfig).map(bid => {\n      bid.bid_id = getUniqueIdentifierStr();\n      return bid;\n    });\n  });\n  adUnitsCopy = adUnitsCopy.filter(adUnit => {\n    if (s2sConfig.filterBidderlessCalls) {\n      if (adUnit.bids.length === 1 && adUnit.bids[0].bidder == null) return false;\n    }\n    return adUnit.bids.length !== 0 || adUnit.s2sBid != null;\n  });\n\n  // don't send empty requests\n  return {\n    adUnits: adUnitsCopy,\n    hasModuleBids\n  };\n}\nfunction getAdUnitCopyForClientAdapters(adUnits) {\n  let adUnitsClientCopy = deepClone(adUnits);\n  adUnitsClientCopy.forEach(adUnit => {\n    adUnit.bids = filterBidsForAdUnit(adUnit.bids, null);\n  });\n\n  // don't send empty requests\n  adUnitsClientCopy = adUnitsClientCopy.filter(adUnit => {\n    return adUnit.bids.length !== 0;\n  });\n  return adUnitsClientCopy;\n}\n\n/**\n * Filter and/or modify media types for ad units based on the given labels.\n *\n * This should return adUnits that are active for the given labels, modified to have their `mediaTypes`\n * conform to size mapping configuration. If different bids for the same adUnit should use different `mediaTypes`,\n * they should be exposed under `adUnit.bids[].mediaTypes`.\n */\nexport const setupAdUnitMediaTypes = hook('sync', (adUnits, labels) => {\n  return adUnits;\n}, 'setupAdUnitMediaTypes');\n\n/**\n * @param {{}|Array<{}>} s2sConfigs\n * @returns {Set<String>} a set of all the bidder codes that should be routed through the S2S adapter(s)\n *                        as defined in `s2sConfigs`\n */\nexport function getS2SBidderSet(s2sConfigs) {\n  if (!isArray(s2sConfigs)) s2sConfigs = [s2sConfigs];\n  // `null` represents the \"no bid bidder\" - when an ad unit is meant only for S2S adapters, like stored impressions\n  const serverBidders = new Set([null]);\n  s2sConfigs.filter(s2s => s2s && s2s.enabled).flatMap(s2s => s2s.bidders).forEach(bidder => serverBidders.add(bidder));\n  return serverBidders;\n}\n\n/**\n * @param {Array} adUnits - The ad units to be processed.\n * @param {Object} s2sConfigs - The server-to-server configurations.\n * @returns {Object} - An object containing arrays of bidder codes for client and server.\n * @returns {Object} return.client - Array of bidder codes that should be routed to client adapters.\n * @returns {Object} return.server - Array of bidder codes that should be routed to server adapters.\n */\nexport function _partitionBidders(adUnits, s2sConfigs) {\n  let {\n    getS2SBidders = getS2SBidderSet\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const serverBidders = getS2SBidders(s2sConfigs);\n  return getBidderCodes(adUnits).reduce((memo, bidder) => {\n    const partition = serverBidders.has(bidder) ? PARTITIONS.SERVER : PARTITIONS.CLIENT;\n    memo[partition].push(bidder);\n    return memo;\n  }, {\n    [PARTITIONS.CLIENT]: [],\n    [PARTITIONS.SERVER]: []\n  });\n}\nexport const partitionBidders = hook('sync', _partitionBidders, 'partitionBidders');\nconst adapterManager = {\n  bidderRegistry: _bidderRegistry,\n  analyticsRegistry: _analyticsRegistry,\n  /**\n   * Map from alias codes to the bidder code they alias.\n   */\n  aliasRegistry: _aliasRegistry,\n  makeBidRequests: hook('sync', function (adUnits, auctionStart, auctionId, cbTimeout, labels) {\n    let ortb2Fragments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    let auctionMetrics = arguments.length > 6 ? arguments[6] : undefined;\n    auctionMetrics = useMetrics(auctionMetrics);\n    /**\n     * emit and pass adunits for external modification\n     * @see {@link https://github.com/prebid/Prebid.js/issues/4149|Issue}\n     */\n    events.emit(EVENTS.BEFORE_REQUEST_BIDS, adUnits);\n    if (true) {\n      decorateAdUnitsWithNativeParams(adUnits);\n    }\n    adUnits.map(adUnit => adUnit.code).filter(uniques).forEach(incrementAuctionsCounter);\n    adUnits.forEach(au => {\n      if (!isPlainObject(au.mediaTypes)) {\n        au.mediaTypes = {};\n      }\n      // filter out bidders that cannot participate in the auction\n      au.bids = au.bids.filter(bid => !bid.bidder || dep.isAllowed(ACTIVITY_FETCH_BIDS, activityParams(MODULE_TYPE_BIDDER, bid.bidder)));\n      incrementRequestsCounter(au.code);\n    });\n    adUnits = setupAdUnitMediaTypes(adUnits, labels);\n    let {\n      [PARTITIONS.CLIENT]: clientBidders,\n      [PARTITIONS.SERVER]: serverBidders\n    } = partitionBidders(adUnits, _s2sConfigs);\n    if (config.getConfig('bidderSequence') === RANDOM) {\n      clientBidders = shuffle(clientBidders);\n    }\n    const refererInfo = getRefererInfo();\n    const bidRequests = [];\n    const ortb2 = ortb2Fragments.global || {};\n    const bidderOrtb2 = ortb2Fragments.bidder || {};\n    function addOrtb2(bidderRequest, s2sActivityParams) {\n      const redact = dep.redact(s2sActivityParams != null ? s2sActivityParams : activityParams(MODULE_TYPE_BIDDER, bidderRequest.bidderCode));\n      const fpd = Object.freeze(redact.ortb2(mergeDeep({\n        source: {\n          tid: auctionId\n        }\n      }, ortb2, bidderOrtb2[bidderRequest.bidderCode])));\n      bidderRequest.ortb2 = fpd;\n      bidderRequest.bids = bidderRequest.bids.map(bid => {\n        bid.ortb2 = fpd;\n        return redact.bidRequest(bid);\n      });\n      return bidderRequest;\n    }\n    _s2sConfigs.forEach(s2sConfig => {\n      const s2sParams = s2sActivityParams(s2sConfig);\n      if (s2sConfig && s2sConfig.enabled && dep.isAllowed(ACTIVITY_FETCH_BIDS, s2sParams)) {\n        const {\n          adUnits: adUnitsS2SCopy,\n          hasModuleBids\n        } = getAdUnitCopyForPrebidServer(adUnits, s2sConfig);\n\n        // uniquePbsTid is so we know which server to send which bids to during the callBids function\n        const uniquePbsTid = generateUUID();\n        (serverBidders.length === 0 && hasModuleBids ? [null] : serverBidders).forEach(bidderCode => {\n          const bidderRequestId = getUniqueIdentifierStr();\n          const metrics = auctionMetrics.fork();\n          const bidderRequest = addOrtb2({\n            bidderCode,\n            auctionId,\n            bidderRequestId,\n            uniquePbsTid,\n            bids: getBids({\n              bidderCode,\n              auctionId,\n              bidderRequestId,\n              'adUnits': deepClone(adUnitsS2SCopy),\n              src: S2S.SRC,\n              metrics\n            }),\n            auctionStart: auctionStart,\n            timeout: s2sConfig.timeout,\n            src: S2S.SRC,\n            refererInfo,\n            metrics\n          }, s2sParams);\n          if (bidderRequest.bids.length !== 0) {\n            bidRequests.push(bidderRequest);\n          }\n        });\n\n        // update the s2sAdUnits object and remove all bids that didn't pass sizeConfig/label checks from getBids()\n        // this is to keep consistency and only allow bids/adunits that passed the checks to go to pbs\n        adUnitsS2SCopy.forEach(adUnitCopy => {\n          const validBids = adUnitCopy.bids.filter(adUnitBid => bidRequests.find(request => request.bids.find(reqBid => reqBid.bidId === adUnitBid.bid_id)));\n          adUnitCopy.bids = validBids;\n        });\n        bidRequests.forEach(request => {\n          if (request.adUnitsS2SCopy === undefined) {\n            request.adUnitsS2SCopy = adUnitsS2SCopy.filter(au => au.bids.length > 0 || au.s2sBid != null);\n          }\n        });\n      }\n    });\n\n    // client adapters\n    const adUnitsClientCopy = getAdUnitCopyForClientAdapters(adUnits);\n    clientBidders.forEach(bidderCode => {\n      const bidderRequestId = getUniqueIdentifierStr();\n      const metrics = auctionMetrics.fork();\n      const bidderRequest = addOrtb2({\n        bidderCode,\n        auctionId,\n        bidderRequestId,\n        bids: getBids({\n          bidderCode,\n          auctionId,\n          bidderRequestId,\n          'adUnits': deepClone(adUnitsClientCopy),\n          src: 'client',\n          metrics\n        }),\n        auctionStart: auctionStart,\n        timeout: cbTimeout,\n        refererInfo,\n        metrics\n      });\n      const adapter = _bidderRegistry[bidderCode];\n      if (!adapter) {\n        logError(`Trying to make a request for bidder that does not exist: ${bidderCode}`);\n      }\n      if (adapter && bidderRequest.bids && bidderRequest.bids.length !== 0) {\n        bidRequests.push(bidderRequest);\n      }\n    });\n    bidRequests.forEach(bidRequest => {\n      if (gdprDataHandler.getConsentData()) {\n        bidRequest['gdprConsent'] = gdprDataHandler.getConsentData();\n      }\n      if (uspDataHandler.getConsentData()) {\n        bidRequest['uspConsent'] = uspDataHandler.getConsentData();\n      }\n      if (gppDataHandler.getConsentData()) {\n        bidRequest['gppConsent'] = gppDataHandler.getConsentData();\n      }\n    });\n    return bidRequests;\n  }, 'makeBidRequests'),\n  callBids(adUnits, bidRequests, addBidResponse, doneCb, requestCallbacks, requestBidsTimeout, onTimelyResponse) {\n    let ortb2Fragments = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n    if (!bidRequests.length) {\n      logWarn('callBids executed with no bidRequests.  Were they filtered by labels or sizing?');\n      return;\n    }\n    const [clientBidderRequests, serverBidderRequests] = bidRequests.reduce((partitions, bidRequest) => {\n      partitions[Number(typeof bidRequest.src !== 'undefined' && bidRequest.src === S2S.SRC)].push(bidRequest);\n      return partitions;\n    }, [[], []]);\n    var uniqueServerBidRequests = [];\n    serverBidderRequests.forEach(serverBidRequest => {\n      var index = -1;\n      for (var i = 0; i < uniqueServerBidRequests.length; ++i) {\n        if (serverBidRequest.uniquePbsTid === uniqueServerBidRequests[i].uniquePbsTid) {\n          index = i;\n          break;\n        }\n      }\n      if (index <= -1) {\n        uniqueServerBidRequests.push(serverBidRequest);\n      }\n    });\n    let counter = 0;\n    _s2sConfigs.forEach(s2sConfig => {\n      if (s2sConfig && uniqueServerBidRequests[counter] && getS2SBidderSet(s2sConfig).has(uniqueServerBidRequests[counter].bidderCode)) {\n        // s2s should get the same client side timeout as other client side requests.\n        const s2sAjax = ajaxBuilder(requestBidsTimeout, requestCallbacks ? {\n          request: requestCallbacks.request.bind(null, 's2s'),\n          done: requestCallbacks.done\n        } : undefined);\n        const adaptersServerSide = s2sConfig.bidders;\n        const s2sAdapter = _bidderRegistry[s2sConfig.adapter];\n        const uniquePbsTid = uniqueServerBidRequests[counter].uniquePbsTid;\n        const adUnitsS2SCopy = uniqueServerBidRequests[counter].adUnitsS2SCopy;\n        const uniqueServerRequests = serverBidderRequests.filter(serverBidRequest => serverBidRequest.uniquePbsTid === uniquePbsTid);\n        if (s2sAdapter) {\n          const s2sBidRequest = {\n            'ad_units': adUnitsS2SCopy,\n            s2sConfig,\n            ortb2Fragments,\n            requestBidsTimeout\n          };\n          if (s2sBidRequest.ad_units.length) {\n            const doneCbs = uniqueServerRequests.map(bidRequest => {\n              bidRequest.start = timestamp();\n              return function (timedOut) {\n                if (!timedOut) {\n                  onTimelyResponse(bidRequest.bidderRequestId);\n                }\n                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  args[_key - 1] = arguments[_key];\n                }\n                doneCb.apply(bidRequest, [timedOut, ...args]);\n              };\n            });\n            const bidders = getBidderCodes(s2sBidRequest.ad_units).filter(bidder => adaptersServerSide.includes(bidder));\n            logMessage(`CALLING S2S HEADER BIDDERS ==== ${bidders.length > 0 ? bidders.join(', ') : 'No bidder specified, using \"ortb2Imp\" definition(s) only'}`);\n\n            // fire BID_REQUESTED event for each s2s bidRequest\n            uniqueServerRequests.forEach(bidRequest => {\n              // add the new sourceTid\n              events.emit(EVENTS.BID_REQUESTED, {\n                ...bidRequest,\n                tid: bidRequest.auctionId\n              });\n            });\n\n            // make bid requests\n            s2sAdapter.callBids(s2sBidRequest, serverBidderRequests, addBidResponse, timedOut => doneCbs.forEach(done => done(timedOut)), s2sAjax);\n          }\n        } else {\n          logError('missing ' + s2sConfig.adapter);\n        }\n        counter++;\n      }\n    });\n\n    // handle client adapter requests\n    clientBidderRequests.forEach(bidderRequest => {\n      bidderRequest.start = timestamp();\n      const adapter = _bidderRegistry[bidderRequest.bidderCode];\n      config.runWithBidder(bidderRequest.bidderCode, () => {\n        logMessage(`CALLING BIDDER`);\n        events.emit(EVENTS.BID_REQUESTED, bidderRequest);\n      });\n      const ajax = ajaxBuilder(requestBidsTimeout, requestCallbacks ? {\n        request: requestCallbacks.request.bind(null, bidderRequest.bidderCode),\n        done: requestCallbacks.done\n      } : undefined);\n      const adapterDone = doneCb.bind(bidderRequest);\n      try {\n        config.runWithBidder(bidderRequest.bidderCode, adapter.callBids.bind(adapter, bidderRequest, addBidResponse, adapterDone, ajax, () => onTimelyResponse(bidderRequest.bidderRequestId), config.callbackWithBidder(bidderRequest.bidderCode)));\n      } catch (e) {\n        logError(`${bidderRequest.bidderCode} Bid Adapter emitted an uncaught error when parsing their bidRequest`, {\n          e,\n          bidRequest: bidderRequest\n        });\n        adapterDone();\n      }\n    });\n  },\n  videoAdapters: [],\n  registerBidAdapter(bidAdapter, bidderCode) {\n    let {\n      supportedMediaTypes = []\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (bidAdapter && bidderCode) {\n      if (typeof bidAdapter.callBids === 'function') {\n        _bidderRegistry[bidderCode] = bidAdapter;\n        GDPR_GVLIDS.register(MODULE_TYPE_BIDDER, bidderCode, bidAdapter.getSpec?.().gvlid);\n        if (true && supportedMediaTypes.includes('video')) {\n          adapterManager.videoAdapters.push(bidderCode);\n        }\n        if (true && supportedMediaTypes.includes('native')) {\n          nativeAdapters.push(bidderCode);\n        }\n      } else {\n        logError('Bidder adaptor error for bidder code: ' + bidderCode + 'bidder must implement a callBids() function');\n      }\n    } else {\n      logError('bidAdapter or bidderCode not specified');\n    }\n  },\n  aliasBidAdapter(bidderCode, alias, options) {\n    const existingAlias = _bidderRegistry[alias];\n    if (typeof existingAlias === 'undefined') {\n      const bidAdapter = _bidderRegistry[bidderCode];\n      if (typeof bidAdapter === 'undefined') {\n        // check if alias is part of s2sConfig and allow them to register if so (as base bidder may be s2s-only)\n        const nonS2SAlias = [];\n        _s2sConfigs.forEach(s2sConfig => {\n          if (s2sConfig.bidders && s2sConfig.bidders.length) {\n            const s2sBidders = s2sConfig && s2sConfig.bidders;\n            if (!(s2sConfig && s2sBidders.includes(alias))) {\n              nonS2SAlias.push(bidderCode);\n            } else {\n              _aliasRegistry[alias] = bidderCode;\n            }\n          }\n        });\n        nonS2SAlias.forEach(bidderCode => {\n          logError('bidderCode \"' + bidderCode + '\" is not an existing bidder.', 'adapterManager.aliasBidAdapter');\n        });\n      } else {\n        try {\n          let newAdapter;\n          const supportedMediaTypes = getSupportedMediaTypes(bidderCode);\n          // Have kept old code to support backward compatibilitiy.\n          // Remove this if loop when all adapters are supporting bidderFactory. i.e When Prebid.js is 1.0\n          if (bidAdapter.constructor.prototype != Object.prototype) {\n            newAdapter = new bidAdapter.constructor();\n            newAdapter.setBidderCode(alias);\n          } else {\n            const {\n              useBaseGvlid = false\n            } = options || {};\n            const spec = bidAdapter.getSpec();\n            const gvlid = useBaseGvlid ? spec.gvlid : options?.gvlid;\n            if (gvlid == null && spec.gvlid != null) {\n              logWarn(`Alias '${alias}' will NOT re-use the GVL ID of the original adapter ('${spec.code}', gvlid: ${spec.gvlid}). Functionality that requires TCF consent may not work as expected.`);\n            }\n            const skipPbsAliasing = options && options.skipPbsAliasing;\n            newAdapter = newBidder(Object.assign({}, spec, {\n              code: alias,\n              gvlid,\n              skipPbsAliasing\n            }));\n            _aliasRegistry[alias] = bidderCode;\n          }\n          adapterManager.registerBidAdapter(newAdapter, alias, {\n            supportedMediaTypes\n          });\n        } catch (e) {\n          logError(bidderCode + ' bidder does not currently support aliasing.', 'adapterManager.aliasBidAdapter');\n        }\n      }\n    } else {\n      logMessage('alias name \"' + alias + '\" has been already specified.');\n    }\n  },\n  resolveAlias(alias) {\n    let code = alias;\n    let visited;\n    while (_aliasRegistry[code] && (!visited || !visited.has(code))) {\n      code = _aliasRegistry[code];\n      (visited = visited || new Set()).add(code);\n    }\n    return code;\n  },\n  registerAnalyticsAdapter(_ref2) {\n    let {\n      adapter,\n      code,\n      gvlid\n    } = _ref2;\n    if (adapter && code) {\n      if (typeof adapter.enableAnalytics === 'function') {\n        adapter.code = code;\n        _analyticsRegistry[code] = {\n          adapter,\n          gvlid\n        };\n        GDPR_GVLIDS.register(MODULE_TYPE_ANALYTICS, code, gvlid);\n      } else {\n        logError(`Prebid Error: Analytics adaptor error for analytics \"${code}\"\n        analytics adapter must implement an enableAnalytics() function`);\n      }\n    } else {\n      logError('Prebid Error: analyticsAdapter or analyticsCode not specified');\n    }\n  },\n  enableAnalytics(config) {\n    if (!isArray(config)) {\n      config = [config];\n    }\n    config.forEach(adapterConfig => {\n      const entry = _analyticsRegistry[adapterConfig.provider];\n      if (entry && entry.adapter) {\n        if (dep.isAllowed(ACTIVITY_REPORT_ANALYTICS, activityParams(MODULE_TYPE_ANALYTICS, adapterConfig.provider, {\n          [ACTIVITY_PARAM_ANL_CONFIG]: adapterConfig\n        }))) {\n          entry.adapter.enableAnalytics(adapterConfig);\n        }\n      } else {\n        logError(`Prebid Error: no analytics adapter found in registry for '${adapterConfig.provider}'.`);\n      }\n    });\n  },\n  getBidAdapter(bidder) {\n    return _bidderRegistry[bidder];\n  },\n  getAnalyticsAdapter(code) {\n    return _analyticsRegistry[code];\n  },\n  callTimedOutBidders(adUnits, timedOutBidders, cbTimeout) {\n    timedOutBidders = timedOutBidders.map(timedOutBidder => {\n      // Adding user configured params & timeout to timeout event data\n      timedOutBidder.params = getUserConfiguredParams(adUnits, timedOutBidder.adUnitCode, timedOutBidder.bidder);\n      timedOutBidder.timeout = cbTimeout;\n      return timedOutBidder;\n    });\n    timedOutBidders = groupBy(timedOutBidders, 'bidder');\n    Object.keys(timedOutBidders).forEach(bidder => {\n      tryCallBidderMethod(bidder, 'onTimeout', timedOutBidders[bidder]);\n    });\n  },\n  callBidWonBidder(bidder, bid, adUnits) {\n    // Adding user configured params to bidWon event data\n    bid.params = getUserConfiguredParams(adUnits, bid.adUnitCode, bid.bidder);\n    incrementBidderWinsCounter(bid.adUnitCode, bid.bidder);\n    tryCallBidderMethod(bidder, 'onBidWon', bid);\n  },\n  triggerBilling: (() => {\n    const BILLED = new WeakSet();\n    return bid => {\n      if (!BILLED.has(bid)) {\n        BILLED.add(bid);\n        (parseEventTrackers(bid.eventtrackers)[EVENT_TYPE_IMPRESSION]?.[TRACKER_METHOD_IMG] || []).forEach(url => internal.triggerPixel(url));\n        tryCallBidderMethod(bid.bidder, 'onBidBillable', bid);\n      }\n    };\n  })(),\n  callSetTargetingBidder(bidder, bid) {\n    tryCallBidderMethod(bidder, 'onSetTargeting', bid);\n  },\n  callBidViewableBidder(bidder, bid) {\n    tryCallBidderMethod(bidder, 'onBidViewable', bid);\n  },\n  callBidderError(bidder, error, bidderRequest) {\n    const param = {\n      error,\n      bidderRequest\n    };\n    tryCallBidderMethod(bidder, 'onBidderError', param);\n  },\n  callAdRenderSucceededBidder(bidder, bid) {\n    tryCallBidderMethod(bidder, 'onAdRenderSucceeded', bid);\n  },\n  /**\n   * Ask every adapter to delete PII.\n   * See https://github.com/prebid/Prebid.js/issues/9081\n   */\n  callDataDeletionRequest: hook('sync', function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const method = 'onDataDeletionRequest';\n    Object.keys(_bidderRegistry).filter(bidder => !_aliasRegistry.hasOwnProperty(bidder)).forEach(bidder => {\n      const target = getBidderMethod(bidder, method);\n      if (target != null) {\n        const bidderRequests = auctionManager.getBidsRequested().filter(br => resolveAlias(br.bidderCode) === bidder);\n        invokeBidderMethod(bidder, method, ...target, bidderRequests, ...args);\n      }\n    });\n    Object.entries(_analyticsRegistry).forEach(_ref3 => {\n      let [name, entry] = _ref3;\n      const fn = entry?.adapter?.[method];\n      if (typeof fn === 'function') {\n        try {\n          fn.apply(entry.adapter, args);\n        } catch (e) {\n          logError(`error calling ${method} of ${name}`, e);\n        }\n      }\n    });\n  })\n};\nfunction getSupportedMediaTypes(bidderCode) {\n  const supportedMediaTypes = [];\n  if (true && adapterManager.videoAdapters.includes(bidderCode)) supportedMediaTypes.push('video');\n  if (true && nativeAdapters.includes(bidderCode)) supportedMediaTypes.push('native');\n  return supportedMediaTypes;\n}\nfunction getBidderMethod(bidder, method) {\n  const adapter = _bidderRegistry[bidder];\n  const spec = adapter?.getSpec && adapter.getSpec();\n  if (spec && spec[method] && typeof spec[method] === 'function') {\n    return [spec, spec[method]];\n  }\n}\nfunction invokeBidderMethod(bidder, method, spec, fn) {\n  try {\n    logInfo(`Invoking ${bidder}.${method}`);\n    for (var _len3 = arguments.length, params = new Array(_len3 > 4 ? _len3 - 4 : 0), _key3 = 4; _key3 < _len3; _key3++) {\n      params[_key3 - 4] = arguments[_key3];\n    }\n    config.runWithBidder(bidder, fn.bind(spec, ...params));\n  } catch (e) {\n    logWarn(`Error calling ${method} of ${bidder}`);\n  }\n}\nfunction tryCallBidderMethod(bidder, method, param) {\n  if (param?.source !== S2S.SRC) {\n    const target = getBidderMethod(bidder, method);\n    if (target != null) {\n      invokeBidderMethod(bidder, method, ...target, param);\n    }\n  }\n}\nfunction resolveAlias(alias) {\n  const seen = new Set();\n  while (_aliasRegistry.hasOwnProperty(alias) && !seen.has(alias)) {\n    seen.add(alias);\n    alias = _aliasRegistry[alias];\n  }\n  return alias;\n}\nexport default adapterManager;\n//# sourceMappingURL=adapterManager.js.map\n","import Adapter from '../adapter.js';\nimport adapterManager from '../adapterManager.js';\nimport { config } from '../config.js';\nimport { createBid } from '../bidfactory.js';\nimport { userSync } from '../userSync.js';\nimport { nativeBidIsValid } from '../native.js';\nimport { isValidVideoBid } from '../video.js';\nimport { EVENTS, REJECTION_REASON, DEBUG_MODE } from '../constants.js';\nimport * as events from '../events.js';\nimport { delayExecution, isArray, isPlainObject, logError, logWarn, memoize, parseQueryStringParameters, parseSizesInput, pick, uniques, isGzipCompressionSupported, compressDataWithGZip, getParameterByName, debugTurnedOn } from '../utils.js';\nimport { hook } from '../hook.js';\nimport { auctionManager } from '../auctionManager.js';\nimport { bidderSettings } from '../bidderSettings.js';\nimport { useMetrics } from '../utils/perfMetrics.js';\nimport { isActivityAllowed } from '../activities/rules.js';\nimport { activityParams } from '../activities/activityParams.js';\nimport { MODULE_TYPE_BIDDER } from '../activities/modules.js';\nimport { ACTIVITY_TRANSMIT_TID, ACTIVITY_TRANSMIT_UFPD } from '../activities/activities.js';\n/**\n * This file aims to support Adapters during the Prebid 0.x -> 1.x transition.\n *\n * Prebid 1.x and Prebid 0.x will be in separate branches--perhaps for a long time.\n * This function defines an API for adapter construction which is compatible with both versions.\n * Adapters which use it can maintain their code in master, and only this file will need to change\n * in the 1.x branch.\n *\n * Typical usage looks something like:\n *\n * const adapter = registerBidder({\n *   code: 'myBidderCode',\n *   aliases: ['alias1', 'alias2'],\n *   supportedMediaTypes: ['video', 'native'],\n *   isBidRequestValid: function(paramsObject) { return true/false },\n *   buildRequests: function(bidRequests, bidderRequest) { return some ServerRequest(s) },\n *   interpretResponse: function(oneServerResponse) { return some Bids, or throw an error. }\n * });\n *\n * @see BidderSpec for the full API and more thorough descriptions.\n *\n */\n\n/**\n * @typedef {object} ServerResponse\n *\n * @property {*} body The response body. If this is legal JSON, then it will be parsed. Otherwise it'll be a\n *   string with the body's content.\n * @property {{get: function(string): string}} headers The response headers.\n *   Call this like `ServerResponse.headers.get(\"Content-Type\")`\n */\n\n/**\n * @typedef {Object} SyncOptions\n *\n * An object containing information about usersyncs which the adapter should obey.\n *\n * @property {boolean} iframeEnabled True if iframe usersyncs are allowed, and false otherwise\n * @property {boolean} pixelEnabled True if image usersyncs are allowed, and false otherwise\n */\n\n/**\n * TODO: Move this to the UserSync module after that PR is merged.\n *\n * @typedef {object} UserSync\n *\n * @property {('image'|'iframe')} type The type of user sync to be done.\n * @property {string} url The URL which makes the sync happen.\n */\n\n// common params for all mediaTypes\nconst COMMON_BID_RESPONSE_KEYS = ['cpm', 'ttl', 'creativeId', 'netRevenue', 'currency'];\nconst TIDS = ['auctionId', 'transactionId'];\n/**\n * Register a bidder with prebid, using the given spec.\n *\n * If possible, Adapter modules should use this function instead of adapterManager.registerBidAdapter().\n *\n * @param {BidderSpec} spec An object containing the bare-bones functions we need to make a Bidder.\n */\nexport function registerBidder(spec) {\n  const mediaTypes = Array.isArray(spec.supportedMediaTypes) ? {\n    supportedMediaTypes: spec.supportedMediaTypes\n  } : undefined;\n  function putBidder(spec) {\n    const bidder = newBidder(spec);\n    adapterManager.registerBidAdapter(bidder, spec.code, mediaTypes);\n  }\n  putBidder(spec);\n  if (Array.isArray(spec.aliases)) {\n    spec.aliases.forEach(alias => {\n      let aliasCode = alias;\n      let gvlid;\n      let skipPbsAliasing;\n      if (isPlainObject(alias)) {\n        aliasCode = alias.code;\n        gvlid = alias.gvlid;\n        skipPbsAliasing = alias.skipPbsAliasing;\n      }\n      adapterManager.aliasRegistry[aliasCode] = spec.code;\n      putBidder(Object.assign({}, spec, {\n        code: aliasCode,\n        gvlid,\n        skipPbsAliasing\n      }));\n    });\n  }\n}\nexport const guardTids = memoize(_ref => {\n  let {\n    bidderCode\n  } = _ref;\n  if (isActivityAllowed(ACTIVITY_TRANSMIT_TID, activityParams(MODULE_TYPE_BIDDER, bidderCode))) {\n    return {\n      bidRequest: br => br,\n      bidderRequest: br => br\n    };\n  }\n  function get(target, prop, receiver) {\n    if (TIDS.includes(prop)) {\n      return null;\n    }\n    return Reflect.get(target, prop, receiver);\n  }\n  function privateAccessProxy(target, handler) {\n    const proxy = new Proxy(target, handler);\n    // always allow methods (such as getFloor) private access to TIDs\n    Object.entries(target).filter(_ref2 => {\n      let [_, v] = _ref2;\n      return typeof v === 'function';\n    }).forEach(_ref3 => {\n      let [prop, fn] = _ref3;\n      proxy[prop] = fn.bind(target);\n    });\n    return proxy;\n  }\n  const bidRequest = memoize(br => privateAccessProxy(br, {\n    get\n  }), arg => arg.bidId);\n  /**\n   * Return a view on bidd(er) requests where auctionId/transactionId are nulled if the bidder is not allowed `transmitTid`.\n   *\n   * Because both auctionId and transactionId are used for Prebid's own internal bookkeeping, we cannot simply erase them\n   * from request objects; and because request objects are quite complex and not easily cloneable, we hide the IDs\n   * with a proxy instead. This should be used only around the adapter logic.\n   */\n  return {\n    bidRequest,\n    bidderRequest: br => privateAccessProxy(br, {\n      get(target, prop, receiver) {\n        if (prop === 'bids') return br.bids.map(bidRequest);\n        return get(target, prop, receiver);\n      }\n    })\n  };\n});\n/**\n * Make a new bidder from the given spec. This is exported mainly for testing.\n * Adapters will probably find it more convenient to use registerBidder instead.\n *\n * @param {BidderSpec} spec\n */\nexport function newBidder(spec) {\n  return Object.assign(Adapter(spec.code), {\n    getSpec: function () {\n      return Object.freeze(Object.assign({}, spec));\n    },\n    registerSyncs,\n    callBids: function (bidderRequest, addBidResponse, done, ajax, onTimelyResponse, configEnabledCallback) {\n      if (!Array.isArray(bidderRequest.bids)) {\n        return;\n      }\n      const tidGuard = guardTids(bidderRequest);\n      const adUnitCodesHandled = {};\n      function addBidWithCode(adUnitCode, bid) {\n        const metrics = useMetrics(bid.metrics);\n        metrics.checkpoint('addBidResponse');\n        adUnitCodesHandled[adUnitCode] = true;\n        if (metrics.measureTime('addBidResponse.validate', () => isValid(adUnitCode, bid))) {\n          addBidResponse(adUnitCode, bid);\n        } else {\n          addBidResponse.reject(adUnitCode, bid, REJECTION_REASON.INVALID);\n        }\n      }\n\n      // After all the responses have come back, call done() and\n      // register any required usersync pixels.\n      const responses = [];\n      function afterAllResponses() {\n        done();\n        config.runWithBidder(spec.code, () => {\n          events.emit(EVENTS.BIDDER_DONE, bidderRequest);\n          registerSyncs(responses, bidderRequest.gdprConsent, bidderRequest.uspConsent, bidderRequest.gppConsent);\n        });\n      }\n      const validBidRequests = adapterMetrics(bidderRequest).measureTime('validate', () => bidderRequest.bids.filter(br => filterAndWarn(tidGuard.bidRequest(br))));\n      if (validBidRequests.length === 0) {\n        afterAllResponses();\n        return;\n      }\n      const bidRequestMap = {};\n      validBidRequests.forEach(bid => {\n        bidRequestMap[bid.bidId] = bid;\n      });\n      processBidderRequests(spec, validBidRequests, bidderRequest, ajax, configEnabledCallback, {\n        onRequest: requestObject => events.emit(EVENTS.BEFORE_BIDDER_HTTP, bidderRequest, requestObject),\n        onResponse: resp => {\n          onTimelyResponse(spec.code);\n          responses.push(resp);\n        },\n        onPaapi: paapiConfig => {\n          const bidRequest = bidRequestMap[paapiConfig.bidId];\n          if (bidRequest) {\n            addPaapiConfig(bidRequest, paapiConfig);\n          } else {\n            logWarn('Received fledge auction configuration for an unknown bidId', paapiConfig);\n          }\n        },\n        // If the server responds with an error, there's not much we can do beside logging.\n        onError: (errorMessage, error) => {\n          if (!error.timedOut) {\n            onTimelyResponse(spec.code);\n          }\n          adapterManager.callBidderError(spec.code, error, bidderRequest);\n          events.emit(EVENTS.BIDDER_ERROR, {\n            error,\n            bidderRequest\n          });\n          logError(`Server call for ${spec.code} failed: ${errorMessage} ${error.status}. Continuing without bids.`, {\n            bidRequests: validBidRequests\n          });\n        },\n        onBid: bidResponse => {\n          const bidRequest = bidRequestMap[bidResponse.requestId];\n          const bid = bidResponse;\n          if (bidRequest) {\n            bid.adapterCode = bidRequest.bidder;\n            if (isInvalidAlternateBidder(bidResponse.bidderCode, bidRequest.bidder)) {\n              logWarn(`${bidResponse.bidderCode} is not a registered partner or known bidder of ${bidRequest.bidder}, hence continuing without bid. If you wish to support this bidder, please mark allowAlternateBidderCodes as true in bidderSettings.`);\n              addBidResponse.reject(bidRequest.adUnitCode, bidResponse, REJECTION_REASON.BIDDER_DISALLOWED);\n              return;\n            }\n            // creating a copy of original values as cpm and currency are modified later\n            bid.originalCpm = bidResponse.cpm;\n            bid.originalCurrency = bidResponse.currency;\n            bid.meta = bidResponse.meta || Object.assign({}, bidResponse[bidRequest.bidder]);\n            bid.deferBilling = bidRequest.deferBilling;\n            bid.deferRendering = bid.deferBilling && (bidResponse.deferRendering ?? typeof spec.onBidBillable !== 'function');\n            const prebidBid = Object.assign(createBid(bidRequest), bid, pick(bidRequest, TIDS));\n            addBidWithCode(bidRequest.adUnitCode, prebidBid);\n          } else {\n            logWarn(`Bidder ${spec.code} made bid for unknown request ID: ${bidResponse.requestId}. Ignoring.`);\n            addBidResponse.reject(null, bidResponse, REJECTION_REASON.INVALID_REQUEST_ID);\n          }\n        },\n        onCompletion: afterAllResponses\n      });\n    }\n  });\n  function isInvalidAlternateBidder(responseBidder, requestBidder) {\n    const allowAlternateBidderCodes = bidderSettings.get(requestBidder, 'allowAlternateBidderCodes') || false;\n    let alternateBiddersList = bidderSettings.get(requestBidder, 'allowedAlternateBidderCodes');\n    if (!!responseBidder && !!requestBidder && requestBidder !== responseBidder) {\n      alternateBiddersList = isArray(alternateBiddersList) ? alternateBiddersList.map(val => val.trim().toLowerCase()).filter(val => !!val).filter(uniques) : alternateBiddersList;\n      if (!allowAlternateBidderCodes || isArray(alternateBiddersList) && alternateBiddersList[0] !== '*' && !alternateBiddersList.includes(responseBidder)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function registerSyncs(responses, gdprConsent, uspConsent, gppConsent) {\n    registerSyncInner(spec, responses, gdprConsent, uspConsent, gppConsent);\n  }\n  function filterAndWarn(bid) {\n    if (!spec.isBidRequestValid(bid)) {\n      logWarn(`Invalid bid sent to bidder ${spec.code}: ${JSON.stringify(bid)}`);\n      return false;\n    }\n    return true;\n  }\n}\nconst RESPONSE_PROPS = ['bids', 'paapi'];\n/**\n * Run a set of bid requests - that entails converting them to HTTP requests, sending\n * them over the network, and parsing the responses.\n *\n * @param spec bid adapter spec\n * @param bids bid requests to run\n * @param bidderRequest the bid request object that `bids` is connected to\n * @param ajax ajax method to use\n * @param wrapCallback a function used to wrap every callback (for the purpose of `config.currentBidder`)\n */\nexport const processBidderRequests = hook('async', function (spec, bids, bidderRequest, ajax, wrapCallback, _ref4) {\n  let {\n    onRequest,\n    onResponse,\n    onPaapi,\n    onError,\n    onBid,\n    onCompletion\n  } = _ref4;\n  const metrics = adapterMetrics(bidderRequest);\n  onCompletion = metrics.startTiming('total').stopBefore(onCompletion);\n  const tidGuard = guardTids(bidderRequest);\n  let requests = metrics.measureTime('buildRequests', () => spec.buildRequests(bids.map(tidGuard.bidRequest), tidGuard.bidderRequest(bidderRequest)));\n  if (!Array.isArray(requests)) {\n    requests = [requests];\n  }\n  if (!requests || requests.length === 0) {\n    onCompletion();\n    return;\n  }\n  const requestDone = delayExecution(onCompletion, requests.length);\n  requests.forEach(request => {\n    const requestMetrics = metrics.fork();\n    function addBid(bid) {\n      if (bid != null) bid.metrics = requestMetrics.fork().renameWith();\n      onBid(bid);\n    }\n    // If the server responds successfully, use the adapter code to unpack the Bids from it.\n    // If the adapter code fails, no bids should be added. After all the bids have been added,\n    // make sure to call the `requestDone` function so that we're one step closer to calling onCompletion().\n    const onSuccess = wrapCallback(function (response, responseObj) {\n      networkDone();\n      try {\n        response = JSON.parse(response);\n      } catch (e) {/* response might not be JSON... that's ok. */}\n\n      // Make response headers available for #1742. These are lazy-loaded because most adapters won't need them.\n      response = {\n        body: response,\n        headers: headerParser(responseObj)\n      };\n      onResponse(response);\n      try {\n        response = requestMetrics.measureTime('interpretResponse', () => spec.interpretResponse(response, request));\n      } catch (err) {\n        logError(`Bidder ${spec.code} failed to interpret the server's response. Continuing without bids`, null, err);\n        requestDone();\n        return;\n      }\n\n      // adapters can reply with:\n      // a single bid\n      // an array of bids\n      // a BidderAuctionResponse object\n\n      let bids, paapiConfigs;\n      if (response && !Object.keys(response).some(key => !RESPONSE_PROPS.includes(key))) {\n        bids = response.bids;\n        paapiConfigs = response.paapi;\n      } else {\n        bids = response;\n      }\n      if (isArray(paapiConfigs)) {\n        paapiConfigs.forEach(onPaapi);\n      }\n      if (bids) {\n        if (isArray(bids)) {\n          bids.forEach(addBid);\n        } else {\n          addBid(bids);\n        }\n      }\n      requestDone();\n      function headerParser(xmlHttpResponse) {\n        return {\n          get: responseObj.getResponseHeader.bind(responseObj)\n        };\n      }\n    });\n    const onFailure = wrapCallback(function (errorMessage, error) {\n      networkDone();\n      onError(errorMessage, error);\n      requestDone();\n    });\n    onRequest(request);\n    const networkDone = requestMetrics.startTiming('net');\n    const debugMode = getParameterByName(DEBUG_MODE).toUpperCase() === 'TRUE' || debugTurnedOn();\n    function getOptions(defaults) {\n      const ro = request.options;\n      return Object.assign(defaults, ro, {\n        browsingTopics: ro?.hasOwnProperty('browsingTopics') && !ro.browsingTopics ? false : (bidderSettings.get(spec.code, 'topicsHeader') ?? true) && isActivityAllowed(ACTIVITY_TRANSMIT_UFPD, activityParams(MODULE_TYPE_BIDDER, spec.code)),\n        suppressTopicsEnrollmentWarning: ro?.hasOwnProperty('suppressTopicsEnrollmentWarning') ? ro.suppressTopicsEnrollmentWarning : !debugMode\n      });\n    }\n    switch (request.method) {\n      case 'GET':\n        ajax(`${request.url}${formatGetParameters(request.data)}`, {\n          success: onSuccess,\n          error: onFailure\n        }, undefined, getOptions({\n          method: 'GET',\n          withCredentials: true\n        }));\n        break;\n      case 'POST':\n        const enableGZipCompression = request.options?.endpointCompression;\n        const callAjax = _ref5 => {\n          let {\n            url,\n            payload\n          } = _ref5;\n          ajax(url, {\n            success: onSuccess,\n            error: onFailure\n          }, payload, getOptions({\n            method: 'POST',\n            contentType: 'text/plain',\n            withCredentials: true\n          }));\n        };\n        if (enableGZipCompression && debugMode) {\n          logWarn(`Skipping GZIP compression for ${spec.code} as debug mode is enabled`);\n        }\n        if (enableGZipCompression && !debugMode && isGzipCompressionSupported()) {\n          compressDataWithGZip(request.data).then(compressedPayload => {\n            const url = new URL(request.url, window.location.origin);\n            if (!url.searchParams.has('gzip')) {\n              url.searchParams.set('gzip', '1');\n            }\n            callAjax({\n              url: url.href,\n              payload: compressedPayload\n            });\n          });\n        } else {\n          callAjax({\n            url: request.url,\n            payload: typeof request.data === 'string' ? request.data : JSON.stringify(request.data)\n          });\n        }\n        break;\n      default:\n        logWarn(`Skipping invalid request from ${spec.code}. Request type ${request.method} must be GET or POST`);\n        requestDone();\n    }\n    function formatGetParameters(data) {\n      if (data) {\n        return `?${typeof data === 'object' ? parseQueryStringParameters(data) : data}`;\n      }\n      return '';\n    }\n  });\n}, 'processBidderRequests');\nexport const registerSyncInner = hook('async', function (spec, responses, gdprConsent, uspConsent, gppConsent) {\n  const aliasSyncEnabled = config.getConfig('userSync.aliasSyncEnabled');\n  if (spec.getUserSyncs && (aliasSyncEnabled || !adapterManager.aliasRegistry[spec.code])) {\n    let syncs = spec.getUserSyncs({\n      iframeEnabled: userSync.canBidderRegisterSync('iframe', spec.code),\n      pixelEnabled: userSync.canBidderRegisterSync('image', spec.code)\n    }, responses, gdprConsent, uspConsent, gppConsent);\n    if (syncs) {\n      if (!Array.isArray(syncs)) {\n        syncs = [syncs];\n      }\n      syncs.forEach(sync => {\n        userSync.registerSync(sync.type, spec.code, sync.url);\n      });\n      userSync.bidderDone(spec.code);\n    }\n  }\n}, 'registerSyncs');\nexport const addPaapiConfig = hook('sync', (request, paapiConfig) => {}, 'addPaapiConfig');\n// check that the bid has a width and height set\nfunction validBidSize(adUnitCode, bid) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if ((bid.width || parseInt(bid.width, 10) === 0) && (bid.height || parseInt(bid.height, 10) === 0)) {\n    bid.width = parseInt(bid.width, 10);\n    bid.height = parseInt(bid.height, 10);\n    return true;\n  }\n  if (bid.wratio != null && bid.hratio != null) {\n    bid.wratio = parseInt(bid.wratio, 10);\n    bid.hratio = parseInt(bid.hratio, 10);\n    return true;\n  }\n  const bidRequest = index.getBidRequest(bid);\n  const mediaTypes = index.getMediaTypes(bid);\n  const sizes = bidRequest && bidRequest.sizes || mediaTypes && mediaTypes.banner && mediaTypes.banner.sizes;\n  const parsedSizes = parseSizesInput(sizes);\n\n  // if a banner impression has one valid size, we assign that size to any bid\n  // response that does not explicitly set width or height\n  if (parsedSizes.length === 1) {\n    const [width, height] = parsedSizes[0].split('x');\n    bid.width = parseInt(width, 10);\n    bid.height = parseInt(height, 10);\n    return true;\n  }\n  return false;\n}\n\n// Validate the arguments sent to us by the adapter. If this returns false, the bid should be totally ignored.\nexport function isValid(adUnitCode, bid) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  function hasValidKeys() {\n    const bidKeys = Object.keys(bid);\n    return COMMON_BID_RESPONSE_KEYS.every(key => bidKeys.includes(key) && ![undefined, null].includes(bid[key]));\n  }\n  function errorMessage(msg) {\n    return `Invalid bid from ${bid.bidderCode}. Ignoring bid: ${msg}`;\n  }\n  if (!adUnitCode) {\n    logWarn('No adUnitCode was supplied to addBidResponse.');\n    return false;\n  }\n  if (!bid) {\n    logWarn(`Some adapter tried to add an undefined bid for ${adUnitCode}.`);\n    return false;\n  }\n  if (!hasValidKeys()) {\n    logError(errorMessage(`Bidder ${bid.bidderCode} is missing required params. Check http://prebid.org/dev-docs/bidder-adapter-1.html for list of params.`));\n    return false;\n  }\n  if (true && bid.mediaType === 'native' && !nativeBidIsValid(bid, {\n    index\n  })) {\n    logError(errorMessage('Native bid missing some required properties.'));\n    return false;\n  }\n  if (true && bid.mediaType === 'video' && !isValidVideoBid(bid, {\n    index\n  })) {\n    logError(errorMessage(`Video bid does not have required vastUrl or renderer property`));\n    return false;\n  }\n  if (bid.mediaType === 'banner' && !validBidSize(adUnitCode, bid, {\n    index\n  })) {\n    logError(errorMessage(`Banner bids require a width and height`));\n    return false;\n  }\n  return true;\n}\nexport function adapterMetrics(bidderRequest) {\n  return useMetrics(bidderRequest.metrics).renameWith(n => [`adapter.client.${n}`, `adapters.client.${bidderRequest.bidderCode}.${n}`]);\n}\n//# sourceMappingURL=bidderFactory.js.map\n","import { LOAD_EXTERNAL_SCRIPT } from './activities/activities.js';\nimport { activityParams } from './activities/activityParams.js';\nimport { isActivityAllowed } from './activities/rules.js';\nimport { insertElement, logError, logWarn, setScriptAttributes } from './utils.js';\nconst _requestCache = new WeakMap();\n// The below list contains modules or vendors whom Prebid allows to load external JS.\nconst _approvedLoadExternalJSList = [\n// Prebid maintained modules:\n'debugging', 'outstream',\n// RTD modules:\n'aaxBlockmeter', 'adagio', 'adloox', 'arcspan', 'airgrid', 'browsi', 'brandmetrics', 'clean.io', 'humansecurityMalvDefense', 'humansecurity', 'confiant', 'contxtful', 'hadron', 'mediafilter', 'medianet', 'azerionedge', 'a1Media', 'geoedge', 'qortex', 'dynamicAdBoost', '51Degrees', 'symitridap', 'wurfl', 'nodalsAi', 'anonymised', 'optable',\n// UserId Submodules\n'justtag', 'tncId', 'ftrackId', 'id5'];\n\n/**\n * Loads external javascript. Can only be used if external JS is approved by Prebid. See https://github.com/prebid/prebid-js-external-js-template#policy\n * Each unique URL will be loaded at most 1 time.\n * @param {string} url the url to load\n * @param {string} moduleType moduleType of the module requesting this resource\n * @param {string} moduleCode bidderCode or module code of the module requesting this resource\n * @param {function} [callback] callback function to be called after the script is loaded\n * @param {Document} [doc] the context document, in which the script will be loaded, defaults to loaded document\n * @param {object} attributes an object of attributes to be added to the script with setAttribute by [key] and [value]; Only the attributes passed in the first request of a url will be added.\n */\nexport function loadExternalScript(url, moduleType, moduleCode, callback, doc, attributes) {\n  if (!isActivityAllowed(LOAD_EXTERNAL_SCRIPT, activityParams(moduleType, moduleCode))) {\n    return;\n  }\n  if (!moduleCode || !url) {\n    logError('cannot load external script without url and moduleCode');\n    return;\n  }\n  if (!_approvedLoadExternalJSList.includes(moduleCode)) {\n    logError(`${moduleCode} not whitelisted for loading external JavaScript`);\n    return;\n  }\n  if (!doc) {\n    doc = document; // provide a \"valid\" key for the WeakMap\n  }\n  // only load each asset once\n  const storedCachedObject = getCacheObject(doc, url);\n  if (storedCachedObject) {\n    if (callback && typeof callback === 'function') {\n      if (storedCachedObject.loaded) {\n        // invokeCallbacks immediately\n        callback();\n      } else {\n        // queue the callback\n        storedCachedObject.callbacks.push(callback);\n      }\n    }\n    return storedCachedObject.tag;\n  }\n  const cachedDocObj = _requestCache.get(doc) || {};\n  const cacheObject = {\n    loaded: false,\n    tag: null,\n    callbacks: []\n  };\n  cachedDocObj[url] = cacheObject;\n  _requestCache.set(doc, cachedDocObj);\n  if (callback && typeof callback === 'function') {\n    cacheObject.callbacks.push(callback);\n  }\n  logWarn(`module ${moduleCode} is loading external JavaScript`);\n  return requestResource(url, function () {\n    cacheObject.loaded = true;\n    try {\n      for (let i = 0; i < cacheObject.callbacks.length; i++) {\n        cacheObject.callbacks[i]();\n      }\n    } catch (e) {\n      logError('Error executing callback', 'adloader.js:loadExternalScript', e);\n    }\n  }, doc, attributes);\n  function requestResource(tagSrc, callback, doc, attributes) {\n    if (!doc) {\n      doc = document;\n    }\n    var jptScript = doc.createElement('script');\n    jptScript.type = 'text/javascript';\n    jptScript.async = true;\n    const cacheObject = getCacheObject(doc, url);\n    if (cacheObject) {\n      cacheObject.tag = jptScript;\n    }\n    if (jptScript.readyState) {\n      jptScript.onreadystatechange = function () {\n        if (jptScript.readyState === 'loaded' || jptScript.readyState === 'complete') {\n          jptScript.onreadystatechange = null;\n          callback();\n        }\n      };\n    } else {\n      jptScript.onload = function () {\n        callback();\n      };\n    }\n    jptScript.src = tagSrc;\n    if (attributes) {\n      setScriptAttributes(jptScript, attributes);\n    }\n\n    // add the new script tag to the page\n    insertElement(jptScript, doc);\n    return jptScript;\n  }\n  function getCacheObject(doc, url) {\n    const cachedDocObj = _requestCache.get(doc);\n    if (cachedDocObj && cachedDocObj[url]) {\n      return cachedDocObj[url];\n    }\n    return null; // return new cache object?\n  }\n}\n;\n//# sourceMappingURL=adloader.js.map\n","import { ACTIVITY_ACCESS_REQUEST_CREDENTIALS } from './activities/activities.js';\nimport { activityParams } from './activities/activityParams.js';\nimport { isActivityAllowed } from './activities/rules.js';\nimport { config } from './config.js';\nimport { hook } from './hook.js';\nimport { buildUrl, hasDeviceAccess, logError, parseUrl } from './utils.js';\nexport const dep = {\n  fetch: window.fetch.bind(window),\n  makeRequest: (r, o) => new Request(r, o),\n  timeout(timeout, resource) {\n    const ctl = new AbortController();\n    let cancelTimer = setTimeout(() => {\n      ctl.abort();\n      logError(`Request timeout after ${timeout}ms`, resource);\n      cancelTimer = null;\n    }, timeout);\n    return {\n      signal: ctl.signal,\n      done() {\n        cancelTimer && clearTimeout(cancelTimer);\n      }\n    };\n  }\n};\nconst GET = 'GET';\nconst POST = 'POST';\nconst CTYPE = 'Content-Type';\nexport const processRequestOptions = hook('async', function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let moduleType = arguments.length > 1 ? arguments[1] : undefined;\n  let moduleName = arguments.length > 2 ? arguments[2] : undefined;\n  if (options.withCredentials) {\n    options.withCredentials = moduleType && moduleName ? isActivityAllowed(ACTIVITY_ACCESS_REQUEST_CREDENTIALS, activityParams(moduleType, moduleName)) : hasDeviceAccess();\n  }\n  return options;\n}, 'processRequestOptions');\n\n/**\n * transform legacy `ajax` parameters into a fetch request.\n * @returns {Request}\n */\nexport function toFetchRequest(url, data) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const method = options.method || (data ? POST : GET);\n  if (method === GET && data) {\n    const urlInfo = parseUrl(url, options);\n    Object.assign(urlInfo.search, data);\n    url = buildUrl(urlInfo);\n  }\n  const headers = new Headers(options.customHeaders);\n  headers.set(CTYPE, options.contentType || 'text/plain');\n  const rqOpts = {\n    method,\n    headers\n  };\n  if (method !== GET && data) {\n    rqOpts.body = data;\n  }\n  if (options.withCredentials) {\n    rqOpts.credentials = 'include';\n  }\n  if (isSecureContext) {\n    ['browsingTopics', 'adAuctionHeaders'].forEach(opt => {\n      // the Request constructor will throw an exception if the browser supports topics/fledge\n      // but we're not in a secure context\n      if (options[opt]) {\n        rqOpts[opt] = true;\n      }\n    });\n    if (options.suppressTopicsEnrollmentWarning != null) {\n      rqOpts.suppressTopicsEnrollmentWarning = options.suppressTopicsEnrollmentWarning;\n    }\n  }\n  if (options.keepalive) {\n    rqOpts.keepalive = true;\n  }\n  return dep.makeRequest(url, rqOpts);\n}\n\n/**\n * Return a version of `fetch` that automatically cancels requests after `timeout` milliseconds.\n *\n * If provided, `request` and `done` should be functions accepting a single argument.\n * `request` is invoked at the beginning of each request, and `done` at the end; both are passed its origin.\n *\n */\nexport function fetcherFactory() {\n  let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;\n  let {\n    request,\n    done\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let moduleType = arguments.length > 2 ? arguments[2] : undefined;\n  let moduleName = arguments.length > 3 ? arguments[3] : undefined;\n  let fetcher = (resource, options) => {\n    let to;\n    if (timeout != null && options?.signal == null && !config.getConfig('disableAjaxTimeout')) {\n      to = dep.timeout(timeout, resource);\n      options = Object.assign({\n        signal: to.signal\n      }, options);\n    }\n    processRequestOptions(options, moduleType, moduleName);\n    let pm = dep.fetch(resource, options);\n    if (to?.done != null) pm = pm.finally(to.done);\n    return pm;\n  };\n  if (request != null || done != null) {\n    fetcher = (fetch => function (resource, options) {\n      const origin = new URL(resource?.url == null ? resource : resource.url, document.location).origin;\n      let req = fetch(resource, options);\n      request && request(origin);\n      if (done) req = req.finally(() => done(origin));\n      return req;\n    })(fetcher);\n  }\n  return fetcher;\n}\nfunction toXHR(_ref, responseText) {\n  let {\n    status,\n    statusText = '',\n    headers,\n    url\n  } = _ref;\n  let xml;\n  function getXML(onError) {\n    if (xml === undefined) {\n      try {\n        xml = new DOMParser().parseFromString(responseText, headers?.get(CTYPE)?.split(';')?.[0]);\n      } catch (e) {\n        xml = null;\n        onError && onError(e);\n      }\n    }\n    return xml;\n  }\n  return {\n    // eslint-disable-next-line no-restricted-globals\n    readyState: XMLHttpRequest.DONE,\n    status,\n    statusText,\n    responseText,\n    response: responseText,\n    responseType: '',\n    responseURL: url,\n    get responseXML() {\n      return getXML(logError);\n    },\n    getResponseHeader: header => headers?.has(header) ? headers.get(header) : null,\n    toJSON() {\n      return Object.assign({\n        responseXML: getXML()\n      }, this);\n    },\n    timedOut: false\n  };\n}\n\n/**\n * attach legacy `ajax` callbacks to a fetch promise.\n */\nexport function attachCallbacks(fetchPm, callback) {\n  const {\n    success,\n    error\n  } = typeof callback === 'object' && callback != null ? callback : {\n    success: typeof callback === 'function' ? callback : () => null,\n    error: (e, x) => logError('Network error', e, x)\n  };\n  return fetchPm.then(response => response.text().then(responseText => [response, responseText])).then(_ref2 => {\n    let [response, responseText] = _ref2;\n    const xhr = toXHR(response, responseText);\n    response.ok || response.status === 304 ? success(responseText, xhr) : error(response.statusText, xhr);\n  }, reason => error('', Object.assign(toXHR({\n    status: 0\n  }, ''), {\n    reason,\n    timedOut: reason?.name === 'AbortError'\n  })));\n}\nexport function ajaxBuilder() {\n  let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;\n  let {\n    request,\n    done\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let moduleType = arguments.length > 2 ? arguments[2] : undefined;\n  let moduleName = arguments.length > 3 ? arguments[3] : undefined;\n  const fetcher = fetcherFactory(timeout, {\n    request,\n    done\n  }, moduleType, moduleName);\n  return function (url, callback, data) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    attachCallbacks(fetcher(toFetchRequest(url, data, options)), callback);\n  };\n}\n\n/**\n * simple wrapper around sendBeacon such that invocations of navigator.sendBeacon can be centrally maintained.\n * verifies that the navigator and sendBeacon are defined for maximum compatibility\n * @param {string} url The URL that will receive the data. Can be relative or absolute.\n * @param {*} data An ArrayBuffer, a TypedArray, a DataView, a Blob, a string literal or object, a FormData or a URLSearchParams object containing the data to send.\n * @returns {boolean} true if the user agent successfully queued the data for transfer. Otherwise, it returns false.\n */\nexport function sendBeacon(url, data) {\n  if (!window.navigator || !window.navigator.sendBeacon) {\n    return false;\n  }\n  return window.navigator.sendBeacon(url, data);\n}\nexport const ajax = ajaxBuilder();\nexport const fetch = fetcherFactory();\n//# sourceMappingURL=ajax.js.map\n","import { generateUUID, isEmpty, isEmptyStr, isFn, logError, logInfo, logMessage, logWarn, parseUrl, timestamp } from './utils.js';\nimport { getPriceBucketString } from './cpmBucketManager.js';\nimport { isNativeResponse, setNativeResponseProperties } from './native.js';\nimport { batchAndStore, storeLocally } from './videoCache.js';\nimport { Renderer } from './Renderer.js';\nimport { config } from './config.js';\nimport { userSync } from './userSync.js';\nimport { hook, ignoreCallbackArg } from './hook.js';\nimport { OUTSTREAM } from './video.js';\nimport { AUDIO, VIDEO } from './mediaTypes.js';\nimport { auctionManager } from './auctionManager.js';\nimport { bidderSettings } from './bidderSettings.js';\nimport * as events from './events.js';\nimport adapterManager from './adapterManager.js';\nimport { EVENTS, GRANULARITY_OPTIONS, JSON_MAPPING, REJECTION_REASON, S2S, TARGETING_KEYS } from './constants.js';\nimport { defer, PbPromise } from './utils/promise.js';\nimport { useMetrics } from './utils/perfMetrics.js';\nimport { adjustCpm } from './utils/cpm.js';\nimport { getGlobal } from './prebidGlobal.js';\nimport { ttlCollection } from './utils/ttlCollection.js';\nimport { getMinBidCacheTTL, onMinBidCacheTTLChange } from './bidTTL.js';\nconst {\n  syncUsers\n} = userSync;\nexport const AUCTION_STARTED = 'started';\nexport const AUCTION_IN_PROGRESS = 'inProgress';\nexport const AUCTION_COMPLETED = 'completed';\n// register event for bid adjustment\nevents.on(EVENTS.BID_ADJUSTMENT, function (bid) {\n  adjustBids(bid);\n});\nconst MAX_REQUESTS_PER_ORIGIN = 4;\nconst outstandingRequests = {};\nconst sourceInfo = {};\nconst queuedCalls = [];\nconst pbjsInstance = getGlobal();\n\n/**\n * Clear global state for tests\n */\nexport function resetAuctionState() {\n  queuedCalls.length = 0;\n  [outstandingRequests, sourceInfo].forEach(ob => Object.keys(ob).forEach(k => {\n    delete ob[k];\n  }));\n}\nexport function newAuction(_ref) {\n  let {\n    adUnits,\n    adUnitCodes,\n    callback,\n    cbTimeout,\n    labels,\n    auctionId,\n    ortb2Fragments,\n    metrics\n  } = _ref;\n  metrics = useMetrics(metrics);\n  const _adUnits = adUnits;\n  const _labels = labels;\n  const _adUnitCodes = adUnitCodes;\n  const _auctionId = auctionId || generateUUID();\n  const _timeout = cbTimeout;\n  const _timelyRequests = new Set();\n  const done = defer();\n  const requestsDone = defer();\n  let _bidsRejected = [];\n  let _callback = callback;\n  let _bidderRequests = [];\n  const _bidsReceived = ttlCollection({\n    startTime: bid => bid.responseTimestamp,\n    ttl: bid => getMinBidCacheTTL() == null ? null : Math.max(getMinBidCacheTTL(), bid.ttl) * 1000\n  });\n  let _noBids = [];\n  let _winningBids = [];\n  let _auctionStart;\n  let _auctionEnd;\n  let _timeoutTimer;\n  let _auctionStatus;\n  let _nonBids = [];\n  onMinBidCacheTTLChange(() => _bidsReceived.refresh());\n  function addBidRequests(bidderRequests) {\n    _bidderRequests = _bidderRequests.concat(bidderRequests);\n  }\n  function addBidReceived(bid) {\n    _bidsReceived.add(bid);\n  }\n  function addBidRejected(bidsRejected) {\n    _bidsRejected = _bidsRejected.concat(bidsRejected);\n  }\n  function addNoBid(noBid) {\n    _noBids = _noBids.concat(noBid);\n  }\n  function addNonBids(seatnonbids) {\n    _nonBids = _nonBids.concat(seatnonbids);\n  }\n  function getProperties() {\n    return {\n      auctionId: _auctionId,\n      timestamp: _auctionStart,\n      auctionEnd: _auctionEnd,\n      auctionStatus: _auctionStatus,\n      adUnits: _adUnits,\n      adUnitCodes: _adUnitCodes,\n      labels: _labels,\n      bidderRequests: _bidderRequests,\n      noBids: _noBids,\n      bidsReceived: _bidsReceived.toArray(),\n      bidsRejected: _bidsRejected,\n      winningBids: _winningBids,\n      timeout: _timeout,\n      metrics: metrics,\n      seatNonBids: _nonBids\n    };\n  }\n  function startAuctionTimer() {\n    _timeoutTimer = setTimeout(() => executeCallback(true), _timeout);\n  }\n  function executeCallback(timedOut) {\n    if (!timedOut) {\n      clearTimeout(_timeoutTimer);\n    } else {\n      events.emit(EVENTS.AUCTION_TIMEOUT, getProperties());\n    }\n    if (_auctionEnd === undefined) {\n      let timedOutRequests = [];\n      if (timedOut) {\n        logMessage(`Auction ${_auctionId} timedOut`);\n        timedOutRequests = _bidderRequests.filter(rq => !_timelyRequests.has(rq.bidderRequestId)).flatMap(br => br.bids);\n        if (timedOutRequests.length) {\n          events.emit(EVENTS.BID_TIMEOUT, timedOutRequests);\n        }\n      }\n      _auctionStatus = AUCTION_COMPLETED;\n      _auctionEnd = Date.now();\n      metrics.checkpoint('auctionEnd');\n      metrics.timeBetween('requestBids', 'auctionEnd', 'requestBids.total');\n      metrics.timeBetween('callBids', 'auctionEnd', 'requestBids.callBids');\n      done.resolve();\n      events.emit(EVENTS.AUCTION_END, getProperties());\n      bidsBackCallback(_adUnits, function () {\n        try {\n          if (_callback != null) {\n            const bids = _bidsReceived.toArray().filter(bid => _adUnitCodes.includes(bid.adUnitCode)).reduce(groupByPlacement, {});\n            _callback.apply(pbjsInstance, [bids, timedOut, _auctionId]);\n            _callback = null;\n          }\n        } catch (e) {\n          logError('Error executing bidsBackHandler', null, e);\n        } finally {\n          // Calling timed out bidders\n          if (timedOutRequests.length) {\n            adapterManager.callTimedOutBidders(adUnits, timedOutRequests, _timeout);\n          }\n          // Only automatically sync if the publisher has not chosen to \"enableOverride\"\n          const userSyncConfig = config.getConfig('userSync') ?? {};\n          if (!userSyncConfig.enableOverride) {\n            // Delay the auto sync by the config delay\n            syncUsers(userSyncConfig.syncDelay);\n          }\n        }\n      });\n    }\n  }\n  function auctionDone() {\n    config.resetBidder();\n    // when all bidders have called done callback atleast once it means auction is complete\n    logInfo(`Bids Received for Auction with id: ${_auctionId}`, _bidsReceived.toArray());\n    _auctionStatus = AUCTION_COMPLETED;\n    executeCallback(false);\n  }\n  function onTimelyResponse(bidderRequestId) {\n    _timelyRequests.add(bidderRequestId);\n  }\n  function callBids() {\n    _auctionStatus = AUCTION_STARTED;\n    _auctionStart = Date.now();\n    const bidRequests = metrics.measureTime('requestBids.makeRequests', () => adapterManager.makeBidRequests(_adUnits, _auctionStart, _auctionId, _timeout, _labels, ortb2Fragments, metrics));\n    logInfo(`Bids Requested for Auction with id: ${_auctionId}`, bidRequests);\n    metrics.checkpoint('callBids');\n    if (bidRequests.length < 1) {\n      logWarn('No valid bid requests returned for auction');\n      auctionDone();\n    } else {\n      addBidderRequests.call({\n        dispatch: addBidderRequestsCallback,\n        context: this\n      }, bidRequests);\n    }\n  }\n\n  /**\n   * callback executed after addBidderRequests completes\n   * @param {BidRequest[]} bidRequests\n   */\n  function addBidderRequestsCallback(bidRequests) {\n    bidRequests.forEach(bidRequest => {\n      addBidRequests(bidRequest);\n    });\n    const requests = {};\n    const call = {\n      bidRequests,\n      run: () => {\n        startAuctionTimer();\n        _auctionStatus = AUCTION_IN_PROGRESS;\n        events.emit(EVENTS.AUCTION_INIT, getProperties());\n        const callbacks = auctionCallbacks(auctionDone, this);\n        adapterManager.callBids(_adUnits, bidRequests, callbacks.addBidResponse, callbacks.adapterDone, {\n          request(source, origin) {\n            increment(outstandingRequests, origin);\n            increment(requests, source);\n            if (!sourceInfo[source]) {\n              sourceInfo[source] = {\n                SRA: true,\n                origin\n              };\n            }\n            if (requests[source] > 1) {\n              sourceInfo[source].SRA = false;\n            }\n          },\n          done(origin) {\n            outstandingRequests[origin]--;\n            if (queuedCalls[0]) {\n              if (runIfOriginHasCapacity(queuedCalls[0])) {\n                queuedCalls.shift();\n              }\n            }\n          }\n        }, _timeout, onTimelyResponse, ortb2Fragments);\n        requestsDone.resolve();\n      }\n    };\n    if (!runIfOriginHasCapacity(call)) {\n      logWarn('queueing auction due to limited endpoint capacity');\n      queuedCalls.push(call);\n    }\n    function runIfOriginHasCapacity(call) {\n      let hasCapacity = true;\n      const maxRequests = config.getConfig('maxRequestsPerOrigin') || MAX_REQUESTS_PER_ORIGIN;\n      call.bidRequests.some(bidRequest => {\n        let requests = 1;\n        const source = typeof bidRequest.src !== 'undefined' && bidRequest.src === S2S.SRC ? 's2s' : bidRequest.bidderCode;\n        // if we have no previous info on this source just let them through\n        if (sourceInfo[source]) {\n          if (sourceInfo[source].SRA === false) {\n            // some bidders might use more than the MAX_REQUESTS_PER_ORIGIN in a single auction.  In those cases\n            // set their request count to MAX_REQUESTS_PER_ORIGIN so the auction isn't permanently queued waiting\n            // for capacity for that bidder\n            requests = Math.min(bidRequest.bids.length, maxRequests);\n          }\n          if (outstandingRequests[sourceInfo[source].origin] + requests > maxRequests) {\n            hasCapacity = false;\n          }\n        }\n        // return only used for terminating this .some() iteration early if it is determined we don't have capacity\n        return !hasCapacity;\n      });\n      if (hasCapacity) {\n        call.run();\n      }\n      return hasCapacity;\n    }\n    function increment(obj, prop) {\n      if (typeof obj[prop] === 'undefined') {\n        obj[prop] = 1;\n      } else {\n        obj[prop]++;\n      }\n    }\n  }\n  function addWinningBid(winningBid) {\n    _winningBids = _winningBids.concat(winningBid);\n    adapterManager.callBidWonBidder(winningBid.adapterCode || winningBid.bidder, winningBid, adUnits);\n    if (!winningBid.deferBilling) {\n      adapterManager.triggerBilling(winningBid);\n    }\n  }\n  function setBidTargeting(bid) {\n    adapterManager.callSetTargetingBidder(bid.adapterCode || bid.bidder, bid);\n  }\n  events.on(EVENTS.SEAT_NON_BID, event => {\n    if (event.auctionId === _auctionId) {\n      addNonBids(event.seatnonbid);\n    }\n  });\n  return {\n    addBidReceived,\n    addBidRejected,\n    addNoBid,\n    callBids,\n    addWinningBid,\n    setBidTargeting,\n    getWinningBids: () => _winningBids,\n    getAuctionStart: () => _auctionStart,\n    getAuctionEnd: () => _auctionEnd,\n    getTimeout: () => _timeout,\n    getAuctionId: () => _auctionId,\n    getAuctionStatus: () => _auctionStatus,\n    getAdUnits: () => _adUnits,\n    getAdUnitCodes: () => _adUnitCodes,\n    getBidRequests: () => _bidderRequests,\n    getBidsReceived: () => _bidsReceived.toArray(),\n    getNoBids: () => _noBids,\n    getNonBids: () => _nonBids,\n    getFPD: () => ortb2Fragments,\n    getMetrics: () => metrics,\n    end: done.promise,\n    requestsDone: requestsDone.promise,\n    getProperties\n  };\n}\n/**\n * Hook into this to intercept bids before they are added to an auction.\n */\nexport const addBidResponse = ignoreCallbackArg(hook('async', function (adUnitCode, bid, reject) {\n  if (!isValidPrice(bid)) {\n    reject(REJECTION_REASON.PRICE_TOO_HIGH);\n  } else {\n    this.dispatch.call(null, adUnitCode, bid);\n  }\n}, 'addBidResponse'));\n\n/**\n * Delay hook for adapter responses.\n *\n * `ready` is a promise; auctions wait for it to resolve before closing. Modules can hook into this\n * to delay the end of auctions while they perform initialization that does not need to delay their start.\n */\nexport const responsesReady = hook('sync', ready => ready, 'responsesReady');\nexport const addBidderRequests = hook('sync', function (bidderRequests) {\n  this.dispatch.call(this.context, bidderRequests);\n}, 'addBidderRequests');\nexport const bidsBackCallback = hook('async', function (adUnits, callback) {\n  if (callback) {\n    callback();\n  }\n}, 'bidsBackCallback');\nexport function auctionCallbacks(auctionDone, auctionInstance) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let outstandingBidsAdded = 0;\n  let allAdapterCalledDone = false;\n  const bidderRequestsDone = new Set();\n  const bidResponseMap = {};\n  function afterBidAdded() {\n    outstandingBidsAdded--;\n    if (allAdapterCalledDone && outstandingBidsAdded === 0) {\n      auctionDone();\n    }\n  }\n  function handleBidResponse(adUnitCode, bid, handler) {\n    bidResponseMap[bid.requestId] = true;\n    addCommonResponseProperties(bid, adUnitCode);\n    outstandingBidsAdded++;\n    return handler(afterBidAdded);\n  }\n  function acceptBidResponse(adUnitCode, bid) {\n    handleBidResponse(adUnitCode, bid, done => {\n      const bidResponse = getPreparedBidForAuction(bid);\n      events.emit(EVENTS.BID_ACCEPTED, bidResponse);\n      if (true && bidResponse.mediaType === VIDEO || true && bidResponse.mediaType === AUDIO) {\n        tryAddVideoAudioBid(auctionInstance, bidResponse, done);\n      } else {\n        if (true && isNativeResponse(bidResponse)) {\n          setNativeResponseProperties(bidResponse, index.getAdUnit(bidResponse));\n        }\n        addBidToAuction(auctionInstance, bidResponse);\n        done();\n      }\n    });\n  }\n  function rejectBidResponse(adUnitCode, bid, reason) {\n    return handleBidResponse(adUnitCode, bid, done => {\n      bid.rejectionReason = reason;\n      logWarn(`Bid from ${bid.bidder || 'unknown bidder'} was rejected: ${reason}`, bid);\n      events.emit(EVENTS.BID_REJECTED, bid);\n      auctionInstance.addBidRejected(bid);\n      done();\n    });\n  }\n  function adapterDone() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const bidderRequest = this;\n    let bidderRequests = auctionInstance.getBidRequests();\n    const auctionOptionsConfig = config.getConfig('auctionOptions');\n    bidderRequestsDone.add(bidderRequest);\n    if (auctionOptionsConfig && !isEmpty(auctionOptionsConfig)) {\n      const secondaryBidders = auctionOptionsConfig.secondaryBidders;\n      if (secondaryBidders && !bidderRequests.every(bidder => secondaryBidders.includes(bidder.bidderCode))) {\n        bidderRequests = bidderRequests.filter(request => !secondaryBidders.includes(request.bidderCode));\n      }\n    }\n    allAdapterCalledDone = bidderRequests.every(bidderRequest => bidderRequestsDone.has(bidderRequest));\n    bidderRequest.bids.forEach(bid => {\n      if (!bidResponseMap[bid.bidId]) {\n        auctionInstance.addNoBid(bid);\n        events.emit(EVENTS.NO_BID, bid);\n      }\n    });\n    if (allAdapterCalledDone && outstandingBidsAdded === 0) {\n      auctionDone();\n    }\n  }\n  return {\n    addBidResponse: function () {\n      function addBid(adUnitCode, bid) {\n        addBidResponse.call({\n          dispatch: acceptBidResponse\n        }, adUnitCode, bid, (() => {\n          let rejected = false;\n          return reason => {\n            if (!rejected) {\n              rejectBidResponse(adUnitCode, bid, reason);\n              rejected = true;\n            }\n          };\n        })());\n      }\n      addBid.reject = rejectBidResponse;\n      return addBid;\n    }(),\n    adapterDone: function () {\n      responsesReady(PbPromise.resolve()).finally(() => adapterDone.call(this));\n    }\n  };\n}\n\n// Add a bid to the auction.\nexport function addBidToAuction(auctionInstance, bidResponse) {\n  setupBidTargeting(bidResponse);\n  useMetrics(bidResponse.metrics).timeSince('addBidResponse', 'addBidResponse.total');\n  auctionInstance.addBidReceived(bidResponse);\n  events.emit(EVENTS.BID_RESPONSE, bidResponse);\n}\n\n// Video bids may fail if the cache is down, or there's trouble on the network.\nfunction tryAddVideoAudioBid(auctionInstance, bidResponse, afterBidAdded) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let addBid = true;\n  const videoMediaType = index.getMediaTypes({\n    requestId: bidResponse.originalRequestId || bidResponse.requestId,\n    adUnitId: bidResponse.adUnitId\n  })?.video;\n  const context = videoMediaType && videoMediaType?.context;\n  const useCacheKey = videoMediaType && videoMediaType?.useCacheKey;\n  const {\n    useLocal,\n    url: cacheUrl,\n    ignoreBidderCacheKey\n  } = config.getConfig('cache') || {};\n  if (useLocal) {\n    // stores video/audio bid vast as local blob in the browser\n    storeLocally(bidResponse);\n  } else if (cacheUrl && (useCacheKey || context !== OUTSTREAM)) {\n    if (!bidResponse.videoCacheKey || ignoreBidderCacheKey) {\n      addBid = false;\n      callPrebidCache(auctionInstance, bidResponse, afterBidAdded, videoMediaType);\n    } else if (!bidResponse.vastUrl) {\n      logError('videoCacheKey specified but not required vastUrl for video bid');\n      addBid = false;\n    }\n  }\n  if (addBid) {\n    addBidToAuction(auctionInstance, bidResponse);\n    afterBidAdded();\n  }\n}\nexport const callPrebidCache = hook('async', function (auctionInstance, bidResponse, afterBidAdded, videoMediaType) {\n  if (true || true) {\n    batchAndStore(auctionInstance, bidResponse, afterBidAdded);\n  }\n}, 'callPrebidCache');\n/**\n * Augment `bidResponse` with properties that are common across all bids - including rejected bids.\n */\nfunction addCommonResponseProperties(bidResponse, adUnitCode) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const bidderRequest = index.getBidderRequest(bidResponse);\n  const adUnit = index.getAdUnit(bidResponse);\n  const start = bidderRequest && bidderRequest.start || bidResponse.requestTimestamp;\n  Object.assign(bidResponse, {\n    responseTimestamp: bidResponse.responseTimestamp || timestamp(),\n    requestTimestamp: bidResponse.requestTimestamp || start,\n    cpm: parseFloat(bidResponse.cpm) || 0,\n    bidder: bidResponse.bidder || bidResponse.bidderCode,\n    adUnitCode\n  });\n  if (adUnit?.ttlBuffer != null) {\n    bidResponse.ttlBuffer = adUnit.ttlBuffer;\n  }\n  bidResponse.timeToRespond = bidResponse.responseTimestamp - bidResponse.requestTimestamp;\n}\n\n/**\n * Add additional bid response properties that are universal for all _accepted_ bids.\n */\nfunction getPreparedBidForAuction(bid) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Let listeners know that now is the time to adjust the bid, if they want to.\n  //\n  // CAREFUL: Publishers rely on certain bid properties to be available (like cpm),\n  // but others to not be set yet (like priceStrings). See #1372 and #1389.\n  events.emit(EVENTS.BID_ADJUSTMENT, bid);\n  const adUnit = index.getAdUnit(bid);\n  bid.instl = adUnit?.ortb2Imp?.instl === 1;\n\n  // a publisher-defined renderer can be used to render bids\n  const bidRenderer = index.getBidRequest(bid)?.renderer || adUnit.renderer;\n\n  // a publisher can also define a renderer for a mediaType\n  const bidObjectMediaType = bid.mediaType;\n  const mediaTypes = index.getMediaTypes(bid);\n  const bidMediaType = mediaTypes && mediaTypes[bidObjectMediaType];\n  var mediaTypeRenderer = bidMediaType && bidMediaType.renderer;\n  var renderer = null;\n\n  // the renderer for the mediaType takes precendence\n  if (mediaTypeRenderer && mediaTypeRenderer.render && !(mediaTypeRenderer.backupOnly === true && bid.renderer)) {\n    renderer = mediaTypeRenderer;\n  } else if (bidRenderer && bidRenderer.render && !(bidRenderer.backupOnly === true && bid.renderer)) {\n    renderer = bidRenderer;\n  }\n  if (renderer) {\n    // be aware, an adapter could already have installed the bidder, in which case this overwrite's the existing adapter\n    bid.renderer = Renderer.install({\n      url: renderer.url,\n      config: renderer.options,\n      renderNow: renderer.url == null\n    }); // rename options to config, to make it consistent?\n    bid.renderer.setRender(renderer.render);\n  }\n\n  // Use the config value 'mediaTypeGranularity' if it has been defined for mediaType, else use 'customPriceBucket'\n  const mediaTypeGranularity = getMediaTypeGranularity(bid.mediaType, mediaTypes, config.getConfig('mediaTypePriceGranularity'));\n  const priceStringsObj = getPriceBucketString(bid.cpm, typeof mediaTypeGranularity === 'object' ? mediaTypeGranularity : config.getConfig('customPriceBucket'), config.getConfig('currency.granularityMultiplier'));\n  bid.pbLg = priceStringsObj.low;\n  bid.pbMg = priceStringsObj.med;\n  bid.pbHg = priceStringsObj.high;\n  bid.pbAg = priceStringsObj.auto;\n  bid.pbDg = priceStringsObj.dense;\n  bid.pbCg = priceStringsObj.custom;\n  return bid;\n}\nfunction setupBidTargeting(bidObject) {\n  let keyValues;\n  const cpmCheck = bidderSettings.get(bidObject.bidderCode, 'allowZeroCpmBids') === true ? bidObject.cpm >= 0 : bidObject.cpm > 0;\n  if (bidObject.bidderCode && (cpmCheck || bidObject.dealId)) {\n    keyValues = getKeyValueTargetingPairs(bidObject.bidderCode, bidObject);\n  }\n\n  // use any targeting provided as defaults, otherwise just set from getKeyValueTargetingPairs\n  bidObject.adserverTargeting = Object.assign(bidObject.adserverTargeting || {}, keyValues);\n}\nexport function getMediaTypeGranularity(mediaType, mediaTypes, mediaTypePriceGranularity) {\n  if (mediaType && mediaTypePriceGranularity) {\n    if (true && mediaType === VIDEO) {\n      const context = mediaTypes?.[VIDEO]?.context ?? 'instream';\n      if (mediaTypePriceGranularity[`${VIDEO}-${context}`]) {\n        return mediaTypePriceGranularity[`${VIDEO}-${context}`];\n      }\n    }\n    return mediaTypePriceGranularity[mediaType];\n  }\n}\n\n/**\n * This function returns the price granularity defined. It can be either publisher defined or default value\n * @param {Bid} bid bid response object\n * @param {object} obj\n * @param {object} obj.index\n * @returns {string} granularity\n */\nexport const getPriceGranularity = function (bid) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Use the config value 'mediaTypeGranularity' if it has been set for mediaType, else use 'priceGranularity'\n  const mediaTypeGranularity = getMediaTypeGranularity(bid.mediaType, index.getMediaTypes(bid), config.getConfig('mediaTypePriceGranularity'));\n  const granularity = typeof bid.mediaType === 'string' && mediaTypeGranularity ? typeof mediaTypeGranularity === 'string' ? mediaTypeGranularity : 'custom' : config.getConfig('priceGranularity');\n  return granularity;\n};\n\n/**\n * This function returns a function to get bid price by price granularity\n * @param {string} granularity\n * @returns {function}\n */\nexport const getPriceByGranularity = granularity => {\n  return bid => {\n    const bidGranularity = granularity || getPriceGranularity(bid);\n    if (bidGranularity === GRANULARITY_OPTIONS.AUTO) {\n      return bid.pbAg;\n    } else if (bidGranularity === GRANULARITY_OPTIONS.DENSE) {\n      return bid.pbDg;\n    } else if (bidGranularity === GRANULARITY_OPTIONS.LOW) {\n      return bid.pbLg;\n    } else if (bidGranularity === GRANULARITY_OPTIONS.MEDIUM) {\n      return bid.pbMg;\n    } else if (bidGranularity === GRANULARITY_OPTIONS.HIGH) {\n      return bid.pbHg;\n    } else if (bidGranularity === GRANULARITY_OPTIONS.CUSTOM) {\n      return bid.pbCg;\n    }\n  };\n};\n\n/**\n * This function returns a function to get crid from bid response\n * @returns {function}\n */\nexport const getCreativeId = () => {\n  return bid => {\n    return bid.creativeId ? bid.creativeId : '';\n  };\n};\n\n/**\n * This function returns a function to get first advertiser domain from bid response meta\n * @returns {function}\n */\nexport const getAdvertiserDomain = () => {\n  return bid => {\n    return bid.meta && bid.meta.advertiserDomains && bid.meta.advertiserDomains.length > 0 ? [bid.meta.advertiserDomains].flat()[0] : '';\n  };\n};\n\n/**\n * This function returns a function to get dsp name or id from bid response meta\n * @returns {function}\n */\nexport const getDSP = () => {\n  return bid => {\n    return bid.meta && (bid.meta.networkId || bid.meta.networkName) ? bid?.meta?.networkName || bid?.meta?.networkId : '';\n  };\n};\n\n/**\n * This function returns a function to get the primary category id from bid response meta\n * @returns {function}\n */\nexport const getPrimaryCatId = () => {\n  return bid => {\n    const catId = bid?.meta?.primaryCatId;\n    if (Array.isArray(catId)) {\n      return catId[0] || '';\n    }\n    return catId || '';\n  };\n};\nfunction createKeyVal(key, value) {\n  return {\n    key,\n    val: typeof value === 'function' ? function (bidResponse, bidReq) {\n      return value(bidResponse, bidReq);\n    } : function (bidResponse) {\n      return bidResponse[value];\n    }\n  };\n}\nfunction defaultAdserverTargeting() {\n  return [createKeyVal(TARGETING_KEYS.BIDDER, 'bidderCode'), createKeyVal(TARGETING_KEYS.AD_ID, 'adId'), createKeyVal(TARGETING_KEYS.PRICE_BUCKET, getPriceByGranularity()), createKeyVal(TARGETING_KEYS.SIZE, 'size'), createKeyVal(TARGETING_KEYS.DEAL, 'dealId'), createKeyVal(TARGETING_KEYS.SOURCE, 'source'), createKeyVal(TARGETING_KEYS.FORMAT, 'mediaType'), createKeyVal(TARGETING_KEYS.ADOMAIN, getAdvertiserDomain()), createKeyVal(TARGETING_KEYS.ACAT, getPrimaryCatId()), createKeyVal(TARGETING_KEYS.DSP, getDSP()), createKeyVal(TARGETING_KEYS.CRID, getCreativeId())];\n}\n\n/**\n * @param {string} mediaType\n * @param {string} bidderCode\n * @returns {*}\n */\nexport function getStandardBidderSettings(mediaType, bidderCode) {\n  const standardSettings = Object.assign({}, bidderSettings.settingsFor(null));\n  if (!standardSettings[JSON_MAPPING.ADSERVER_TARGETING]) {\n    standardSettings[JSON_MAPPING.ADSERVER_TARGETING] = defaultAdserverTargeting();\n  }\n  if (true && mediaType === 'video') {\n    const adserverTargeting = standardSettings[JSON_MAPPING.ADSERVER_TARGETING].slice();\n    standardSettings[JSON_MAPPING.ADSERVER_TARGETING] = adserverTargeting;\n\n    // Adding hb_uuid + hb_cache_id\n    [TARGETING_KEYS.UUID, TARGETING_KEYS.CACHE_ID].forEach(targetingKeyVal => {\n      if (typeof adserverTargeting.find(kvPair => kvPair.key === targetingKeyVal) === 'undefined') {\n        adserverTargeting.push(createKeyVal(targetingKeyVal, 'videoCacheKey'));\n      }\n    });\n\n    // Adding hb_cache_host\n    if (config.getConfig('cache.url') && (!bidderCode || bidderSettings.get(bidderCode, 'sendStandardTargeting') !== false)) {\n      const urlInfo = parseUrl(config.getConfig('cache.url'));\n      if (typeof adserverTargeting.find(targetingKeyVal => targetingKeyVal.key === TARGETING_KEYS.CACHE_HOST) === 'undefined') {\n        adserverTargeting.push(createKeyVal(TARGETING_KEYS.CACHE_HOST, function (bidResponse) {\n          return bidResponse?.adserverTargeting?.[TARGETING_KEYS.CACHE_HOST] || urlInfo.hostname;\n        }));\n      }\n    }\n  }\n  return standardSettings;\n}\nexport function getKeyValueTargetingPairs(bidderCode, custBidObj) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!custBidObj) {\n    return {};\n  }\n  const bidRequest = index.getBidRequest(custBidObj);\n  var keyValues = {};\n\n  // 1) set the keys from \"standard\" setting or from prebid defaults\n  // initialize default if not set\n  const standardSettings = getStandardBidderSettings(custBidObj.mediaType, bidderCode);\n  setKeys(keyValues, standardSettings, custBidObj, bidRequest);\n\n  // 2) set keys from specific bidder setting override if they exist\n  if (bidderCode && bidderSettings.getOwn(bidderCode, JSON_MAPPING.ADSERVER_TARGETING)) {\n    setKeys(keyValues, bidderSettings.ownSettingsFor(bidderCode), custBidObj, bidRequest);\n    custBidObj.sendStandardTargeting = bidderSettings.get(bidderCode, 'sendStandardTargeting');\n  }\n  return keyValues;\n}\nfunction setKeys(keyValues, bidderSettings, custBidObj, bidReq) {\n  var targeting = bidderSettings[JSON_MAPPING.ADSERVER_TARGETING];\n  custBidObj.size = custBidObj.getSize();\n  (targeting || []).forEach(function (kvPair) {\n    var key = kvPair.key;\n    var value = kvPair.val;\n    if (keyValues[key]) {\n      logWarn('The key: ' + key + ' is being overwritten');\n    }\n    if (isFn(value)) {\n      try {\n        value = value(custBidObj, bidReq);\n      } catch (e) {\n        logError('bidmanager', 'ERROR', e);\n      }\n    }\n    if ((typeof bidderSettings.suppressEmptyKeys !== 'undefined' && bidderSettings.suppressEmptyKeys === true || key === TARGETING_KEYS.DEAL || key === TARGETING_KEYS.ACAT || key === TARGETING_KEYS.DSP || key === TARGETING_KEYS.CRID) && (\n    // hb_deal & hb_acat are suppressed automatically if not set\n\n    isEmptyStr(value) || value === null || value === undefined)) {\n      logInfo(\"suppressing empty key '\" + key + \"' from adserver targeting\");\n    } else {\n      keyValues[key] = value;\n    }\n  });\n  return keyValues;\n}\nexport function adjustBids(bid) {\n  const bidPriceAdjusted = adjustCpm(bid.cpm, bid);\n  if (bidPriceAdjusted >= 0) {\n    bid.cpm = bidPriceAdjusted;\n  }\n}\n\n/**\n * groupByPlacement is a reduce function that converts an array of Bid objects\n * to an object with placement codes as keys, with each key representing an object\n * with an array of `Bid` objects for that placement\n * @returns {*} as { [adUnitCode]: { bids: [Bid, Bid, Bid] } }\n */\nfunction groupByPlacement(bidsByPlacement, bid) {\n  if (!bidsByPlacement[bid.adUnitCode]) {\n    bidsByPlacement[bid.adUnitCode] = {\n      bids: []\n    };\n  }\n  bidsByPlacement[bid.adUnitCode].bids.push(bid);\n  return bidsByPlacement;\n}\n\n/**\n * isValidPrice is price validation function\n * which checks if price from bid response\n * is not higher than top limit set in config\n * @type {Function}\n * @param bid\n * @returns {boolean}\n */\nfunction isValidPrice(bid) {\n  const maxBidValue = config.getConfig('maxBid');\n  if (!maxBidValue || !bid.cpm) return true;\n  return maxBidValue >= Number(bid.cpm);\n}\n//# sourceMappingURL=auction.js.map\n","/**\n * @typedef {Object} AuctionIndex\n *\n * @property {function({ auctionId?: * }): *} getAuction Returns auction instance for `auctionId`\n * @property {function({ adUnitId?: * }): *} getAdUnit Returns `adUnit` object for `transactionId`.\n * You should prefer `getMediaTypes` for looking up bid media types.\n * @property {function({ adUnitId?: *, requestId?: * }): *} getMediaTypes Returns mediaTypes object from bidRequest (through `requestId`) falling back to the adUnit (through `transactionId`).\n * The bidRequest is given precedence because its mediaTypes can differ from the adUnit's (if bidder-specific labels are in use).\n * Bids that have no associated request do not have labels either, and use the adUnit's mediaTypes.\n * @property {function({ requestId?: *, bidderRequestId?: * }): *} getBidderRequest Returns bidderRequest that matches both requestId and bidderRequestId (if either or both are provided).\n * Bid responses are not guaranteed to have a corresponding request.\n * @property {function({ requestId?: string }): *} getBidRequest Returns bidRequest object for requestId.\n * Bid responses are not guaranteed to have a corresponding request.\n */\n\n/**\n * Retrieves request-related bid data.\n * All methods are designed to work with Bid (response) objects returned by bid adapters.\n */\nexport function AuctionIndex(getAuctions) {\n  Object.assign(this, {\n    getAuction(_ref) {\n      let {\n        auctionId\n      } = _ref;\n      if (auctionId != null) {\n        return getAuctions().find(auction => auction.getAuctionId() === auctionId);\n      }\n    },\n    getAdUnit(_ref2) {\n      let {\n        adUnitId\n      } = _ref2;\n      if (adUnitId != null) {\n        return getAuctions().flatMap(a => a.getAdUnits()).find(au => au.adUnitId === adUnitId);\n      }\n    },\n    getMediaTypes(_ref3) {\n      let {\n        adUnitId,\n        requestId\n      } = _ref3;\n      if (requestId != null) {\n        const req = this.getBidRequest({\n          requestId\n        });\n        if (req != null && (adUnitId == null || req.adUnitId === adUnitId)) {\n          return req.mediaTypes;\n        }\n      } else if (adUnitId != null) {\n        const au = this.getAdUnit({\n          adUnitId\n        });\n        if (au != null) {\n          return au.mediaTypes;\n        }\n      }\n    },\n    getBidderRequest(_ref4) {\n      let {\n        requestId,\n        bidderRequestId\n      } = _ref4;\n      if (requestId != null || bidderRequestId != null) {\n        let bers = getAuctions().flatMap(a => a.getBidRequests());\n        if (bidderRequestId != null) {\n          bers = bers.filter(ber => ber.bidderRequestId === bidderRequestId);\n        }\n        if (requestId == null) {\n          return bers[0];\n        } else {\n          return bers.find(ber => ber.bids && ber.bids.find(br => br.bidId === requestId) != null);\n        }\n      }\n    },\n    getBidRequest(_ref5) {\n      let {\n        requestId\n      } = _ref5;\n      if (requestId != null) {\n        return getAuctions().flatMap(a => a.getBidRequests()).flatMap(ber => ber.bids).find(br => br && br.bidId === requestId);\n      }\n    },\n    getOrtb2(bid) {\n      return this.getBidderRequest(bid)?.ortb2 || this.getAuction(bid)?.getFPD()?.global?.ortb2;\n    }\n  });\n}\n//# sourceMappingURL=auctionIndex.js.map\n","/**\n * AuctionManager modules is responsible for creating auction instances.\n * This module is the gateway for Prebid core to access auctions.\n * It stores all created instances of auction and can be used to get consolidated values from auction.\n */\n\n/**\n * @typedef {Object} AuctionManager\n *\n * @property {function(): Array} getBidsRequested - returns consolidated bid requests\n * @property {function(): Array} getBidsReceived - returns consolidated bid received\n * @property {function(string): Array} getAllBidsForAdUnitCode - returns consolidated bid received for a given adUnit\n * @property {function(): Array} getAllWinningBids - returns all winning bids\n * @property {function(): Array} getAdUnits - returns consolidated adUnits\n * @property {function(): Array} getAdUnitCodes - returns consolidated adUnitCodes\n * @property {function(): Array} getNoBids - returns consolidated adUnitCodes\n * @property {function(string, string): void} setStatusForBids - set status for bids\n * @property {function(): string} getLastAuctionId - returns last auctionId\n * @property {function(Object): Object} createAuction - creates auction instance and stores it for future reference\n * @property {function(string): Object} findBidByAdId - find bid received by adId. This function will be called by $$PREBID_GLOBAL$$.renderAd\n * @property {function(): Object} getStandardBidderAdServerTargeting - returns standard bidder targeting for all the adapters. Refer http://prebid.org/dev-docs/publisher-api-reference.html#module_pbjs.bidderSettings for more details\n * @property {function(Object): void} addWinningBid - add a winning bid to an auction based on auctionId\n * @property {function(): void} clearAllAuctions - clear all auctions for testing\n * @property {function(*): *} onExpiry\n * @property {AuctionIndex} index\n */\n\nimport { uniques, logWarn } from './utils.js';\nimport { newAuction, getStandardBidderSettings, AUCTION_COMPLETED } from './auction.js';\nimport { AuctionIndex } from './auctionIndex.js';\nimport { BID_STATUS, JSON_MAPPING } from './constants.js';\nimport { useMetrics } from './utils/perfMetrics.js';\nimport { ttlCollection } from './utils/ttlCollection.js';\nimport { getMinBidCacheTTL, onMinBidCacheTTLChange } from './bidTTL.js';\n\n/**\n * Creates new instance of auctionManager. There will only be one instance of auctionManager but\n * a factory is created to assist in testing.\n *\n * @returns {AuctionManager} auctionManagerInstance\n */\nexport function newAuctionManager() {\n  const _auctions = ttlCollection({\n    startTime: au => au.end.then(() => au.getAuctionEnd()),\n    ttl: au => getMinBidCacheTTL() == null ? null : au.end.then(() => {\n      return Math.max(getMinBidCacheTTL(), ...au.getBidsReceived().map(bid => bid.ttl)) * 1000;\n    })\n  });\n  onMinBidCacheTTLChange(() => _auctions.refresh());\n  const auctionManager = {\n    onExpiry: _auctions.onExpiry\n  };\n  function getAuction(auctionId) {\n    for (const auction of _auctions) {\n      if (auction.getAuctionId() === auctionId) return auction;\n    }\n  }\n  auctionManager.addWinningBid = function (bid) {\n    const metrics = useMetrics(bid.metrics);\n    metrics.checkpoint('bidWon');\n    metrics.timeBetween('auctionEnd', 'bidWon', 'adserver.pending');\n    metrics.timeBetween('requestBids', 'bidWon', 'adserver.e2e');\n    const auction = getAuction(bid.auctionId);\n    if (auction) {\n      auction.addWinningBid(bid);\n    } else {\n      logWarn(`Auction not found when adding winning bid`);\n    }\n  };\n  Object.entries({\n    getAllWinningBids: {\n      name: 'getWinningBids'\n    },\n    getBidsRequested: {\n      name: 'getBidRequests'\n    },\n    getNoBids: {},\n    getAdUnits: {},\n    getBidsReceived: {\n      pre(auction) {\n        return auction.getAuctionStatus() === AUCTION_COMPLETED;\n      }\n    },\n    getAdUnitCodes: {\n      post: uniques\n    }\n  }).forEach(_ref => {\n    let [mgrMethod, {\n      name = mgrMethod,\n      pre,\n      post\n    }] = _ref;\n    const mapper = pre == null ? auction => auction[name]() : auction => pre(auction) ? auction[name]() : [];\n    const filter = post == null ? items => items : items => items.filter(post);\n    auctionManager[mgrMethod] = () => {\n      return filter(_auctions.toArray().flatMap(mapper));\n    };\n  });\n  function allBidsReceived() {\n    return _auctions.toArray().flatMap(au => au.getBidsReceived());\n  }\n  auctionManager.getAllBidsForAdUnitCode = function (adUnitCode) {\n    return allBidsReceived().filter(bid => bid && bid.adUnitCode === adUnitCode);\n  };\n  auctionManager.createAuction = function (opts) {\n    const auction = newAuction(opts);\n    _addAuction(auction);\n    return auction;\n  };\n  auctionManager.findBidByAdId = function (adId) {\n    return allBidsReceived().find(bid => bid.adId === adId);\n  };\n  auctionManager.getStandardBidderAdServerTargeting = function () {\n    return getStandardBidderSettings()[JSON_MAPPING.ADSERVER_TARGETING];\n  };\n  auctionManager.setStatusForBids = function (adId, status) {\n    const bid = auctionManager.findBidByAdId(adId);\n    if (bid) bid.status = status;\n    if (bid && status === BID_STATUS.BID_TARGETING_SET) {\n      const auction = getAuction(bid.auctionId);\n      if (auction) auction.setBidTargeting(bid);\n    }\n  };\n  auctionManager.getLastAuctionId = function () {\n    const auctions = _auctions.toArray();\n    return auctions.length && auctions[auctions.length - 1].getAuctionId();\n  };\n  auctionManager.clearAllAuctions = function () {\n    _auctions.clear();\n  };\n  function _addAuction(auction) {\n    _auctions.add(auction);\n  }\n  auctionManager.index = new AuctionIndex(() => _auctions.toArray());\n  return auctionManager;\n}\nexport const auctionManager = newAuctionManager();\n//# sourceMappingURL=auctionManager.js.map\n","import { config } from './config.js';\nimport { logError } from './utils.js';\nconst CACHE_TTL_SETTING = 'minBidCacheTTL';\nlet TTL_BUFFER = 1;\nlet minCacheTTL = null;\nconst listeners = [];\nconfig.getConfig('ttlBuffer', cfg => {\n  if (typeof cfg.ttlBuffer === 'number') {\n    TTL_BUFFER = cfg.ttlBuffer;\n  } else {\n    logError('Invalid value for ttlBuffer', cfg.ttlBuffer);\n  }\n});\nexport function getBufferedTTL(bid) {\n  return bid.ttl - (bid.hasOwnProperty('ttlBuffer') ? bid.ttlBuffer : TTL_BUFFER);\n}\nexport function getMinBidCacheTTL() {\n  return minCacheTTL;\n}\nconfig.getConfig(CACHE_TTL_SETTING, cfg => {\n  const prev = minCacheTTL;\n  minCacheTTL = cfg?.[CACHE_TTL_SETTING];\n  minCacheTTL = typeof minCacheTTL === 'number' ? minCacheTTL : null;\n  if (prev !== minCacheTTL) {\n    listeners.forEach(l => l(minCacheTTL));\n  }\n});\nexport function onMinBidCacheTTLChange(listener) {\n  listeners.push(listener);\n}\n//# sourceMappingURL=bidTTL.js.map\n","import { deepAccess, mergeDeep } from './utils.js';\nimport { getGlobal } from './prebidGlobal.js';\nimport { JSON_MAPPING } from './constants.js';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nexport class ScopedSettings {\n  constructor(getSettings, defaultScope) {\n    this.getSettings = getSettings;\n    this.defaultScope = defaultScope;\n  }\n\n  /**\n   * Get setting value at `path` under the given scope, falling back to the default scope if needed.\n   * If `scope` is `null`, get the setting's default value.\n   */\n  get(scope, path) {\n    let value = this.getOwn(scope, path);\n    if (typeof value === 'undefined') {\n      value = this.getOwn(null, path);\n    }\n    return value;\n  }\n\n  /**\n   * Get the setting value at `path` *without* falling back to the default value.\n   */\n  getOwn(scope, path) {\n    scope = this.#resolveScope(scope);\n    return deepAccess(this.getSettings(), `${scope}.${path}`);\n  }\n\n  /**\n   * @returns all existing scopes except the default one.\n   */\n  getScopes() {\n    return Object.keys(this.getSettings()).filter(scope => scope !== this.defaultScope);\n  }\n\n  /**\n   * @returns all settings in the given scope, merged with the settings for the default scope.\n   */\n  settingsFor(scope) {\n    return mergeDeep({}, this.ownSettingsFor(null), this.ownSettingsFor(scope));\n  }\n\n  /**\n   * @returns all settings in the given scope, *without* any of the default settings.\n   */\n  ownSettingsFor(scope) {\n    scope = this.#resolveScope(scope);\n    return this.getSettings()[scope] || {};\n  }\n  #resolveScope(scope) {\n    if (scope == null) {\n      return this.defaultScope;\n    } else {\n      return scope;\n    }\n  }\n}\nexport const bidderSettings = new ScopedSettings(() => getGlobal().bidderSettings || {}, JSON_MAPPING.BD_SETTING_STANDARD);\n//# sourceMappingURL=bidderSettings.js.map\n","import { getUniqueIdentifierStr } from './utils.js';\n\n/**\n * Bid metadata.\n */\n\n/**\n * Bid responses as provided by adapters; core then transforms these into `Bid`s\n */\n\n// <format>BidResponesProperties - adapter interpretResponse properties specific to the format.\n// they are included in both BidResponse and Bid types.\n// Here we have only \"naked\" declarations, extended in banner/video/native.ts as well as modules.\n\n// <format>BidProperties - format specific properties of Bid objects generated by Prebid, but not in\n// (or different from) adapter responses. Again,these are just naked declarations, extended in their place of\n// use.\n\n// the following adds `property?: undefined` declarations for each property\n// that is in some other format, to avoid requiring type casts\n// every time that property is used\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nfunction Bid() {\n  let {\n    src = 'client',\n    bidder = '',\n    bidId,\n    transactionId,\n    adUnitId,\n    auctionId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _bidSrc = src;\n  Object.assign(this, {\n    bidderCode: bidder,\n    width: 0,\n    height: 0,\n    adId: getUniqueIdentifierStr(),\n    requestId: bidId,\n    transactionId,\n    adUnitId,\n    auctionId,\n    mediaType: 'banner',\n    source: _bidSrc\n  });\n\n  // returns the size of the bid creative. Concatenation of width and height by x.\n  this.getSize = function () {\n    return this.width + 'x' + this.height;\n  };\n}\nexport function createBid(identifiers) {\n  return new Bid(identifiers);\n}\n//# sourceMappingURL=bidfactory.js.map\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-expect-error\n// eslint-disable-next-line prebid/validate-imports\nimport buildOptions from \"../buildOptions.mjs\"; // autogenerated during precompilation\n\nexport function getGlobalVarName() {\n  return buildOptions.pbGlobal;\n}\nexport function shouldDefineGlobal() {\n  return buildOptions.defineGlobal;\n}\nexport function getDistUrlBase() {\n  return buildOptions.distUrlBase;\n}\n//# sourceMappingURL=buildOptions.js.map\n","/*\n * Module for getting and setting Prebid configuration.\n*/\n\nimport { isValidPriceConfig } from './cpmBucketManager.js';\nimport { deepAccess, deepClone, getParameterByName, isArray, isBoolean, isPlainObject, isStr, logError, logMessage, logWarn, mergeDeep } from './utils.js';\nimport { DEBUG_MODE } from './constants.js';\nconst DEFAULT_DEBUG = getParameterByName(DEBUG_MODE).toUpperCase() === 'TRUE';\nconst DEFAULT_BIDDER_TIMEOUT = 3000;\nconst DEFAULT_ENABLE_SEND_ALL_BIDS = true;\nconst DEFAULT_DISABLE_AJAX_TIMEOUT = false;\nconst DEFAULT_BID_CACHE = false;\nconst DEFAULT_DEVICE_ACCESS = true;\nconst DEFAULT_MAX_NESTED_IFRAMES = 10;\nconst DEFAULT_MAXBID_VALUE = 5000;\nconst DEFAULT_IFRAMES_CONFIG = {};\nexport const RANDOM = 'random';\nconst FIXED = 'fixed';\nconst VALID_ORDERS = {};\nVALID_ORDERS[RANDOM] = true;\nVALID_ORDERS[FIXED] = true;\nconst DEFAULT_BIDDER_SEQUENCE = RANDOM;\nconst GRANULARITY_OPTIONS = {\n  LOW: 'low',\n  MEDIUM: 'medium',\n  HIGH: 'high',\n  AUTO: 'auto',\n  DENSE: 'dense',\n  CUSTOM: 'custom'\n};\nconst ALL_TOPICS = '*';\nfunction attachProperties(config) {\n  let useDefaultValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const values = useDefaultValues ? {\n    priceGranularity: GRANULARITY_OPTIONS.MEDIUM,\n    customPriceBucket: {},\n    mediaTypePriceGranularity: {},\n    bidderSequence: DEFAULT_BIDDER_SEQUENCE,\n    auctionOptions: {}\n  } : {};\n  function getProp(name) {\n    return values[name];\n  }\n  function setProp(name, val) {\n    if (!values.hasOwnProperty(name)) {\n      Object.defineProperty(config, name, {\n        enumerable: true\n      });\n    }\n    values[name] = val;\n  }\n  const props = {\n    publisherDomain: {\n      set(val) {\n        if (val != null) {\n          logWarn('publisherDomain is deprecated and has no effect since v7 - use pageUrl instead');\n        }\n        setProp('publisherDomain', val);\n      }\n    },\n    priceGranularity: {\n      set(val) {\n        if (validatePriceGranularity(val)) {\n          if (typeof val === 'string') {\n            setProp('priceGranularity', hasGranularity(val) ? val : GRANULARITY_OPTIONS.MEDIUM);\n          } else if (isPlainObject(val)) {\n            setProp('customPriceBucket', val);\n            setProp('priceGranularity', GRANULARITY_OPTIONS.CUSTOM);\n            logMessage('Using custom price granularity');\n          }\n        }\n      }\n    },\n    customPriceBucket: {},\n    mediaTypePriceGranularity: {\n      set(val) {\n        val != null && setProp('mediaTypePriceGranularity', Object.keys(val).reduce((aggregate, item) => {\n          if (validatePriceGranularity(val[item])) {\n            if (typeof val === 'string') {\n              aggregate[item] = hasGranularity(val[item]) ? val[item] : getProp('priceGranularity');\n            } else if (isPlainObject(val)) {\n              aggregate[item] = val[item];\n              logMessage(`Using custom price granularity for ${item}`);\n            }\n          } else {\n            logWarn(`Invalid price granularity for media type: ${item}`);\n          }\n          return aggregate;\n        }, {}));\n      }\n    },\n    bidderSequence: {\n      set(val) {\n        if (VALID_ORDERS[val]) {\n          setProp('bidderSequence', val);\n        } else {\n          logWarn(`Invalid order: ${val}. Bidder Sequence was not set.`);\n        }\n      }\n    },\n    auctionOptions: {\n      set(val) {\n        if (validateauctionOptions(val)) {\n          setProp('auctionOptions', val);\n        }\n      }\n    }\n  };\n  Object.defineProperties(config, Object.fromEntries(Object.entries(props).map(_ref => {\n    let [k, def] = _ref;\n    return [k, Object.assign({\n      get: getProp.bind(null, k),\n      set: setProp.bind(null, k),\n      enumerable: values.hasOwnProperty(k),\n      configurable: !values.hasOwnProperty(k)\n    }, def)];\n  })));\n  return config;\n  function hasGranularity(val) {\n    return Object.keys(GRANULARITY_OPTIONS).find(option => val === GRANULARITY_OPTIONS[option]);\n  }\n  function validatePriceGranularity(val) {\n    if (!val) {\n      logError('Prebid Error: no value passed to `setPriceGranularity()`');\n      return false;\n    }\n    if (typeof val === 'string') {\n      if (!hasGranularity(val)) {\n        logWarn('Prebid Warning: setPriceGranularity was called with invalid setting, using `medium` as default.');\n      }\n    } else if (isPlainObject(val)) {\n      if (!isValidPriceConfig(val)) {\n        logError('Invalid custom price value passed to `setPriceGranularity()`');\n        return false;\n      }\n    }\n    return true;\n  }\n  function validateauctionOptions(val) {\n    if (!isPlainObject(val)) {\n      logWarn('Auction Options must be an object');\n      return false;\n    }\n    for (const k of Object.keys(val)) {\n      if (k !== 'secondaryBidders' && k !== 'suppressStaleRender' && k !== 'suppressExpiredRender') {\n        logWarn(`Auction Options given an incorrect param: ${k}`);\n        return false;\n      }\n      if (k === 'secondaryBidders') {\n        if (!isArray(val[k])) {\n          logWarn(`Auction Options ${k} must be of type Array`);\n          return false;\n        } else if (!val[k].every(isStr)) {\n          logWarn(`Auction Options ${k} must be only string`);\n          return false;\n        }\n      } else if (k === 'suppressStaleRender' || k === 'suppressExpiredRender') {\n        if (!isBoolean(val[k])) {\n          logWarn(`Auction Options ${k} must be of type boolean`);\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\nexport function newConfig() {\n  const listeners = [];\n  let defaults;\n  let config;\n  let bidderConfig;\n  let currBidder = null;\n  function resetConfig() {\n    defaults = {};\n    const newConfig = attachProperties({\n      // `debug` is equivalent to legacy `pbjs.logging` property\n      debug: DEFAULT_DEBUG,\n      bidderTimeout: DEFAULT_BIDDER_TIMEOUT,\n      enableSendAllBids: DEFAULT_ENABLE_SEND_ALL_BIDS,\n      useBidCache: DEFAULT_BID_CACHE,\n      /**\n       * deviceAccess set to false will disable setCookie, getCookie, hasLocalStorage\n       * @type {boolean}\n       */\n      deviceAccess: DEFAULT_DEVICE_ACCESS,\n      disableAjaxTimeout: DEFAULT_DISABLE_AJAX_TIMEOUT,\n      // default max nested iframes for referer detection\n      maxNestedIframes: DEFAULT_MAX_NESTED_IFRAMES,\n      // default max bid\n      maxBid: DEFAULT_MAXBID_VALUE,\n      userSync: {\n        topics: DEFAULT_IFRAMES_CONFIG\n      }\n    });\n    if (config) {\n      callSubscribers(Object.keys(config).reduce((memo, topic) => {\n        if (config[topic] !== newConfig[topic]) {\n          memo[topic] = newConfig[topic] || {};\n        }\n        return memo;\n      }, {}));\n    }\n    config = newConfig;\n    bidderConfig = {};\n  }\n\n  /**\n   * Returns base config with bidder overrides (if there is currently a bidder)\n   * @private\n   */\n  function _getConfig() {\n    if (currBidder && bidderConfig && isPlainObject(bidderConfig[currBidder])) {\n      const curr = bidderConfig[currBidder];\n      const topics = new Set([...Object.keys(config), ...Object.keys(curr)]);\n      const merged = {};\n      for (const topic of topics) {\n        const base = config[topic];\n        const override = curr[topic];\n        merged[topic] = override === undefined ? base : base === undefined ? override : isPlainObject(override) ? mergeDeep({}, base, override) : override;\n      }\n      return merged;\n    }\n    return {\n      ...config\n    };\n  }\n  function _getRestrictedConfig() {\n    // This causes reading 'ortb2' to throw an error; with prebid 7, that will almost\n    // always be the incorrect way to access FPD configuration (https://github.com/prebid/Prebid.js/issues/7651)\n    // code that needs the ortb2 config should explicitly use `getAnyConfig`\n    // TODO: this is meant as a temporary tripwire to catch inadvertent use of `getConfig('ortb')` as we transition.\n    // It should be removed once the risk of that happening is low enough.\n    const conf = _getConfig();\n    Object.defineProperty(conf, 'ortb2', {\n      get: function () {\n        throw new Error('invalid access to \\'orbt2\\' config - use request parameters instead');\n      }\n    });\n    return conf;\n  }\n  const [getAnyConfig, getConfig] = [_getConfig, _getRestrictedConfig].map(accessor => {\n    /*\n     * Returns configuration object if called without parameters,\n     * or single configuration property if given a string matching a configuration\n     * property name.  Allows deep access e.g. getConfig('currency.adServerCurrency')\n     *\n     * If called with callback parameter, or a string and a callback parameter,\n     * subscribes to configuration updates. See `subscribe` function for usage.\n     */\n    return function getConfig() {\n      if (arguments.length <= 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) !== 'function') {\n        const option = arguments.length <= 0 ? undefined : arguments[0];\n        return option ? deepAccess(accessor(), option) : _getConfig();\n      }\n      return subscribe(...arguments);\n    };\n  });\n  const [readConfig, readAnyConfig] = [getConfig, getAnyConfig].map(wrapee => {\n    /*\n     * Like getConfig, except that it returns a deepClone of the result.\n     */\n    return function readConfig() {\n      let res = wrapee(...arguments);\n      if (res && typeof res === 'object') {\n        res = deepClone(res);\n      }\n      return res;\n    };\n  });\n\n  /**\n   * Internal API for modules (such as prebid-server) that might need access to all bidder config\n   */\n  function getBidderConfig() {\n    return bidderConfig;\n  }\n\n  /*\n   * Set configuration.\n   */\n  function setConfig(options) {\n    if (!isPlainObject(options)) {\n      logError('setConfig options must be an object');\n      return;\n    }\n    const topics = Object.keys(options);\n    const topicalConfig = {};\n    topics.forEach(topic => {\n      let option = options[topic];\n      if (isPlainObject(defaults[topic]) && isPlainObject(option)) {\n        option = Object.assign({}, defaults[topic], option);\n      }\n      try {\n        topicalConfig[topic] = config[topic] = option;\n      } catch (e) {\n        logWarn(`Cannot set config for property ${topic} : `, e);\n      }\n    });\n    callSubscribers(topicalConfig);\n  }\n\n  /**\n   * Sets configuration defaults which setConfig values can be applied on top of\n   * @param {object} options\n   */\n  function setDefaults(options) {\n    if (!isPlainObject(defaults)) {\n      logError('defaults must be an object');\n      return;\n    }\n    Object.assign(defaults, options);\n    // Add default values to config as well\n    Object.assign(config, options);\n  }\n\n  /*\n   * Adds a function to a set of listeners that are invoked whenever `setConfig`\n   * is called. The subscribed function will be passed the options object that\n   * was used in the `setConfig` call. Topics can be subscribed to to only get\n   * updates when specific properties are updated by passing a topic string as\n   * the first parameter.\n   *\n   * If `options.init` is true, the listener will be immediately called with the current options.\n   *\n   * Returns an `unsubscribe` function for removing the subscriber from the\n   * set of listeners\n   *\n   * Example use:\n   * // subscribe to all configuration changes\n   * subscribe((config) => console.log('config set:', config));\n   *\n   * // subscribe to only 'logging' changes\n   * subscribe('logging', (config) => console.log('logging set:', config));\n   *\n   * // unsubscribe\n   * const unsubscribe = subscribe(...);\n   * unsubscribe(); // no longer listening\n   *\n   */\n\n  function subscribe(topic, listener) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let callback = listener;\n    if (typeof topic !== 'string') {\n      // first param should be callback function in this case,\n      // meaning it gets called for any config change\n      callback = topic;\n      topic = ALL_TOPICS;\n      options = listener || {};\n    }\n    if (typeof callback !== 'function') {\n      logError('listener must be a function');\n      return;\n    }\n    const nl = {\n      topic,\n      callback\n    };\n    listeners.push(nl);\n    if (options.init) {\n      if (topic === ALL_TOPICS) {\n        callback(getConfig());\n      } else {\n        callback({\n          [topic]: getConfig(topic)\n        });\n      }\n    }\n\n    // save and call this function to remove the listener\n    return function unsubscribe() {\n      listeners.splice(listeners.indexOf(nl), 1);\n    };\n  }\n\n  /*\n   * Calls listeners that were added by the `subscribe` function\n   */\n  function callSubscribers(options) {\n    const TOPICS = Object.keys(options);\n\n    // call subscribers of a specific topic, passing only that configuration\n    listeners.filter(listener => TOPICS.includes(listener.topic)).forEach(listener => {\n      listener.callback({\n        [listener.topic]: options[listener.topic]\n      });\n    });\n\n    // call subscribers that didn't give a topic, passing everything that was set\n    listeners.filter(listener => listener.topic === ALL_TOPICS).forEach(listener => listener.callback(options));\n  }\n  function setBidderConfig(config) {\n    let mergeFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    try {\n      check(config);\n      config.bidders.forEach(bidder => {\n        if (!bidderConfig[bidder]) {\n          bidderConfig[bidder] = attachProperties({}, false);\n        }\n        Object.keys(config.config).forEach(topic => {\n          const option = config.config[topic];\n          const currentConfig = bidderConfig[bidder][topic];\n          if (isPlainObject(option) && (currentConfig == null || isPlainObject(currentConfig))) {\n            const func = mergeFlag ? mergeDeep : Object.assign;\n            bidderConfig[bidder][topic] = func({}, currentConfig || {}, option);\n          } else {\n            bidderConfig[bidder][topic] = option;\n          }\n        });\n      });\n    } catch (e) {\n      logError(e);\n    }\n    function check(obj) {\n      if (!isPlainObject(obj)) {\n        throw new Error('setBidderConfig bidder options must be an object');\n      }\n      if (!(Array.isArray(obj.bidders) && obj.bidders.length)) {\n        throw new Error('setBidderConfig bidder options must contain a bidders list with at least 1 bidder');\n      }\n      if (!isPlainObject(obj.config)) {\n        throw new Error('setBidderConfig bidder options must contain a config object');\n      }\n    }\n  }\n  function mergeConfig(config) {\n    if (!isPlainObject(config)) {\n      logError('mergeConfig input must be an object');\n      return;\n    }\n    const mergedConfig = mergeDeep(_getConfig(), config);\n    setConfig({\n      ...mergedConfig\n    });\n    return mergedConfig;\n  }\n  function mergeBidderConfig(config) {\n    return setBidderConfig(config, true);\n  }\n\n  /**\n   * Internal functions for core to execute some synchronous code while having an active bidder set.\n   */\n  function runWithBidder(bidder, fn) {\n    currBidder = bidder;\n    try {\n      return fn();\n    } finally {\n      resetBidder();\n    }\n  }\n  function callbackWithBidder(bidder) {\n    return function (cb) {\n      return function () {\n        if (typeof cb === 'function') {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          return runWithBidder(bidder, cb.bind(this, ...args));\n        } else {\n          logWarn('config.callbackWithBidder callback is not a function');\n        }\n      };\n    };\n  }\n  function getCurrentBidder() {\n    return currBidder;\n  }\n  function resetBidder() {\n    currBidder = null;\n  }\n  resetConfig();\n  return {\n    getCurrentBidder,\n    resetBidder,\n    getConfig,\n    getAnyConfig,\n    readConfig,\n    readAnyConfig,\n    setConfig,\n    mergeConfig,\n    setDefaults,\n    resetConfig,\n    runWithBidder,\n    callbackWithBidder,\n    setBidderConfig,\n    getBidderConfig,\n    mergeBidderConfig\n  };\n}\n\n/**\n * Set a `cache.url` if we should use prebid-cache to store video bids before adding bids to the auction.\n * This must be set if you want to use the gamAdServerVideo module.\n */\nexport const config = newConfig();\n//# sourceMappingURL=config.js.map\n","import { cyrb53Hash, isStr, timestamp } from './utils.js';\nimport { defer, PbPromise } from './utils/promise.js';\nimport { config } from './config.js';\n/**\n * Placeholder gvlid for when vendor consent is not required. When this value is used as gvlid, the gdpr\n * enforcement module will take it to mean \"vendor consent was given\".\n *\n * see https://github.com/prebid/Prebid.js/issues/8161\n */\nexport const VENDORLESS_GVLID = Object.freeze({});\nexport const CONSENT_GDPR = 'gdpr';\nexport const CONSENT_GPP = 'gpp';\nexport const CONSENT_USP = 'usp';\nexport const CONSENT_COPPA = 'coppa';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\nexport class ConsentHandler {\n  #enabled;\n  #data;\n  #defer;\n  #ready;\n  #dirty = true;\n  #hash;\n  constructor() {\n    this.reset();\n  }\n  #resolve(data) {\n    this.#ready = true;\n    this.#data = data;\n    this.#defer.resolve(data);\n  }\n\n  /**\n   * reset this handler (mainly for tests)\n   */\n  reset() {\n    this.#defer = defer();\n    this.#enabled = false;\n    this.#data = null;\n    this.#ready = false;\n    this.generatedTime = null;\n  }\n\n  /**\n   * Enable this consent handler. This should be called by the relevant consent management module\n   * on initialization.\n   */\n  enable() {\n    this.#enabled = true;\n  }\n\n  /**\n   * @returns {boolean} true if the related consent management module is enabled.\n   */\n  get enabled() {\n    return this.#enabled;\n  }\n\n  /**\n   * @returns {boolean} true if consent data has been resolved (it may be `null` if the resolution failed).\n   */\n  get ready() {\n    return this.#ready;\n  }\n\n  /**\n   * @returns a promise than resolves to the consent data, or null if no consent data is available\n   */\n  get promise() {\n    if (this.#ready) {\n      return PbPromise.resolve(this.#data);\n    }\n    if (!this.#enabled) {\n      this.#resolve(null);\n    }\n    return this.#defer.promise;\n  }\n  setConsentData(data) {\n    let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : timestamp();\n    this.generatedTime = time;\n    this.#dirty = true;\n    this.#resolve(data);\n  }\n  getConsentData() {\n    return this.#data;\n  }\n  get hash() {\n    if (this.#dirty) {\n      this.#hash = cyrb53Hash(JSON.stringify(this.#data && this.hashFields ? this.hashFields.map(f => this.#data[f]) : this.#data));\n      this.#dirty = false;\n    }\n    return this.#hash;\n  }\n}\nclass UspConsentHandler extends ConsentHandler {\n  getConsentMeta() {\n    const consentData = this.getConsentData();\n    if (consentData && this.generatedTime) {\n      return {\n        generatedAt: this.generatedTime\n      };\n    }\n  }\n}\nclass GdprConsentHandler extends ConsentHandler {\n  hashFields = ['gdprApplies', 'consentString'];\n  getConsentMeta() {\n    const consentData = this.getConsentData();\n    if (consentData && consentData.vendorData && this.generatedTime) {\n      return {\n        gdprApplies: consentData.gdprApplies,\n        consentStringSize: isStr(consentData.vendorData.tcString) ? consentData.vendorData.tcString.length : 0,\n        generatedAt: this.generatedTime,\n        apiVersion: consentData.apiVersion\n      };\n    }\n  }\n}\nclass GppConsentHandler extends ConsentHandler {\n  hashFields = ['applicableSections', 'gppString'];\n  getConsentMeta() {\n    const consentData = this.getConsentData();\n    if (consentData && this.generatedTime) {\n      return {\n        generatedAt: this.generatedTime\n      };\n    }\n  }\n}\nexport function gvlidRegistry() {\n  const registry = {};\n  const flat = {};\n  const none = {};\n  return {\n    /**\n     * Register a module's GVL ID.\n     * @param moduleType defined in `activities/modules.js`\n     * @param moduleName\n     * @param gvlid\n     */\n    register(moduleType, moduleName, gvlid) {\n      if (gvlid) {\n        (registry[moduleName] = registry[moduleName] || {})[moduleType] = gvlid;\n        if (flat.hasOwnProperty(moduleName)) {\n          if (flat[moduleName] !== gvlid) flat[moduleName] = none;\n        } else {\n          flat[moduleName] = gvlid;\n        }\n      }\n    },\n    /**\n     * Get a module's GVL ID(s).\n     *\n     * @param moduleName - The name of the module.\n     * @return An object where:\n     *   `modules` is a map from module type to that module's GVL ID;\n     *   `gvlid` is the single GVL ID for this family of modules (only defined if all modules with this name declare the same ID).\n     */\n    get(moduleName) {\n      const result = {\n        modules: registry[moduleName] || {}\n      };\n      if (flat.hasOwnProperty(moduleName) && flat[moduleName] !== none) {\n        result.gvlid = flat[moduleName];\n      }\n      return result;\n    }\n  };\n}\nexport const gdprDataHandler = new GdprConsentHandler();\nexport const uspDataHandler = new UspConsentHandler();\nexport const gppDataHandler = new GppConsentHandler();\nexport const coppaDataHandler = (() => {\n  function getCoppa() {\n    return !!config.getConfig('coppa');\n  }\n  return {\n    getCoppa,\n    getConsentData: getCoppa,\n    getConsentMeta: getCoppa,\n    reset() {},\n    get promise() {\n      return PbPromise.resolve(getCoppa());\n    },\n    get hash() {\n      return getCoppa() ? '1' : '0';\n    }\n  };\n})();\nexport const GDPR_GVLIDS = gvlidRegistry();\nconst ALL_HANDLERS = {\n  [CONSENT_GDPR]: gdprDataHandler,\n  [CONSENT_USP]: uspDataHandler,\n  [CONSENT_GPP]: gppDataHandler,\n  [CONSENT_COPPA]: coppaDataHandler\n};\nexport function multiHandler() {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ALL_HANDLERS;\n  const entries = Object.entries(handlers);\n  function collector(method) {\n    return function () {\n      return Object.fromEntries(entries.map(_ref => {\n        let [name, handler] = _ref;\n        return [name, handler[method]()];\n      }));\n    };\n  }\n  return Object.assign({\n    get promise() {\n      return PbPromise.all(entries.map(_ref2 => {\n        let [name, handler] = _ref2;\n        return handler.promise.then(val => [name, val]);\n      })).then(entries => Object.fromEntries(entries));\n    },\n    get hash() {\n      return cyrb53Hash(entries.map(_ref3 => {\n        let [_, handler] = _ref3;\n        return handler.hash;\n      }).join(':'));\n    }\n  }, Object.fromEntries(['getConsentData', 'getConsentMeta', 'reset'].map(n => [n, collector(n)])));\n}\nexport const allConsent = multiHandler();\n//# sourceMappingURL=consentHandler.js.map\n","export const JSON_MAPPING = {\n  PL_CODE: 'code',\n  PL_SIZE: 'sizes',\n  PL_BIDS: 'bids',\n  BD_BIDDER: 'bidder',\n  BD_ID: 'paramsd',\n  BD_PL_ID: 'placementId',\n  ADSERVER_TARGETING: 'adserverTargeting',\n  BD_SETTING_STANDARD: 'standard'\n};\nexport const DEBUG_MODE = 'pbjs_debug';\nexport const STATUS = {\n  GOOD: 1\n};\nexport const EVENTS = {\n  AUCTION_INIT: 'auctionInit',\n  AUCTION_TIMEOUT: 'auctionTimeout',\n  AUCTION_END: 'auctionEnd',\n  BID_ADJUSTMENT: 'bidAdjustment',\n  BID_TIMEOUT: 'bidTimeout',\n  BID_REQUESTED: 'bidRequested',\n  BID_RESPONSE: 'bidResponse',\n  BID_REJECTED: 'bidRejected',\n  NO_BID: 'noBid',\n  SEAT_NON_BID: 'seatNonBid',\n  BID_WON: 'bidWon',\n  BIDDER_DONE: 'bidderDone',\n  BIDDER_ERROR: 'bidderError',\n  SET_TARGETING: 'setTargeting',\n  BEFORE_REQUEST_BIDS: 'beforeRequestBids',\n  BEFORE_BIDDER_HTTP: 'beforeBidderHttp',\n  REQUEST_BIDS: 'requestBids',\n  ADD_AD_UNITS: 'addAdUnits',\n  AD_RENDER_FAILED: 'adRenderFailed',\n  AD_RENDER_SUCCEEDED: 'adRenderSucceeded',\n  TCF2_ENFORCEMENT: 'tcf2Enforcement',\n  AUCTION_DEBUG: 'auctionDebug',\n  BID_VIEWABLE: 'bidViewable',\n  STALE_RENDER: 'staleRender',\n  EXPIRED_RENDER: 'expiredRender',\n  BILLABLE_EVENT: 'billableEvent',\n  BID_ACCEPTED: 'bidAccepted',\n  RUN_PAAPI_AUCTION: 'paapiRunAuction',\n  PBS_ANALYTICS: 'pbsAnalytics',\n  PAAPI_BID: 'paapiBid',\n  PAAPI_NO_BID: 'paapiNoBid',\n  PAAPI_ERROR: 'paapiError',\n  BEFORE_PBS_HTTP: 'beforePBSHttp',\n  BROWSI_INIT: 'browsiInit',\n  BROWSI_DATA: 'browsiData'\n};\nexport const AD_RENDER_FAILED_REASON = {\n  PREVENT_WRITING_ON_MAIN_DOCUMENT: 'preventWritingOnMainDocument',\n  NO_AD: 'noAd',\n  EXCEPTION: 'exception',\n  CANNOT_FIND_AD: 'cannotFindAd',\n  MISSING_DOC_OR_ADID: 'missingDocOrAdid'\n};\nexport const EVENT_ID_PATHS = {\n  bidWon: 'adUnitCode'\n};\nexport const GRANULARITY_OPTIONS = {\n  LOW: 'low',\n  MEDIUM: 'medium',\n  HIGH: 'high',\n  AUTO: 'auto',\n  DENSE: 'dense',\n  CUSTOM: 'custom'\n};\nexport const TARGETING_KEYS = {\n  BIDDER: 'hb_bidder',\n  AD_ID: 'hb_adid',\n  PRICE_BUCKET: 'hb_pb',\n  SIZE: 'hb_size',\n  DEAL: 'hb_deal',\n  SOURCE: 'hb_source',\n  FORMAT: 'hb_format',\n  UUID: 'hb_uuid',\n  CACHE_ID: 'hb_cache_id',\n  CACHE_HOST: 'hb_cache_host',\n  ADOMAIN: 'hb_adomain',\n  ACAT: 'hb_acat',\n  CRID: 'hb_crid',\n  DSP: 'hb_dsp'\n};\nexport const DEFAULT_TARGETING_KEYS = {\n  BIDDER: 'hb_bidder',\n  AD_ID: 'hb_adid',\n  PRICE_BUCKET: 'hb_pb',\n  SIZE: 'hb_size',\n  DEAL: 'hb_deal',\n  FORMAT: 'hb_format',\n  UUID: 'hb_uuid',\n  CACHE_HOST: 'hb_cache_host'\n};\nexport const NATIVE_KEYS = {\n  title: 'hb_native_title',\n  body: 'hb_native_body',\n  body2: 'hb_native_body2',\n  privacyLink: 'hb_native_privacy',\n  privacyIcon: 'hb_native_privicon',\n  sponsoredBy: 'hb_native_brand',\n  image: 'hb_native_image',\n  icon: 'hb_native_icon',\n  clickUrl: 'hb_native_linkurl',\n  displayUrl: 'hb_native_displayurl',\n  cta: 'hb_native_cta',\n  rating: 'hb_native_rating',\n  address: 'hb_native_address',\n  downloads: 'hb_native_downloads',\n  likes: 'hb_native_likes',\n  phone: 'hb_native_phone',\n  price: 'hb_native_price',\n  salePrice: 'hb_native_saleprice',\n  rendererUrl: 'hb_renderer_url',\n  adTemplate: 'hb_adTemplate'\n};\nexport const S2S = {\n  SRC: 's2s',\n  DEFAULT_ENDPOINT: 'https://prebid.adnxs.com/pbs/v1/openrtb2/auction',\n  SYNCED_BIDDERS_KEY: 'pbjsSyncs'\n};\nexport const BID_STATUS = {\n  BID_TARGETING_SET: 'targetingSet',\n  RENDERED: 'rendered',\n  BID_REJECTED: 'bidRejected'\n};\nexport const REJECTION_REASON = {\n  INVALID: 'Bid has missing or invalid properties',\n  INVALID_REQUEST_ID: 'Invalid request ID',\n  BIDDER_DISALLOWED: 'Bidder code is not allowed by allowedAlternateBidderCodes / allowUnknownBidderCodes',\n  FLOOR_NOT_MET: 'Bid does not meet price floor',\n  CANNOT_CONVERT_CURRENCY: 'Unable to convert currency',\n  DSA_REQUIRED: 'Bid does not provide required DSA transparency info',\n  DSA_MISMATCH: 'Bid indicates inappropriate DSA rendering method',\n  PRICE_TOO_HIGH: 'Bid price exceeds maximum value'\n};\nexport const PREBID_NATIVE_DATA_KEYS_TO_ORTB = {\n  body: 'desc',\n  body2: 'desc2',\n  sponsoredBy: 'sponsored',\n  cta: 'ctatext',\n  rating: 'rating',\n  address: 'address',\n  downloads: 'downloads',\n  likes: 'likes',\n  phone: 'phone',\n  price: 'price',\n  salePrice: 'saleprice',\n  displayUrl: 'displayurl'\n};\nexport const NATIVE_ASSET_TYPES = {\n  sponsored: 1,\n  desc: 2,\n  rating: 3,\n  likes: 4,\n  downloads: 5,\n  price: 6,\n  saleprice: 7,\n  phone: 8,\n  address: 9,\n  desc2: 10,\n  displayurl: 11,\n  ctatext: 12\n};\nexport const NATIVE_IMAGE_TYPES = {\n  ICON: 1,\n  MAIN: 3\n};\nexport const NATIVE_KEYS_THAT_ARE_NOT_ASSETS = ['privacyIcon', 'clickUrl', 'adTemplate', 'rendererUrl', 'type'];\nexport const MESSAGES = {\n  REQUEST: 'Prebid Request',\n  RESPONSE: 'Prebid Response',\n  NATIVE: 'Prebid Native',\n  EVENT: 'Prebid Event'\n};\nexport const PB_LOCATOR = '__pb_locator__';\n//# sourceMappingURL=constants.js.map\n","import { isEmpty, logWarn } from './utils.js';\nimport { config } from './config.js';\nconst _defaultPrecision = 2;\nconst _lgPriceConfig = {\n  'buckets': [{\n    'max': 5,\n    'increment': 0.5\n  }]\n};\nconst _mgPriceConfig = {\n  'buckets': [{\n    'max': 20,\n    'increment': 0.1\n  }]\n};\nconst _hgPriceConfig = {\n  'buckets': [{\n    'max': 20,\n    'increment': 0.01\n  }]\n};\nconst _densePriceConfig = {\n  'buckets': [{\n    'max': 3,\n    'increment': 0.01\n  }, {\n    'max': 8,\n    'increment': 0.05\n  }, {\n    'max': 20,\n    'increment': 0.5\n  }]\n};\nconst _autoPriceConfig = {\n  'buckets': [{\n    'max': 5,\n    'increment': 0.05\n  }, {\n    'max': 10,\n    'increment': 0.1\n  }, {\n    'max': 20,\n    'increment': 0.5\n  }]\n};\nfunction getPriceBucketString(cpm, customConfig) {\n  let granularityMultiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let cpmFloat = parseFloat(cpm);\n  if (isNaN(cpmFloat)) {\n    cpmFloat = '';\n  }\n  return {\n    low: cpmFloat === '' ? '' : getCpmStringValue(cpm, _lgPriceConfig, granularityMultiplier),\n    med: cpmFloat === '' ? '' : getCpmStringValue(cpm, _mgPriceConfig, granularityMultiplier),\n    high: cpmFloat === '' ? '' : getCpmStringValue(cpm, _hgPriceConfig, granularityMultiplier),\n    auto: cpmFloat === '' ? '' : getCpmStringValue(cpm, _autoPriceConfig, granularityMultiplier),\n    dense: cpmFloat === '' ? '' : getCpmStringValue(cpm, _densePriceConfig, granularityMultiplier),\n    custom: cpmFloat === '' ? '' : getCpmStringValue(cpm, customConfig, granularityMultiplier)\n  };\n}\nfunction getCpmStringValue(cpm, config, granularityMultiplier) {\n  let cpmStr = '';\n  if (!isValidPriceConfig(config)) {\n    return cpmStr;\n  }\n  const cap = config.buckets.reduce((prev, curr) => {\n    if (prev.max > curr.max) {\n      return prev;\n    }\n    return curr;\n  }, {\n    'max': 0\n  });\n  let bucketFloor = 0;\n  const bucket = config.buckets.find(bucket => {\n    if (cpm > cap.max * granularityMultiplier) {\n      // cpm exceeds cap, just return the cap.\n      let precision = bucket.precision;\n      if (typeof precision === 'undefined') {\n        precision = _defaultPrecision;\n      }\n      cpmStr = (bucket.max * granularityMultiplier).toFixed(precision);\n    } else if (cpm <= bucket.max * granularityMultiplier && cpm >= bucketFloor * granularityMultiplier) {\n      bucket.min = bucketFloor;\n      return bucket;\n    } else {\n      bucketFloor = bucket.max;\n    }\n  });\n  if (bucket) {\n    cpmStr = getCpmTarget(cpm, bucket, granularityMultiplier);\n  }\n  return cpmStr;\n}\nfunction isValidPriceConfig(config) {\n  if (isEmpty(config) || !config.buckets || !Array.isArray(config.buckets)) {\n    return false;\n  }\n  let isValid = true;\n  config.buckets.forEach(bucket => {\n    if (!bucket.max || !bucket.increment) {\n      isValid = false;\n    }\n  });\n  return isValid;\n}\nfunction getCpmTarget(cpm, bucket, granularityMultiplier) {\n  const precision = typeof bucket.precision !== 'undefined' ? bucket.precision : _defaultPrecision;\n  const increment = bucket.increment * granularityMultiplier;\n  const bucketMin = bucket.min * granularityMultiplier;\n  let roundingFunction = Math.floor;\n  const customRoundingFunction = config.getConfig('cpmRoundingFunction');\n  if (typeof customRoundingFunction === 'function') {\n    roundingFunction = customRoundingFunction;\n  }\n\n  // start increments at the bucket min and then add bucket min back to arrive at the correct rounding\n  // note - we're padding the values to avoid using decimals in the math prior to flooring\n  // this is done as JS can return values slightly below the expected mark which would skew the price bucket target\n  //   (eg 4.01 / 0.01 = 400.99999999999994)\n  // min precison should be 2 to move decimal place over.\n  const pow = Math.pow(10, precision + 2);\n  const cpmToRound = (cpm * pow - bucketMin * pow) / (increment * pow);\n  let cpmTarget;\n  let invalidRounding;\n  // It is likely that we will be passed {cpmRoundingFunction: roundingFunction()}\n  // rather than the expected {cpmRoundingFunction: roundingFunction}. Default back to floor in that case\n  try {\n    cpmTarget = roundingFunction(cpmToRound) * increment + bucketMin;\n  } catch (err) {\n    invalidRounding = true;\n  }\n  if (invalidRounding || typeof cpmTarget !== 'number') {\n    logWarn('Invalid rounding function passed in config');\n    cpmTarget = Math.floor(cpmToRound) * increment + bucketMin;\n  }\n  // force to 10 decimal places to deal with imprecise decimal/binary conversions\n  //    (for example 0.1 * 3 = 0.30000000000000004)\n\n  cpmTarget = Number(cpmTarget.toFixed(10));\n  return cpmTarget.toFixed(precision);\n}\nexport { getPriceBucketString, isValidPriceConfig };\n//# sourceMappingURL=cpmBucketManager.js.map\n","import { PbPromise } from './utils/promise.js';\nimport { createInvisibleIframe } from './utils.js';\nimport { RENDERER } from '../libraries/creative-renderer-display/renderer.js';\nimport { hook } from './hook.js';\n\n// the minimum rendererVersion that will be used by PUC\nexport const PUC_MIN_VERSION = 3;\nexport const getCreativeRendererSource = hook('sync', function (bidResponse) {\n  return RENDERER;\n});\nexport const getCreativeRenderer = function () {\n  const renderers = {};\n  return function (bidResponse) {\n    const src = getCreativeRendererSource(bidResponse);\n    if (!renderers.hasOwnProperty(src)) {\n      renderers[src] = new PbPromise(resolve => {\n        const iframe = createInvisibleIframe();\n        iframe.srcdoc = `<script>${src}</script>`;\n        iframe.onload = () => resolve(iframe.contentWindow.render);\n        document.body.appendChild(iframe);\n      });\n    }\n    return renderers[src];\n  };\n}();\n//# sourceMappingURL=creativeRenderers.js.map\n","export const TRACKER_METHOD_IMG = 1;\nexport const TRACKER_METHOD_JS = 2;\nexport const EVENT_TYPE_IMPRESSION = 1;\nexport const EVENT_TYPE_WIN = 500;\n\n/**\n * Returns a map from event type (EVENT_TYPE_*)\n * to a map from tracker method (TRACKER_METHOD_*)\n * to an array of tracking URLs\n *\n * @param {{}[]} eventTrackers an array of \"Event Tracker Response Object\" as defined\n *  in the ORTB native 1.2 spec (https://www.iab.com/wp-content/uploads/2018/03/OpenRTB-Native-Ads-Specification-Final-1.2.pdf, section 5.8)\n * @returns {{[type: string]: {[method: string]: string[]}}}\n */\nexport function parseEventTrackers(eventTrackers) {\n  return (eventTrackers ?? []).reduce((tally, _ref) => {\n    let {\n      event,\n      method,\n      url\n    } = _ref;\n    const trackersForType = tally[event] = tally[event] ?? {};\n    const trackersForMethod = trackersForType[method] = trackersForType[method] ?? [];\n    trackersForMethod.push(url);\n    return tally;\n  }, {});\n}\n//# sourceMappingURL=eventTrackers.js.map\n","/**\n * events.js\n */\nimport * as utils from './utils.js';\nimport { EVENTS, EVENT_ID_PATHS } from './constants.js';\nimport { ttlCollection } from './utils/ttlCollection.js';\nimport { config } from './config.js';\n\n// hide video events (unless the video module is included) with this one weird trick\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\nconst TTL_CONFIG = 'eventHistoryTTL';\nlet eventTTL = null;\n\n// keep a record of all events fired\nconst eventsFired = ttlCollection({\n  monotonic: true,\n  ttl: () => eventTTL\n});\nconfig.getConfig(TTL_CONFIG, cfg => {\n  const previous = eventTTL;\n  const val = cfg?.[TTL_CONFIG];\n  eventTTL = typeof val === 'number' ? val * 1000 : null;\n  if (previous !== eventTTL) {\n    eventsFired.refresh();\n  }\n});\n\n// define entire events\nlet allEvents = Object.values(EVENTS);\nconst idPaths = EVENT_ID_PATHS;\nconst _public = function () {\n  const _handlers = {};\n  function _dispatch(eventName, args) {\n    utils.logMessage('Emitting event for: ' + eventName);\n    const eventPayload = args[0] || {};\n    const idPath = idPaths[eventName];\n    const key = eventPayload[idPath];\n    const event = _handlers[eventName] || {\n      que: []\n    };\n    var eventKeys = Object.keys(event);\n    const callbacks = [];\n\n    // record the event:\n    eventsFired.add({\n      eventType: eventName,\n      args: eventPayload,\n      id: key,\n      elapsedTime: utils.getPerformanceNow()\n    });\n\n    /**\n     * Push each specific callback to the `callbacks` array.\n     * If the `event` map has a key that matches the value of the\n     * event payload id path, e.g. `eventPayload[idPath]`, then apply\n     * each function in the `que` array as an argument to push to the\n     * `callbacks` array\n     */\n    if (key && eventKeys.includes(key)) {\n      callbacks.push(...event[key].que);\n    }\n\n    /** Push each general callback to the `callbacks` array. */\n    callbacks.push(...event.que);\n\n    /** call each of the callbacks */\n    (callbacks || []).forEach(function (fn) {\n      if (!fn) return;\n      try {\n        fn(...args);\n      } catch (e) {\n        utils.logError('Error executing handler:', 'events.js', e, eventName);\n      }\n    });\n  }\n  function _checkAvailableEvent(event) {\n    return allEvents.includes(event);\n  }\n  return {\n    has: _checkAvailableEvent,\n    on: function (eventName, handler, id) {\n      // check whether available event or not\n      if (_checkAvailableEvent(eventName)) {\n        const event = _handlers[eventName] || {\n          que: []\n        };\n        if (id) {\n          event[id] = event[id] || {\n            que: []\n          };\n          event[id].que.push(handler);\n        } else {\n          event.que.push(handler);\n        }\n        _handlers[eventName] = event;\n      } else {\n        utils.logError('Wrong event name : ' + eventName + ' Valid event names :' + allEvents);\n      }\n    },\n    emit: function (eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      _dispatch(eventName, args);\n    },\n    off: function (eventName, handler, id) {\n      const event = _handlers[eventName];\n      if (utils.isEmpty(event) || utils.isEmpty(event.que) && utils.isEmpty(event[id])) {\n        return;\n      }\n      if (id && (utils.isEmpty(event[id]) || utils.isEmpty(event[id].que))) {\n        return;\n      }\n      if (id) {\n        (event[id].que || []).forEach(function (_handler) {\n          const que = event[id].que;\n          if (_handler === handler) {\n            que.splice(que.indexOf(_handler), 1);\n          }\n        });\n      } else {\n        (event.que || []).forEach(function (_handler) {\n          const que = event.que;\n          if (_handler === handler) {\n            que.splice(que.indexOf(_handler), 1);\n          }\n        });\n      }\n      _handlers[eventName] = event;\n    },\n    get: function () {\n      return _handlers;\n    },\n    addEvents: function (events) {\n      allEvents = allEvents.concat(events);\n    },\n    /**\n     * Return a copy of all events fired\n     */\n    getEvents: function () {\n      return eventsFired.toArray().map(val => Object.assign({}, val));\n    }\n  };\n}();\nutils._setEventEmitter(_public.emit.bind(_public));\nexport const {\n  on,\n  off,\n  get,\n  getEvents,\n  emit,\n  addEvents,\n  has\n} = _public;\nexport function clearEvents() {\n  eventsFired.clear();\n}\n//# sourceMappingURL=events.js.map\n","import { logWarn } from '../utils.js';\n\n// mutually exclusive ORTB sections in order of priority - 'dooh' beats 'app' & 'site' and 'app' beats 'site';\n// if one is set, the others will be removed\nexport const CLIENT_SECTIONS = ['dooh', 'app', 'site'];\nexport function clientSectionChecker(logPrefix) {\n  return function onlyOneClientSection(ortb2) {\n    CLIENT_SECTIONS.reduce((found, section) => {\n      if (hasSection(ortb2, section)) {\n        if (found != null) {\n          logWarn(`${logPrefix} specifies both '${found}' and '${section}'; dropping the latter.`);\n          delete ortb2[section];\n        } else {\n          found = section;\n        }\n      }\n      return found;\n    }, null);\n    return ortb2;\n  };\n}\nexport function hasSection(ortb2, section) {\n  return ortb2[section] != null && Object.keys(ortb2[section]).length > 0;\n}\n//# sourceMappingURL=oneClient.js.map\n","import funHooks from 'fun-hooks/no-eval/index.js';\nimport { defer } from './utils/promise.js';\n/**\n * NOTE: you must not call `next` asynchronously from 'sync' hooks\n * see https://github.com/snapwich/fun-hooks/issues/42\n */\n\nexport const hook = funHooks({\n  ready: funHooks.SYNC | funHooks.ASYNC | funHooks.QUEUE\n});\nconst readyCtl = defer();\nhook.ready = (() => {\n  const ready = hook.ready;\n  return function () {\n    try {\n      return ready.apply(hook);\n    } finally {\n      readyCtl.resolve();\n    }\n  };\n})();\n\n/**\n * A promise that resolves when hooks are ready.\n * @type {Promise}\n */\nexport const ready = readyCtl.promise;\nexport const getHook = hook.get;\nexport function setupBeforeHookFnOnce(baseFn, hookFn) {\n  let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 15;\n  const result = baseFn.getHooks({\n    hook: hookFn\n  });\n  if (result.length === 0) {\n    baseFn.before(hookFn, priority);\n  }\n}\nconst submoduleInstallMap = {};\nexport function module(name, install) {\n  let {\n    postInstallAllowed = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  hook('async', function (submodules) {\n    submodules.forEach(args => install(...args));\n    if (postInstallAllowed) submoduleInstallMap[name] = install;\n  }, name)([]); // will be queued until hook.ready() called in pbjs.processQueue();\n}\nexport function submodule(name) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  const install = submoduleInstallMap[name];\n  if (install) return install(...args);\n  getHook(name).before((next, modules) => {\n    modules.push(args);\n    next(modules);\n  });\n}\n\n/**\n * Copy hook methods (.before, .after, etc) from a given hook to a given wrapper object.\n */\nexport function wrapHook(hook, wrapper) {\n  Object.defineProperties(wrapper, Object.fromEntries(['before', 'after', 'getHooks', 'removeAll'].map(m => [m, {\n    get: () => hook[m]\n  }])));\n  return wrapper;\n}\n\n/**\n * 'async' hooks expect the last argument to be a callback, and have special treatment for it if it's a function;\n * which prevents it from being used as a normal argument in 'before' hooks - and presents a modified version of it\n * to the hooked function.\n *\n * This returns a wrapper around a given 'async' hook that works around this, for when the last argument\n * should be treated as a normal argument.\n */\nexport function ignoreCallbackArg(hook) {\n  return wrapHook(hook, function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    args.push(function () {});\n    return hook.apply(this, args);\n  });\n}\n//# sourceMappingURL=hook.js.map\n","/**\n * This file contains the valid Media Types in Prebid.\n *\n * All adapters are assumed to support banner ads. Other media types are specified by Adapters when they\n * register themselves with prebid-core.\n */\n\nexport const NATIVE = 'native';\nexport const VIDEO = 'video';\nexport const BANNER = 'banner';\nexport const ADPOD = 'adpod';\nexport const AUDIO = 'audio';\nexport const ALL_MEDIATYPES = [NATIVE, VIDEO, BANNER, AUDIO];\n//# sourceMappingURL=mediaTypes.js.map\n","import { deepClone, getDefinedParams, insertHtmlIntoIframe, isArray, isBoolean, isInteger, isNumber, isPlainObject, logError, pick, triggerPixel } from './utils.js';\nimport { auctionManager } from './auctionManager.js';\nimport { NATIVE_ASSET_TYPES, NATIVE_IMAGE_TYPES, NATIVE_KEYS, NATIVE_KEYS_THAT_ARE_NOT_ASSETS, PREBID_NATIVE_DATA_KEYS_TO_ORTB } from './constants.js';\nimport { NATIVE } from './mediaTypes.js';\nimport { getRenderingData } from './adRendering.js';\nimport { getCreativeRendererSource, PUC_MIN_VERSION } from './creativeRenderers.js';\nimport { EVENT_TYPE_IMPRESSION, parseEventTrackers, TRACKER_METHOD_IMG, TRACKER_METHOD_JS } from './eventTrackers.js';\nexport const nativeAdapters = [];\nexport const IMAGE = {\n  ortb: {\n    ver: '1.2',\n    assets: [{\n      required: 1,\n      id: 1,\n      img: {\n        type: 3,\n        wmin: 100,\n        hmin: 100\n      }\n    }, {\n      required: 1,\n      id: 2,\n      title: {\n        len: 140\n      }\n    }, {\n      required: 1,\n      id: 3,\n      data: {\n        type: 1\n      }\n    }, {\n      required: 0,\n      id: 4,\n      data: {\n        type: 2\n      }\n    }, {\n      required: 0,\n      id: 5,\n      img: {\n        type: 1,\n        wmin: 20,\n        hmin: 20\n      }\n    }]\n  },\n  image: {\n    required: true\n  },\n  title: {\n    required: true\n  },\n  sponsoredBy: {\n    required: true\n  },\n  clickUrl: {\n    required: true\n  },\n  body: {\n    required: false\n  },\n  icon: {\n    required: false\n  }\n};\nconst SUPPORTED_TYPES = {\n  image: IMAGE\n};\n\n// inverse native maps useful for converting to legacy\nconst PREBID_NATIVE_DATA_KEYS_TO_ORTB_INVERSE = inverse(PREBID_NATIVE_DATA_KEYS_TO_ORTB);\nconst NATIVE_ASSET_TYPES_INVERSE = inverse(NATIVE_ASSET_TYPES);\nexport function isNativeResponse(bidResponse) {\n  // check for native data and not mediaType; it's possible\n  // to treat banner responses as native\n  return bidResponse.native != null && typeof bidResponse.native === 'object';\n}\n\n/**\n * Recieves nativeParams from an adUnit. If the params were not of type 'type',\n * passes them on directly. If they were of type 'type', translate\n * them into the predefined specific asset requests for that type of native ad.\n */\nexport function processNativeAdUnitParams(params) {\n  if (params && params.type && typeIsSupported(params.type)) {\n    params = SUPPORTED_TYPES[params.type];\n  }\n  if (params && params.ortb && !isOpenRTBBidRequestValid(params.ortb)) {\n    return;\n  }\n  return params;\n}\nexport function decorateAdUnitsWithNativeParams(adUnits) {\n  adUnits.forEach(adUnit => {\n    const nativeParams = adUnit.nativeParams || adUnit?.mediaTypes?.native;\n    if (nativeParams) {\n      adUnit.nativeParams = processNativeAdUnitParams(nativeParams);\n    }\n    if (adUnit.nativeParams) {\n      adUnit.nativeOrtbRequest = adUnit.nativeParams.ortb || toOrtbNativeRequest(adUnit.nativeParams);\n    }\n  });\n}\nexport function isOpenRTBBidRequestValid(ortb) {\n  const assets = ortb.assets;\n  if (!Array.isArray(assets) || assets.length === 0) {\n    logError(`assets in mediaTypes.native.ortb is not an array, or it's empty. Assets: `, assets);\n    return false;\n  }\n\n  // validate that ids exist, that they are unique and that they are numbers\n  const ids = assets.map(asset => asset.id);\n  if (assets.length !== new Set(ids).size || ids.some(id => id !== parseInt(id, 10))) {\n    logError(`each asset object must have 'id' property, it must be unique and it must be an integer`);\n    return false;\n  }\n  if (ortb.hasOwnProperty('eventtrackers') && !Array.isArray(ortb.eventtrackers)) {\n    logError('ortb.eventtrackers is not an array. Eventtrackers: ', ortb.eventtrackers);\n    return false;\n  }\n  return assets.every(asset => isOpenRTBAssetValid(asset));\n}\nfunction isOpenRTBAssetValid(asset) {\n  if (!isPlainObject(asset)) {\n    logError(`asset must be an object. Provided asset: `, asset);\n    return false;\n  }\n  if (asset.img) {\n    if (!isNumber(asset.img.w) && !isNumber(asset.img.wmin)) {\n      logError(`for img asset there must be 'w' or 'wmin' property`);\n      return false;\n    }\n    if (!isNumber(asset.img.h) && !isNumber(asset.img.hmin)) {\n      logError(`for img asset there must be 'h' or 'hmin' property`);\n      return false;\n    }\n  } else if (asset.title) {\n    if (!isNumber(asset.title.len)) {\n      logError(`for title asset there must be 'len' property defined`);\n      return false;\n    }\n  } else if (asset.data) {\n    if (!isNumber(asset.data.type)) {\n      logError(`for data asset 'type' property must be a number`);\n      return false;\n    }\n  } else if (asset.video) {\n    if (!Array.isArray(asset.video.mimes) || !Array.isArray(asset.video.protocols) || !isNumber(asset.video.minduration) || !isNumber(asset.video.maxduration)) {\n      logError('video asset is not properly configured');\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check if the native type specified in the adUnit is supported by Prebid.\n */\nfunction typeIsSupported(type) {\n  if (!(type && Object.keys(SUPPORTED_TYPES).includes(type))) {\n    logError(`${type} nativeParam is not supported`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Helper functions for working with native-enabled adUnits\n * TODO: abstract this and the video helper functions into general\n * adunit validation helper functions\n */\nexport const nativeAdUnit = adUnit => {\n  const mediaType = adUnit.mediaType === 'native';\n  const mediaTypes = adUnit?.mediaTypes?.native;\n  return mediaType || mediaTypes;\n};\nexport const nativeBidder = bid => nativeAdapters.includes(bid.bidder);\nexport const hasNonNativeBidder = adUnit => adUnit.bids.filter(bid => !nativeBidder(bid)).length;\n\n/**\n * Validate that the native assets on this bid contain all assets that were\n * marked as required in the adUnit configuration.\n * bid Native bid to validate\n * @return {Boolean} If object is valid\n */\nexport function nativeBidIsValid(bid) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const adUnit = index.getAdUnit(bid);\n  if (!adUnit) {\n    return false;\n  }\n  const ortbRequest = adUnit.nativeOrtbRequest;\n  const ortbResponse = bid.native?.ortb || toOrtbNativeResponse(bid.native, ortbRequest);\n  return isNativeOpenRTBBidValid(ortbResponse, ortbRequest);\n}\nexport function isNativeOpenRTBBidValid(bidORTB, bidRequestORTB) {\n  if (!bidORTB?.link?.url) {\n    logError(`native response doesn't have 'link' property. Ortb response: `, bidORTB);\n    return false;\n  }\n  const requiredAssetIds = bidRequestORTB.assets.filter(asset => asset.required === 1).map(a => a.id);\n  const returnedAssetIds = bidORTB.assets.map(asset => asset.id);\n  const match = requiredAssetIds.every(assetId => returnedAssetIds.includes(assetId));\n  if (!match) {\n    logError(`didn't receive a bid with all required assets. Required ids: ${requiredAssetIds}, but received ids in response: ${returnedAssetIds}`);\n  }\n  return match;\n}\n\n/*\n * Native responses may have associated impression or click trackers.\n * This retrieves the appropriate tracker urls for the given ad object and\n * fires them. As a native creatives may be in a cross-origin frame, it may be\n * necessary to invoke this function via postMessage. secureCreatives is\n * configured to fire this function when it receives a `message` of 'Prebid Native'\n * and an `adId` with the value of the `bid.adId`. When a message is posted with\n * these parameters, impression trackers are fired. To fire click trackers, the\n * message should contain an `action` set to 'click'.\n *\n * // Native creative template example usage\n * <a href=\"%%CLICK_URL_UNESC%%%%PATTERN:hb_native_linkurl%%\"\n *    target=\"_blank\"\n *    onclick=\"fireTrackers('click')\">\n *    %%PATTERN:hb_native_title%%\n * </a>\n *\n * <script>\n *   function fireTrackers(action) {\n *     var message = {message: 'Prebid Native', adId: '%%PATTERN:hb_adid%%'};\n *     if (action === 'click') {message.action = 'click';} // fires click trackers\n *     window.parent.postMessage(JSON.stringify(message), '*');\n *   }\n *   fireTrackers(); // fires impressions when creative is loaded\n * </script>\n */\nexport function fireNativeTrackers(message, bidResponse) {\n  const nativeResponse = bidResponse.native.ortb || legacyPropertiesToOrtbNative(bidResponse.native);\n  if (message.action === 'click') {\n    fireClickTrackers(nativeResponse, message?.assetId);\n  } else {\n    fireImpressionTrackers(nativeResponse);\n  }\n  return message.action;\n}\nexport function fireImpressionTrackers(nativeResponse) {\n  let {\n    runMarkup = mkup => insertHtmlIntoIframe(mkup),\n    fetchURL = triggerPixel\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    [TRACKER_METHOD_IMG]: img = [],\n    [TRACKER_METHOD_JS]: js = []\n  } = parseEventTrackers(nativeResponse.eventtrackers || [])[EVENT_TYPE_IMPRESSION] || {};\n  if (nativeResponse.imptrackers) {\n    img = img.concat(nativeResponse.imptrackers);\n  }\n  img.forEach(url => fetchURL(url));\n  js = js.map(url => `<script async src=\"${url}\"></script>`);\n  if (nativeResponse.jstracker) {\n    // jstracker is already HTML markup\n    js = js.concat([nativeResponse.jstracker]);\n  }\n  if (js.length) {\n    runMarkup(js.join('\\n'));\n  }\n}\nexport function fireClickTrackers(nativeResponse) {\n  let assetId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let {\n    fetchURL = triggerPixel\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // legacy click tracker\n  if (!assetId) {\n    (nativeResponse.link?.clicktrackers || []).forEach(url => fetchURL(url));\n  } else {\n    // ortb click tracker. This will try to call the clicktracker associated with the asset;\n    // will fallback to the link if none is found.\n    const assetIdLinkMap = (nativeResponse.assets || []).filter(a => a.link).reduce((map, asset) => {\n      map[asset.id] = asset.link;\n      return map;\n    }, {});\n    const masterClickTrackers = nativeResponse.link?.clicktrackers || [];\n    const assetLink = assetIdLinkMap[assetId];\n    let clickTrackers = masterClickTrackers;\n    if (assetLink) {\n      clickTrackers = assetLink.clicktrackers || [];\n    }\n    clickTrackers.forEach(url => fetchURL(url));\n  }\n}\nexport function setNativeResponseProperties(bid, adUnit) {\n  const nativeOrtbRequest = adUnit?.nativeOrtbRequest;\n  const nativeOrtbResponse = bid.native?.ortb;\n  if (nativeOrtbRequest && nativeOrtbResponse) {\n    const legacyResponse = toLegacyResponse(nativeOrtbResponse, nativeOrtbRequest);\n    Object.assign(bid.native, legacyResponse);\n  }\n  ['rendererUrl', 'adTemplate'].forEach(prop => {\n    const val = adUnit?.nativeParams?.[prop];\n    if (val) {\n      bid.native[prop] = getAssetValue(val);\n    }\n  });\n}\nfunction getNativeAssets(nativeProps, keys) {\n  let ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const assets = [];\n  Object.entries(nativeProps).filter(_ref => {\n    let [k, v] = _ref;\n    return v && (ext === false && k === 'ext' || keys == null || keys.includes(k));\n  }).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    if (ext === false && key === 'ext') {\n      assets.push(...getNativeAssets(value, keys, true));\n    } else if (ext || NATIVE_KEYS.hasOwnProperty(key)) {\n      assets.push({\n        key,\n        value: getAssetValue(value)\n      });\n    }\n  });\n  return assets;\n}\nexport function getNativeRenderingData(bid, adUnit, keys) {\n  const data = {\n    ...getDefinedParams(bid.native, ['rendererUrl', 'adTemplate']),\n    assets: getNativeAssets(bid.native, keys),\n    nativeKeys: NATIVE_KEYS\n  };\n  if (bid.native.ortb) {\n    data.ortb = bid.native.ortb;\n  } else if (adUnit.mediaTypes?.native?.ortb) {\n    data.ortb = toOrtbNativeResponse(bid.native, adUnit.nativeOrtbRequest);\n  }\n  return data;\n}\nfunction assetsMessage(data, adObject, keys) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const msg = {\n    message: 'assetResponse',\n    adId: data.adId\n  };\n  let renderData = getRenderingData(adObject).native;\n  if (renderData) {\n    // if we have native rendering data (set up by the nativeRendering module)\n    // include it in full (\"all assets\") together with the renderer.\n    // this is to allow PUC to use dynamic renderers without requiring changes in creative setup\n    msg.native = Object.assign({}, renderData);\n    msg.renderer = getCreativeRendererSource(adObject);\n    msg.rendererVersion = PUC_MIN_VERSION;\n    if (keys != null) {\n      renderData.assets = renderData.assets.filter(_ref3 => {\n        let {\n          key\n        } = _ref3;\n        return keys.includes(key);\n      });\n    }\n  } else {\n    renderData = getNativeRenderingData(adObject, index.getAdUnit(adObject), keys);\n  }\n  return Object.assign(msg, renderData);\n}\nconst NATIVE_KEYS_INVERTED = Object.fromEntries(Object.entries(NATIVE_KEYS).map(_ref4 => {\n  let [k, v] = _ref4;\n  return [v, k];\n}));\n\n/**\n * Constructs a message object containing asset values for each of the\n * requested data keys.\n */\nexport function getAssetMessage(data, adObject) {\n  const keys = data.assets.map(k => NATIVE_KEYS_INVERTED[k]);\n  return assetsMessage(data, adObject, keys);\n}\nexport function getAllAssetsMessage(data, adObject) {\n  return assetsMessage(data, adObject, null);\n}\n\n/**\n * Native assets can be a string or an object with a url prop. Returns the value\n * appropriate for sending in adserver targeting or placeholder replacement.\n */\nfunction getAssetValue(value) {\n  return value?.url || value;\n}\n/**\n * converts Prebid legacy native assets request to OpenRTB format\n * @param {object} legacyNativeAssets an object that describes a native bid request in Prebid proprietary format\n * @returns an OpenRTB format of the same bid request\n */\nexport function toOrtbNativeRequest(legacyNativeAssets) {\n  if (!legacyNativeAssets && !isPlainObject(legacyNativeAssets)) {\n    logError('Native assets object is empty or not an object: ', legacyNativeAssets);\n    return;\n  }\n  const ortb = {\n    ver: '1.2',\n    assets: []\n  };\n  for (const key in legacyNativeAssets) {\n    // skip conversion for non-asset keys\n    if (NATIVE_KEYS_THAT_ARE_NOT_ASSETS.includes(key)) continue;\n    if (!NATIVE_KEYS.hasOwnProperty(key)) {\n      logError(`Unrecognized native asset code: ${key}. Asset will be ignored.`);\n      continue;\n    }\n    if (key === 'privacyLink') {\n      ortb.privacy = 1;\n      continue;\n    }\n    const asset = legacyNativeAssets[key];\n    let required = 0;\n    if (asset.required && isBoolean(asset.required)) {\n      required = Number(asset.required);\n    }\n    const ortbAsset = {\n      id: ortb.assets.length,\n      required\n    };\n    // data cases\n    if (key in PREBID_NATIVE_DATA_KEYS_TO_ORTB) {\n      ortbAsset.data = {\n        type: NATIVE_ASSET_TYPES[PREBID_NATIVE_DATA_KEYS_TO_ORTB[key]]\n      };\n      if (asset.len) {\n        ortbAsset.data.len = asset.len;\n      }\n      // icon or image case\n    } else if (key === 'icon' || key === 'image') {\n      ortbAsset.img = {\n        type: key === 'icon' ? NATIVE_IMAGE_TYPES.ICON : NATIVE_IMAGE_TYPES.MAIN\n      };\n      // if min_width and min_height are defined in aspect_ratio, they are preferred\n      if (asset.aspect_ratios) {\n        if (!isArray(asset.aspect_ratios)) {\n          logError(\"image.aspect_ratios was passed, but it's not a an array:\", asset.aspect_ratios);\n        } else if (!asset.aspect_ratios.length) {\n          logError(\"image.aspect_ratios was passed, but it's empty:\", asset.aspect_ratios);\n        } else {\n          const {\n            min_width: minWidth,\n            min_height: minHeight\n          } = asset.aspect_ratios[0];\n          if (!isInteger(minWidth) || !isInteger(minHeight)) {\n            logError('image.aspect_ratios min_width or min_height are invalid: ', minWidth, minHeight);\n          } else {\n            ortbAsset.img.wmin = minWidth;\n            ortbAsset.img.hmin = minHeight;\n          }\n          const aspectRatios = asset.aspect_ratios.filter(ar => ar.ratio_width && ar.ratio_height).map(ratio => `${ratio.ratio_width}:${ratio.ratio_height}`);\n          if (aspectRatios.length > 0) {\n            ortbAsset.img.ext = {\n              aspectratios: aspectRatios\n            };\n          }\n        }\n      }\n\n      // if asset.sizes exist, by OpenRTB spec we should remove wmin and hmin\n      if (asset.sizes) {\n        if (asset.sizes.length !== 2 || !isInteger(asset.sizes[0]) || !isInteger(asset.sizes[1])) {\n          logError('image.sizes was passed, but its value is not an array of integers:', asset.sizes);\n        } else {\n          ortbAsset.img.w = asset.sizes[0];\n          ortbAsset.img.h = asset.sizes[1];\n          delete ortbAsset.img.hmin;\n          delete ortbAsset.img.wmin;\n        }\n      }\n      // title case\n    } else if (key === 'title') {\n      ortbAsset.title = {\n        // in openRTB, len is required for titles, while in legacy prebid was not.\n        // for this reason, if len is missing in legacy prebid, we're adding a default value of 140.\n        len: asset.len || 140\n      };\n      // all extensions to the native bid request are passed as is\n    } else if (key === 'ext') {\n      ortbAsset.ext = asset;\n      // in `ext` case, required field is not needed\n      delete ortbAsset.required;\n    }\n    ortb.assets.push(ortbAsset);\n  }\n  return ortb;\n}\n\n/**\n * Greatest common divisor between two positive integers\n * https://en.wikipedia.org/wiki/Euclidean_algorithm\n */\nfunction gcd(a, b) {\n  while (a && b && a !== b) {\n    if (a > b) {\n      a = a - b;\n    } else {\n      b = b - a;\n    }\n  }\n  return a || b;\n}\n\n/**\n * This function converts an OpenRTB native request object to Prebid proprietary\n * format. The purpose of this function is to help adapters to handle the\n * transition phase where publishers may be using OpenRTB objects but the\n *  bidder does not yet support it.\n * @param {object} openRTBRequest an OpenRTB v1.2 request object\n * @returns a Prebid legacy native format request\n */\nexport function fromOrtbNativeRequest(openRTBRequest) {\n  if (!isOpenRTBBidRequestValid(openRTBRequest)) {\n    return;\n  }\n  const oldNativeObject = {};\n  for (const asset of openRTBRequest.assets) {\n    if (asset.title) {\n      const title = {\n        required: asset.required ? Boolean(asset.required) : false,\n        len: asset.title.len\n      };\n      oldNativeObject.title = title;\n    } else if (asset.img) {\n      const image = {\n        required: asset.required ? Boolean(asset.required) : false\n      };\n      if (asset.img.w && asset.img.h) {\n        image.sizes = [asset.img.w, asset.img.h];\n      } else if (asset.img.wmin && asset.img.hmin) {\n        const scale = gcd(asset.img.wmin, asset.img.hmin);\n        image.aspect_ratios = [{\n          min_width: asset.img.wmin,\n          min_height: asset.img.hmin,\n          ratio_width: asset.img.wmin / scale,\n          ratio_height: asset.img.hmin / scale\n        }];\n      }\n      if (asset.img.type === NATIVE_IMAGE_TYPES.MAIN) {\n        oldNativeObject.image = image;\n      } else {\n        oldNativeObject.icon = image;\n      }\n    } else if (asset.data) {\n      const assetType = Object.keys(NATIVE_ASSET_TYPES).find(k => NATIVE_ASSET_TYPES[k] === asset.data.type);\n      const prebidAssetName = Object.keys(PREBID_NATIVE_DATA_KEYS_TO_ORTB).find(k => PREBID_NATIVE_DATA_KEYS_TO_ORTB[k] === assetType);\n      oldNativeObject[prebidAssetName] = {\n        required: asset.required ? Boolean(asset.required) : false\n      };\n      if (asset.data.len) {\n        oldNativeObject[prebidAssetName].len = asset.data.len;\n      }\n    }\n    if (openRTBRequest.privacy) {\n      oldNativeObject.privacyLink = {\n        required: false\n      };\n    }\n    // video was not supported by old prebid assets\n  }\n  return oldNativeObject;\n}\n\n/**\n * Converts an OpenRTB request to a proprietary Prebid.js format.\n * The proprietary Prebid format has many limitations and will be dropped in\n * the future; adapters are encouraged to stop using it in favour of OpenRTB format.\n * IMPLEMENTATION DETAILS: This function returns the same exact object if no\n * conversion is needed. If a conversion is needed (meaning, at least one\n * bidRequest contains a native.ortb definition), it will return a copy.\n *\n * @param bidRequests an array of valid bid requests\n * @returns an array of valid bid requests where the openRTB bids are converted to proprietary format.\n */\nexport function convertOrtbRequestToProprietaryNative(bidRequests) {\n  if (true) {\n    if (!bidRequests || !isArray(bidRequests)) return bidRequests;\n    // check if a conversion is needed\n    if (!bidRequests.some(bidRequest => (bidRequest?.mediaTypes || {})[NATIVE]?.ortb)) {\n      return bidRequests;\n    }\n    const bidRequestsCopy = deepClone(bidRequests);\n    // convert Native ORTB definition to old-style prebid native definition\n    for (const bidRequest of bidRequestsCopy) {\n      if (bidRequest.mediaTypes && bidRequest.mediaTypes[NATIVE] && bidRequest.mediaTypes[NATIVE].ortb) {\n        bidRequest.mediaTypes[NATIVE] = Object.assign(pick(bidRequest.mediaTypes[NATIVE], NATIVE_KEYS_THAT_ARE_NOT_ASSETS), fromOrtbNativeRequest(bidRequest.mediaTypes[NATIVE].ortb));\n        bidRequest.nativeParams = processNativeAdUnitParams(bidRequest.mediaTypes[NATIVE]);\n      }\n    }\n    return bidRequestsCopy;\n  }\n  return bidRequests;\n}\n\n/**\n * convert PBJS proprietary native properties that are *not* assets to the ORTB native format.\n *\n * @param legacyNative `bidResponse.native` object as returned by adapters\n */\nexport function legacyPropertiesToOrtbNative(legacyNative) {\n  const response = {\n    link: {},\n    eventtrackers: []\n  };\n  Object.entries(legacyNative).forEach(_ref5 => {\n    let [key, value] = _ref5;\n    switch (key) {\n      case 'clickUrl':\n        response.link.url = value;\n        break;\n      case 'clickTrackers':\n        response.link.clicktrackers = Array.isArray(value) ? value : [value];\n        break;\n      case 'impressionTrackers':\n        (Array.isArray(value) ? value : [value]).forEach(url => {\n          response.eventtrackers.push({\n            event: EVENT_TYPE_IMPRESSION,\n            method: TRACKER_METHOD_IMG,\n            url\n          });\n        });\n        break;\n      case 'javascriptTrackers':\n        // jstracker is deprecated, but we need to use it here since 'javascriptTrackers' is markup, not an url\n        // TODO: at the time of writing this, core expected javascriptTrackers to be a string (despite the name),\n        // but many adapters are passing an array. It's possible that some of them are, in fact, passing URLs and not markup\n        // in general, native trackers seem to be neglected and/or broken\n        response.jstracker = Array.isArray(value) ? value.join('') : value;\n        break;\n      case 'privacyLink':\n        response.privacy = value;\n        break;\n    }\n  });\n  return response;\n}\nexport function toOrtbNativeResponse(legacyResponse, ortbRequest) {\n  const ortbResponse = {\n    ...legacyPropertiesToOrtbNative(legacyResponse),\n    assets: []\n  };\n  function useRequestAsset(predicate, fn) {\n    let asset = ortbRequest.assets.find(predicate);\n    if (asset != null) {\n      asset = deepClone(asset);\n      fn(asset);\n      ortbResponse.assets.push(asset);\n    }\n  }\n  Object.keys(legacyResponse).filter(key => !!legacyResponse[key]).forEach(key => {\n    const value = getAssetValue(legacyResponse[key]);\n    switch (key) {\n      // process titles\n      case 'title':\n        useRequestAsset(asset => asset.title != null, titleAsset => {\n          titleAsset.title = {\n            text: value\n          };\n        });\n        break;\n      case 'image':\n      case 'icon':\n        const imageType = key === 'image' ? NATIVE_IMAGE_TYPES.MAIN : NATIVE_IMAGE_TYPES.ICON;\n        useRequestAsset(asset => asset.img != null && asset.img.type === imageType, imageAsset => {\n          imageAsset.img = {\n            url: value\n          };\n        });\n        break;\n      default:\n        if (key in PREBID_NATIVE_DATA_KEYS_TO_ORTB) {\n          useRequestAsset(asset => asset.data != null && asset.data.type === NATIVE_ASSET_TYPES[PREBID_NATIVE_DATA_KEYS_TO_ORTB[key]], dataAsset => {\n            dataAsset.data = {\n              value\n            };\n          });\n        }\n        break;\n    }\n  });\n  return ortbResponse;\n}\n\n/**\n * Generates a legacy response from an ortb response. Useful during the transition period.\n * @param {*} ortbResponse a standard ortb response object\n * @param {*} ortbRequest the ortb request, useful to match ids.\n * @returns an object containing the response in legacy native format: { title: \"this is a title\", image: ... }\n */\nexport function toLegacyResponse(ortbResponse, ortbRequest) {\n  const legacyResponse = {};\n  const requestAssets = ortbRequest?.assets || [];\n  legacyResponse.clickUrl = ortbResponse.link?.url;\n  legacyResponse.privacyLink = ortbResponse.privacy;\n  for (const asset of ortbResponse?.assets || []) {\n    const requestAsset = requestAssets.find(reqAsset => asset.id === reqAsset.id);\n    if (asset.title) {\n      legacyResponse.title = asset.title.text;\n    } else if (asset.img) {\n      legacyResponse[requestAsset?.img?.type === NATIVE_IMAGE_TYPES.MAIN ? 'image' : 'icon'] = {\n        url: asset.img.url,\n        width: asset.img.w,\n        height: asset.img.h\n      };\n    } else if (asset.data) {\n      legacyResponse[PREBID_NATIVE_DATA_KEYS_TO_ORTB_INVERSE[NATIVE_ASSET_TYPES_INVERSE[requestAsset?.data?.type]]] = asset.data.value;\n    }\n  }\n\n  // Handle trackers\n  legacyResponse.impressionTrackers = [];\n  let jsTrackers = [];\n  if (ortbResponse.imptrackers) {\n    legacyResponse.impressionTrackers.push(...ortbResponse.imptrackers);\n  }\n  for (const eventTracker of ortbResponse?.eventtrackers || []) {\n    if (eventTracker.event === EVENT_TYPE_IMPRESSION && eventTracker.method === TRACKER_METHOD_IMG) {\n      legacyResponse.impressionTrackers.push(eventTracker.url);\n    }\n    if (eventTracker.event === EVENT_TYPE_IMPRESSION && eventTracker.method === TRACKER_METHOD_JS) {\n      jsTrackers.push(eventTracker.url);\n    }\n  }\n  jsTrackers = jsTrackers.map(url => `<script async src=\"${url}\"></script>`);\n  if (ortbResponse?.jstracker) {\n    jsTrackers.push(ortbResponse.jstracker);\n  }\n  if (jsTrackers.length) {\n    legacyResponse.javascriptTrackers = jsTrackers.join('\\n');\n  }\n  return legacyResponse;\n}\n\n/**\n * Inverts key-values of an object.\n */\nfunction inverse(obj) {\n  var retobj = {};\n  for (var key in obj) {\n    retobj[obj[key]] = key;\n  }\n  return retobj;\n}\n//# sourceMappingURL=native.js.map\n","import { getGlobalVarName, shouldDefineGlobal } from \"./buildOptions.js\";\n// if the global already exists in global document scope, use it, if not, create the object\nconst scope = !shouldDefineGlobal() ? {} : window;\nconst global = scope[getGlobalVarName()] = scope[getGlobalVarName()] || {};\nglobal.cmd = global.cmd || [];\nglobal.que = global.que || [];\nglobal.installedModules = global.installedModules || [];\n\n// create a pbjs global pointer\nif (scope === window) {\n  scope._pbjsGlobals = scope._pbjsGlobals || [];\n  scope._pbjsGlobals.push(getGlobalVarName());\n}\nexport function getGlobal() {\n  return global;\n}\nexport function registerModule(name) {\n  global.installedModules.push(name);\n}\n//# sourceMappingURL=prebidGlobal.js.map\n","/**\n * The referer detection module attempts to gather referer information from the current page that prebid.js resides in.\n * The information that it tries to collect includes:\n * The detected top url in the nav bar,\n * Whether it was able to reach the top most window (if for example it was embedded in several iframes),\n * The number of iframes it was embedded in if applicable (by default max ten iframes),\n * A list of the domains of each embedded window if applicable.\n * Canonical URL which refers to an HTML link element, with the attribute of rel=\"canonical\", found in the <head> element of your webpage\n */\n\nimport { config } from './config.js';\nimport { logWarn } from './utils.js';\n\n/**\n * Prepend a URL with the page's protocol (http/https), if necessary.\n */\nexport function ensureProtocol(url) {\n  let win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  if (!url) return url;\n  if (/\\w+:\\/\\//.exec(url)) {\n    // url already has protocol\n    return url;\n  }\n  let windowProto = win.location.protocol;\n  try {\n    windowProto = win.top.location.protocol;\n  } catch (e) {}\n  if (/^\\/\\//.exec(url)) {\n    // url uses relative protocol (\"//example.com\")\n    return windowProto + url;\n  } else {\n    return `${windowProto}//${url}`;\n  }\n}\n\n/**\n * Extract the domain portion from a URL.\n * @param url - The URL to extract the domain from.\n * @param options - Options for parsing the domain.\n * @param options.noLeadingWww - If true, remove 'www.' appearing at the beginning of the domain.\n * @param options.noPort - If true, do not include the ':[port]' portion.\n * @return The extracted domain or undefined if the URL is invalid.\n */\nexport function parseDomain(url) {\n  let {\n    noLeadingWww = false,\n    noPort = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let target;\n  try {\n    target = new URL(ensureProtocol(url));\n  } catch (e) {\n    return;\n  }\n  target = noPort ? target.hostname : target.host;\n  if (noLeadingWww && target.startsWith('www.')) {\n    target = target.substring(4);\n  }\n  return target;\n}\n\n/**\n * This function returns canonical URL which refers to an HTML link element, with the attribute of rel=\"canonical\", found in the <head> element of your webpage\n *\n * @param {Object} doc document\n * @returns {string|null}\n */\nfunction getCanonicalUrl(doc) {\n  try {\n    const element = doc.querySelector(\"link[rel='canonical']\");\n    if (element !== null) {\n      return element.href;\n    }\n  } catch (e) {\n    // Ignore error\n  }\n  return null;\n}\n/**\n * @param {Window} win Window\n * @returns {Function}\n */\nexport function detectReferer(win) {\n  /**\n   * This function would return a read-only array of hostnames for all the parent frames.\n   * win.location.ancestorOrigins is only supported in webkit browsers. For non-webkit browsers it will return undefined.\n   *\n   * @param {Window} win Window object\n   * @returns {(undefined|Array)} Ancestor origins or undefined\n   */\n  function getAncestorOrigins(win) {\n    try {\n      if (!win.location.ancestorOrigins) {\n        return;\n      }\n      return win.location.ancestorOrigins;\n    } catch (e) {\n      // Ignore error\n    }\n  }\n\n  // TODO: the meaning of \"reachedTop\" seems to be intentionally ambiguous - best to leave them out of\n  // the typedef for now. (for example, unit tests enforce that \"reachedTop\" should be false in some situations where we\n  // happily provide a location for the top).\n\n  /**\n   * Walk up the windows to get the origin stack and best available referrer, canonical URL, etc.\n   *\n   * @returns An object containing referer information.\n   */\n  function refererInfo() {\n    const stack = [];\n    const ancestors = getAncestorOrigins(win);\n    const maxNestedIframes = config.getConfig('maxNestedIframes');\n    let currentWindow;\n    let bestLocation;\n    let bestCanonicalUrl;\n    let reachedTop = false;\n    let level = 0;\n    let valuesFromAmp = false;\n    let inAmpFrame = false;\n    let hasTopLocation = false;\n    do {\n      const previousWindow = currentWindow;\n      const wasInAmpFrame = inAmpFrame;\n      let currentLocation;\n      let crossOrigin = false;\n      let foundLocation = null;\n      inAmpFrame = false;\n      currentWindow = currentWindow ? currentWindow.parent : win;\n      try {\n        currentLocation = currentWindow.location.href || null;\n      } catch (e) {\n        crossOrigin = true;\n      }\n      if (crossOrigin) {\n        if (wasInAmpFrame) {\n          const context = previousWindow.context;\n          try {\n            foundLocation = context.sourceUrl;\n            bestLocation = foundLocation;\n            hasTopLocation = true;\n            valuesFromAmp = true;\n            if (currentWindow === win.top) {\n              reachedTop = true;\n            }\n            if (context.canonicalUrl) {\n              bestCanonicalUrl = context.canonicalUrl;\n            }\n          } catch (e) {/* Do nothing */}\n        } else {\n          logWarn('Trying to access cross domain iframe. Continuing without referrer and location');\n          try {\n            // the referrer to an iframe is the parent window\n            const referrer = previousWindow.document.referrer;\n            if (referrer) {\n              foundLocation = referrer;\n              if (currentWindow === win.top) {\n                reachedTop = true;\n              }\n            }\n          } catch (e) {/* Do nothing */}\n          if (!foundLocation && ancestors && ancestors[level - 1]) {\n            foundLocation = ancestors[level - 1];\n            if (currentWindow === win.top) {\n              hasTopLocation = true;\n            }\n          }\n          if (foundLocation && !valuesFromAmp) {\n            bestLocation = foundLocation;\n          }\n        }\n      } else {\n        if (currentLocation) {\n          foundLocation = currentLocation;\n          bestLocation = foundLocation;\n          valuesFromAmp = false;\n          if (currentWindow === win.top) {\n            reachedTop = true;\n            const canonicalUrl = getCanonicalUrl(currentWindow.document);\n            if (canonicalUrl) {\n              bestCanonicalUrl = canonicalUrl;\n            }\n          }\n        }\n        if (currentWindow.context && currentWindow.context.sourceUrl) {\n          inAmpFrame = true;\n        }\n      }\n      stack.push(foundLocation);\n      level++;\n    } while (currentWindow !== win.top && level < maxNestedIframes);\n    stack.reverse();\n    let ref;\n    try {\n      ref = win.top.document.referrer;\n    } catch (e) {}\n    const location = reachedTop || hasTopLocation ? bestLocation : null;\n    const canonicalUrl = config.getConfig('pageUrl') || bestCanonicalUrl || null;\n    let page = config.getConfig('pageUrl') || location || ensureProtocol(canonicalUrl, win);\n    if (location && location.indexOf('?') > -1 && page.indexOf('?') === -1) {\n      page = `${page}${location.substring(location.indexOf('?'))}`;\n    }\n    return {\n      /**\n       * True if the top window is accessible.\n       */\n      reachedTop,\n      isAmp: valuesFromAmp,\n      /**\n       * number of steps between window.self and window.top\n       */\n      numIframes: level - 1,\n      /**\n       * our best guess at the location for each frame, in the direction top -> self.\n       */\n      stack,\n      /**\n       * of the top-most frame for which we could guess the location. Outside of cross-origin scenarios, this is equivalent to `location`.\n       */\n      topmostLocation: bestLocation || null,\n      /**\n       * the browser's location, or null if not available (due to cross-origin restrictions)\n       */\n      location,\n      /**\n       * the site's canonical URL as set by the publisher, through setConfig({pageUrl}) or <link rel=\"canonical\" />\n       */\n      canonicalUrl,\n      /**\n       * the best candidate for the current page URL: `canonicalUrl`, falling back to `location`\n       */\n      page,\n      /**\n       * the domain portion of `page`\n       */\n      domain: parseDomain(page) || null,\n      /**\n       * the referrer (document.referrer) to the current page, or null if not available (due to cross-origin restrictions)\n       */\n      ref: ref || null,\n      // TODO: the \"legacy\" refererInfo object is provided here, for now, to accommodate\n      // adapters that decided to just send it verbatim to their backend.\n      legacy: {\n        reachedTop,\n        isAmp: valuesFromAmp,\n        numIframes: level - 1,\n        stack,\n        referer: bestLocation || null,\n        canonicalUrl\n      }\n    };\n  }\n  return refererInfo;\n}\n\n// cache result of fn (= referer info) as long as:\n// - we are the top window\n// - canonical URL tag and window location have not changed\nexport function cacheWithLocation(fn) {\n  let win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  if (win.top !== win) return fn;\n  let canonical, href, value;\n  return function () {\n    const newCanonical = getCanonicalUrl(win.document);\n    const newHref = win.location.href;\n    if (canonical !== newCanonical || newHref !== href) {\n      canonical = newCanonical;\n      href = newHref;\n      value = fn();\n    }\n    return value;\n  };\n}\nexport const getRefererInfo = cacheWithLocation(detectReferer(window));\n//# sourceMappingURL=refererDetection.js.map\n","import { checkCookieSupport, hasDeviceAccess, logError } from './utils.js';\nimport { bidderSettings } from './bidderSettings.js';\nimport { MODULE_TYPE_BIDDER, MODULE_TYPE_PREBID } from './activities/modules.js';\nimport { isActivityAllowed, registerActivityControl } from './activities/rules.js';\nimport { ACTIVITY_PARAM_ADAPTER_CODE, ACTIVITY_PARAM_COMPONENT_TYPE, ACTIVITY_PARAM_STORAGE_KEY, ACTIVITY_PARAM_STORAGE_TYPE, ACTIVITY_PARAM_STORAGE_WRITE } from './activities/params.js';\nimport { ACTIVITY_ACCESS_DEVICE, ACTIVITY_ACCESS_REQUEST_CREDENTIALS } from './activities/activities.js';\nimport { config } from './config.js';\nimport { hook } from \"./hook.js\";\nimport adapterManager from './adapterManager.js';\nimport { activityParams } from './activities/activityParams.js';\nexport const STORAGE_TYPE_LOCALSTORAGE = 'html5';\nexport const STORAGE_TYPE_COOKIES = 'cookie';\nexport let storageCallbacks = [];\n\n/* eslint-disable no-restricted-properties */\n\n/*\n *  Storage manager constructor. Consumers should prefer one of `getStorageManager` or `getCoreStorageManager`.\n */\nexport function newStorageManager() {\n  let {\n    moduleName,\n    moduleType,\n    advertiseKeys = true\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    isAllowed = isActivityAllowed\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  function isValid(cb, storageType, storageKey, isWrite) {\n    let mod = moduleName;\n    const curBidder = config.getCurrentBidder();\n    if (curBidder && moduleType === MODULE_TYPE_BIDDER && adapterManager.aliasRegistry[curBidder] === moduleName) {\n      mod = curBidder;\n    }\n    const params = {\n      [ACTIVITY_PARAM_STORAGE_TYPE]: storageType,\n      [ACTIVITY_PARAM_STORAGE_WRITE]: isWrite\n    };\n    if (advertiseKeys && storageKey != null) {\n      params[ACTIVITY_PARAM_STORAGE_KEY] = storageKey;\n    }\n    const result = {\n      valid: isAllowed(ACTIVITY_ACCESS_DEVICE, activityParams(moduleType, mod, params))\n    };\n    return cb(result);\n  }\n  function schedule(operation, storageType, storageKey, isWrite, done) {\n    if (done && typeof done === 'function') {\n      storageCallbacks.push(function () {\n        let result = isValid(operation, storageType, storageKey, isWrite);\n        done(result);\n      });\n    } else {\n      return isValid(operation, storageType, storageKey, isWrite);\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {string} value\n   * @param {string} [expires='']\n   * @param {string} [sameSite='/']\n   * @param {string} [domain] domain (e.g., 'example.com' or 'subdomain.example.com').\n   * If not specified, defaults to the host portion of the current document location.\n   * If a domain is specified, subdomains are always included.\n   * Domain must match the domain of the JavaScript origin. Setting cookies to foreign domains will be silently ignored.\n   * @param {function} [done]\n   */\n  const setCookie = function (key, value, expires, sameSite, domain, done) {\n    let cb = function (result) {\n      if (result && result.valid) {\n        const domainPortion = domain && domain !== '' ? ` ;domain=${encodeURIComponent(domain)}` : '';\n        const expiresPortion = expires && expires !== '' ? ` ;expires=${expires}` : '';\n        const isNone = sameSite != null && sameSite.toLowerCase() == 'none';\n        const secure = isNone ? '; Secure' : '';\n        document.cookie = `${key}=${encodeURIComponent(value)}${expiresPortion}; path=/${domainPortion}${sameSite ? `; SameSite=${sameSite}` : ''}${secure}`;\n      }\n    };\n    return schedule(cb, STORAGE_TYPE_COOKIES, key, true, done);\n  };\n\n  /**\n   * @param {string} name\n   * @param {function} [done]\n   * @returns {(string|null)}\n   */\n  const getCookie = function (name, done) {\n    let cb = function (result) {\n      if (result && result.valid) {\n        let m = window.document.cookie.match('(^|;)\\\\s*' + name + '\\\\s*=\\\\s*([^;]*)\\\\s*(;|$)');\n        return m ? decodeURIComponent(m[2]) : null;\n      }\n      return null;\n    };\n    return schedule(cb, STORAGE_TYPE_COOKIES, name, false, done);\n  };\n\n  /**\n   * @param {function} [done]\n   * @returns {boolean}\n   */\n  const cookiesAreEnabled = function (done) {\n    let cb = function (result) {\n      if (result && result.valid) {\n        return checkCookieSupport();\n      }\n      return false;\n    };\n    return schedule(cb, STORAGE_TYPE_COOKIES, null, false, done);\n  };\n  function storageMethods(name) {\n    const capName = name.charAt(0).toUpperCase() + name.substring(1);\n    const backend = () => window[name];\n    const hasStorage = function (done) {\n      let cb = function (result) {\n        if (result && result.valid) {\n          try {\n            return !!backend();\n          } catch (e) {\n            logError(`${name} api disabled`);\n          }\n        }\n        return false;\n      };\n      return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, null, false, done);\n    };\n    return {\n      [`has${capName}`]: hasStorage,\n      [`${name}IsEnabled`](done) {\n        let cb = function (result) {\n          if (result && result.valid) {\n            try {\n              backend().setItem('prebid.cookieTest', '1');\n              return backend().getItem('prebid.cookieTest') === '1';\n            } catch (error) {} finally {\n              try {\n                backend().removeItem('prebid.cookieTest');\n              } catch (error) {}\n            }\n          }\n          return false;\n        };\n        return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, null, false, done);\n      },\n      [`setDataIn${capName}`](key, value, done) {\n        let cb = function (result) {\n          if (result && result.valid && hasStorage()) {\n            backend().setItem(key, value);\n          }\n        };\n        return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, key, true, done);\n      },\n      [`getDataFrom${capName}`](key, done) {\n        let cb = function (result) {\n          if (result && result.valid && hasStorage()) {\n            return backend().getItem(key);\n          }\n          return null;\n        };\n        return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, key, false, done);\n      },\n      [`removeDataFrom${capName}`](key, done) {\n        let cb = function (result) {\n          if (result && result.valid && hasStorage()) {\n            backend().removeItem(key);\n          }\n        };\n        return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, key, true, done);\n      }\n    };\n  }\n\n  /**\n   * Returns all cookie values from the jar whose names contain the `keyLike`\n   * Needs to exist in `utils.js` as it follows the StorageHandler interface defined in live-connect-js. If that module were to be removed, this function can go as well.\n   * @param {string} keyLike\n   * @param {function} [done]\n   * @returns {string[]}\n   */\n  const findSimilarCookies = function (keyLike, done) {\n    let cb = function (result) {\n      if (result && result.valid) {\n        const all = [];\n        if (hasDeviceAccess()) {\n          const cookies = document.cookie.split(';');\n          while (cookies.length) {\n            const cookie = cookies.pop();\n            let separatorIndex = cookie.indexOf('=');\n            separatorIndex = separatorIndex < 0 ? cookie.length : separatorIndex;\n            const cookieName = decodeURIComponent(cookie.slice(0, separatorIndex).replace(/^\\s+/, ''));\n            if (cookieName.indexOf(keyLike) >= 0) {\n              all.push(decodeURIComponent(cookie.slice(separatorIndex + 1)));\n            }\n          }\n        }\n        return all;\n      }\n    };\n    return schedule(cb, STORAGE_TYPE_COOKIES, keyLike, false, done);\n  };\n  return {\n    setCookie,\n    getCookie,\n    cookiesAreEnabled,\n    ...storageMethods('localStorage'),\n    ...storageMethods('sessionStorage'),\n    findSimilarCookies\n  };\n}\n\n/**\n * Get a storage manager for a particular module.\n *\n * Either bidderCode or a combination of moduleType + moduleName must be provided. The former is a shorthand\n *  for `{moduleType: 'bidder', moduleName: bidderCode}`.\n *\n */\nexport function getStorageManager() {\n  let {\n    moduleType,\n    moduleName,\n    bidderCode\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  function err() {\n    throw new Error(`Invalid invocation for getStorageManager: must set either bidderCode, or moduleType + moduleName`);\n  }\n  if (bidderCode) {\n    if (moduleType && moduleType !== MODULE_TYPE_BIDDER || moduleName) err();\n    moduleType = MODULE_TYPE_BIDDER;\n    moduleName = bidderCode;\n  } else if (!moduleName || !moduleType) {\n    err();\n  }\n  return newStorageManager({\n    moduleType,\n    moduleName\n  });\n}\n\n/**\n * Get a storage manager for \"core\" (vendorless, or first-party) modules. Shorthand for `getStorageManager({moduleName, moduleType: 'core'})`.\n *\n * @param {string} moduleName Module name\n */\nexport function getCoreStorageManager(moduleName) {\n  return newStorageManager({\n    moduleName: moduleName,\n    moduleType: MODULE_TYPE_PREBID\n  });\n}\n\n/**\n * Block all access to storage when deviceAccess = false\n */\nexport function deviceAccessRule() {\n  if (!hasDeviceAccess()) {\n    return {\n      allow: false\n    };\n  }\n}\nregisterActivityControl(ACTIVITY_ACCESS_DEVICE, 'deviceAccess config', deviceAccessRule);\n\n/**\n * Block all access to request credentials when deviceAccess = false\n */\nregisterActivityControl(ACTIVITY_ACCESS_REQUEST_CREDENTIALS, 'deviceAccess config', deviceAccessRule);\n\n/**\n * By default, deny bidders accessDevice unless they enable it through bidderSettings\n *\n * // TODO: for backwards compat, the check is done on the adapter - rather than bidder's code.\n */\nexport function storageAllowedRule(params) {\n  let bs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : bidderSettings;\n  if (params[ACTIVITY_PARAM_COMPONENT_TYPE] !== MODULE_TYPE_BIDDER) return;\n  let allow = bs.get(params[ACTIVITY_PARAM_ADAPTER_CODE], 'storageAllowed');\n  if (!allow || allow === true) {\n    allow = !!allow;\n  } else {\n    const storageType = params[ACTIVITY_PARAM_STORAGE_TYPE];\n    allow = Array.isArray(allow) ? allow.some(e => e === storageType) : allow === storageType;\n  }\n  if (!allow) {\n    return {\n      allow\n    };\n  }\n}\nregisterActivityControl(ACTIVITY_ACCESS_DEVICE, 'bidderSettings.*.storageAllowed', storageAllowedRule);\nexport function resetData() {\n  storageCallbacks = [];\n}\n\n/**\n * First party storage use disclosure. Follows the same format as\n * https://github.com/InteractiveAdvertisingBureau/GDPR-Transparency-and-Consent-Framework/blob/master/TCFv2/Vendor%20Device%20Storage%20%26%20Operational%20Disclosures.md\n * except that `domain` is omitted.\n */\n\n/**\n * Disclose first party storage use.\n */\nexport const discloseStorageUse = hook('sync', (moduleName, disclosure) => {});\n//# sourceMappingURL=storageManager.js.map\n","import { auctionManager } from './auctionManager.js';\nimport { getBufferedTTL } from './bidTTL.js';\nimport { bidderSettings } from './bidderSettings.js';\nimport { config } from './config.js';\nimport { BID_STATUS, DEFAULT_TARGETING_KEYS, EVENTS, JSON_MAPPING, TARGETING_KEYS } from './constants.js';\nimport * as events from './events.js';\nimport { hook } from './hook.js';\nimport { ADPOD } from './mediaTypes.js';\nimport { deepAccess, deepClone, groupBy, isAdUnitCodeMatchingSlot, isArray, isFn, isStr, logError, logInfo, logMessage, logWarn, sortByHighestCpm, timestamp, uniques } from './utils.js';\nimport { getHighestCpm, getOldestHighestCpmBid } from './utils/reducers.js';\nvar pbTargetingKeys = [];\nconst MAX_DFP_KEYLENGTH = 20;\nconst CFG_ALLOW_TARGETING_KEYS = `targetingControls.allowTargetingKeys`;\nconst CFG_ADD_TARGETING_KEYS = `targetingControls.addTargetingKeys`;\nconst TARGETING_KEY_CONFIGURATION_ERROR_MSG = `Only one of \"${CFG_ALLOW_TARGETING_KEYS}\" or \"${CFG_ADD_TARGETING_KEYS}\" can be set`;\nexport const TARGETING_KEYS_ARR = Object.keys(TARGETING_KEYS).map(key => TARGETING_KEYS[key]);\n\n// return unexpired bids\nconst isBidNotExpired = bid => bid.responseTimestamp + getBufferedTTL(bid) * 1000 > timestamp();\n\n// return bids whose status is not set. Winning bids can only have a status of `rendered`.\nconst isUnusedBid = bid => bid && (bid.status && ![BID_STATUS.RENDERED].includes(bid.status) || !bid.status);\nexport const filters = {\n  isBidNotExpired,\n  isUnusedBid\n};\nexport function isBidUsable(bid) {\n  return !Object.values(filters).some(predicate => !predicate(bid));\n}\n\n// If two bids are found for same adUnitCode, we will use the highest one to take part in auction\n// This can happen in case of concurrent auctions\n// If adUnitBidLimit is set above 0 return top N number of bids\nexport const getHighestCpmBidsFromBidPool = hook('sync', function (bidsReceived, winReducer) {\n  let adUnitBidLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let hasModified = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let winSorter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : sortByHighestCpm;\n  if (!hasModified) {\n    const bids = [];\n    const dealPrioritization = config.getConfig('sendBidsControl.dealPrioritization');\n    // bucket by adUnitcode\n    const buckets = groupBy(bidsReceived, 'adUnitCode');\n    // filter top bid for each bucket by bidder\n    Object.keys(buckets).forEach(bucketKey => {\n      let bucketBids = [];\n      const bidsByBidder = groupBy(buckets[bucketKey], 'bidderCode');\n      Object.keys(bidsByBidder).forEach(key => {\n        bucketBids.push(bidsByBidder[key].reduce(winReducer));\n      });\n      // if adUnitBidLimit is set, pass top N number bids\n      if (adUnitBidLimit) {\n        bucketBids = dealPrioritization ? bucketBids.sort(sortByDealAndPriceBucketOrCpm(true)) : bucketBids.sort((a, b) => b.cpm - a.cpm);\n        bids.push(...bucketBids.slice(0, adUnitBidLimit));\n      } else {\n        bucketBids = bucketBids.sort(winSorter);\n        bids.push(...bucketBids);\n      }\n    });\n    return bids;\n  }\n  return bidsReceived;\n});\n\n/**\n * A descending sort function that will sort the list of objects based on the following two dimensions:\n *  - bids with a deal are sorted before bids w/o a deal\n *  - then sort bids in each grouping based on the hb_pb value\n * eg: the following list of bids would be sorted like:\n *  [{\n *    \"hb_adid\": \"vwx\",\n *    \"hb_pb\": \"28\",\n *    \"hb_deal\": \"7747\"\n *  }, {\n *    \"hb_adid\": \"jkl\",\n *    \"hb_pb\": \"10\",\n *    \"hb_deal\": \"9234\"\n *  }, {\n *    \"hb_adid\": \"stu\",\n *    \"hb_pb\": \"50\"\n *  }, {\n *    \"hb_adid\": \"def\",\n *    \"hb_pb\": \"2\"\n *  }]\n */\nexport function sortByDealAndPriceBucketOrCpm() {\n  let useCpm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return function (a, b) {\n    if (a.adserverTargeting.hb_deal !== undefined && b.adserverTargeting.hb_deal === undefined) {\n      return -1;\n    }\n    if (a.adserverTargeting.hb_deal === undefined && b.adserverTargeting.hb_deal !== undefined) {\n      return 1;\n    }\n\n    // assuming both values either have a deal or don't have a deal - sort by the hb_pb param\n    if (useCpm) {\n      return b.cpm - a.cpm;\n    }\n    return b.adserverTargeting.hb_pb - a.adserverTargeting.hb_pb;\n  };\n}\n\n/**\n * Return a map where each code in `adUnitCodes` maps to a list of GPT slots that match it.\n *\n * @param adUnitCodes\n * @param customSlotMatching\n * @param getSlots\n */\nexport function getGPTSlotsForAdUnits(adUnitCodes, customSlotMatching) {\n  let getSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => window.googletag.pubads().getSlots();\n  return getSlots().reduce((auToSlots, slot) => {\n    const customMatch = isFn(customSlotMatching) && customSlotMatching(slot);\n    Object.keys(auToSlots).filter(isFn(customMatch) ? customMatch : isAdUnitCodeMatchingSlot(slot)).forEach(au => auToSlots[au].push(slot));\n    return auToSlots;\n  }, Object.fromEntries(adUnitCodes.map(au => [au, []])));\n}\nexport function newTargeting(auctionManager) {\n  const latestAuctionForAdUnit = {};\n  const targeting = {\n    setLatestAuctionForAdUnit(adUnitCode, auctionId) {\n      latestAuctionForAdUnit[adUnitCode] = auctionId;\n    },\n    resetPresetTargetingAST(adUnitCode) {\n      const adUnitCodes = getAdUnitCodes(adUnitCode);\n      adUnitCodes.forEach(function (unit) {\n        const astTag = window.apntag.getTag(unit);\n        if (astTag && astTag.keywords) {\n          const currentKeywords = Object.keys(astTag.keywords);\n          const newKeywords = {};\n          currentKeywords.forEach(key => {\n            if (!pbTargetingKeys.includes(key.toLowerCase())) {\n              newKeywords[key] = astTag.keywords[key];\n            }\n          });\n          window.apntag.modifyTag(unit, {\n            keywords: newKeywords\n          });\n        }\n      });\n    },\n    /**\n     * Returns all ad server targeting for all ad units.\n     * @param adUnitCode\n     * @param bidLimit\n     * @param bidsReceived - The received bids, defaulting to the result of getBidsReceived().\n     * @param [winReducer = getHighestCpm] - reducer method\n     * @param [winSorter = sortByHighestCpm] - sorter method\n     * @return targeting\n     */\n    getAllTargeting(adUnitCode, bidLimit, bidsReceived) {\n      let winReducer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getHighestCpm;\n      let winSorter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : sortByHighestCpm;\n      bidsReceived ||= getBidsReceived(winReducer, winSorter);\n      const adUnitCodes = getAdUnitCodes(adUnitCode);\n      const sendAllBids = config.getConfig('enableSendAllBids');\n      const bidLimitConfigValue = config.getConfig('sendBidsControl.bidLimit');\n      const adUnitBidLimit = sendAllBids && (bidLimit || bidLimitConfigValue) || 0;\n      const {\n        customKeysByUnit,\n        filteredBids\n      } = getfilteredBidsAndCustomKeys(adUnitCodes, bidsReceived);\n      const bidsSorted = getHighestCpmBidsFromBidPool(filteredBids, winReducer, adUnitBidLimit, undefined, winSorter);\n      let targeting = getTargetingLevels(bidsSorted, customKeysByUnit, adUnitCodes);\n      const defaultKeys = Object.keys(Object.assign({}, DEFAULT_TARGETING_KEYS));\n      let allowedKeys = config.getConfig(CFG_ALLOW_TARGETING_KEYS);\n      const addedKeys = config.getConfig(CFG_ADD_TARGETING_KEYS);\n      if (addedKeys != null && allowedKeys != null) {\n        throw new Error(TARGETING_KEY_CONFIGURATION_ERROR_MSG);\n      } else if (addedKeys != null) {\n        allowedKeys = defaultKeys.concat(addedKeys);\n      } else {\n        allowedKeys = allowedKeys || defaultKeys;\n      }\n      if (Array.isArray(allowedKeys) && allowedKeys.length > 0) {\n        targeting = getAllowedTargetingKeyValues(targeting, allowedKeys);\n      }\n      let flatTargeting = flattenTargeting(targeting);\n      const auctionKeysThreshold = config.getConfig('targetingControls.auctionKeyMaxChars');\n      if (auctionKeysThreshold) {\n        logInfo(`Detected 'targetingControls.auctionKeyMaxChars' was active for this auction; set with a limit of ${auctionKeysThreshold} characters.  Running checks on auction keys...`);\n        flatTargeting = filterTargetingKeys(flatTargeting, auctionKeysThreshold);\n      }\n\n      // make sure at least there is a entry per adUnit code in the targetingSet so receivers of SET_TARGETING call's can know what ad units are being invoked\n      adUnitCodes.forEach(code => {\n        if (!flatTargeting[code]) {\n          flatTargeting[code] = {};\n        }\n      });\n      return flatTargeting;\n    },\n    setTargetingForGPT: hook('sync', function (adUnit, customSlotMatching) {\n      // get our ad unit codes\n      const targetingSet = targeting.getAllTargeting(adUnit);\n      const resetMap = Object.fromEntries(pbTargetingKeys.map(key => [key, null]));\n      Object.entries(getGPTSlotsForAdUnits(Object.keys(targetingSet), customSlotMatching)).forEach(_ref => {\n        let [targetId, slots] = _ref;\n        slots.forEach(slot => {\n          // now set new targeting keys\n          Object.keys(targetingSet[targetId]).forEach(key => {\n            let value = targetingSet[targetId][key];\n            if (typeof value === 'string' && value.indexOf(',') !== -1) {\n              // due to the check the array will be formed only if string has ',' else plain string will be assigned as value\n              value = value.split(',');\n            }\n            targetingSet[targetId][key] = value;\n          });\n          logMessage(`Attempting to set targeting-map for slot: ${slot.getSlotElementId()} with targeting-map:`, targetingSet[targetId]);\n          slot.updateTargetingFromMap(Object.assign({}, resetMap, targetingSet[targetId]));\n        });\n      });\n      Object.keys(targetingSet).forEach(adUnitCode => {\n        Object.keys(targetingSet[adUnitCode]).forEach(targetingKey => {\n          if (targetingKey === 'hb_adid') {\n            auctionManager.setStatusForBids(targetingSet[adUnitCode][targetingKey], BID_STATUS.BID_TARGETING_SET);\n          }\n        });\n      });\n      targeting.targetingDone(targetingSet);\n\n      // emit event\n      events.emit(EVENTS.SET_TARGETING, targetingSet);\n    }, 'setTargetingForGPT'),\n    targetingDone: hook('sync', function (targetingSet) {\n      return targetingSet;\n    }, 'targetingDone'),\n    /**\n     * Returns top bids for a given adUnit or set of adUnits.\n     * @param  adUnitCode adUnitCode or array of adUnitCodes\n     * @param  bids - The received bids, defaulting to the result of getBidsReceived().\n     * @param  [winReducer = getHighestCpm] - reducer method\n     * @param  [winSorter = sortByHighestCpm] - sorter method\n     * @return An array of winning bids.\n     */\n    getWinningBids(adUnitCode, bids) {\n      let winReducer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getHighestCpm;\n      let winSorter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sortByHighestCpm;\n      const bidsReceived = bids || getBidsReceived(winReducer, winSorter);\n      const adUnitCodes = getAdUnitCodes(adUnitCode);\n      return bidsReceived.filter(bid => adUnitCodes.includes(bid.adUnitCode)).filter(bid => bidderSettings.get(bid.bidderCode, 'allowZeroCpmBids') === true ? bid.cpm >= 0 : bid.cpm > 0).map(bid => bid.adUnitCode).filter(uniques).map(adUnitCode => bidsReceived.filter(bid => bid.adUnitCode === adUnitCode ? bid : null).reduce(getHighestCpm));\n    },\n    /**\n     * @param  adUnitCodes adUnitCode or array of adUnitCodes\n     * Sets targeting for AST\n     */\n    setTargetingForAst(adUnitCodes) {\n      const astTargeting = targeting.getAllTargeting(adUnitCodes);\n      try {\n        targeting.resetPresetTargetingAST(adUnitCodes);\n      } catch (e) {\n        logError('unable to reset targeting for AST' + e);\n      }\n      Object.keys(astTargeting).forEach(targetId => Object.keys(astTargeting[targetId]).forEach(key => {\n        logMessage(`Attempting to set targeting for targetId: ${targetId} key: ${key} value: ${astTargeting[targetId][key]}`);\n        // setKeywords supports string and array as value\n        if (isStr(astTargeting[targetId][key]) || isArray(astTargeting[targetId][key])) {\n          const keywordsObj = {};\n          const regex = /pt[0-9]/;\n          if (key.search(regex) < 0) {\n            keywordsObj[key.toUpperCase()] = astTargeting[targetId][key];\n          } else {\n            // pt${n} keys should not be uppercased\n            keywordsObj[key] = astTargeting[targetId][key];\n          }\n          window.apntag.setKeywords(targetId, keywordsObj, {\n            overrideKeyValue: true\n          });\n        }\n      }));\n    },\n    isApntagDefined() {\n      if (window.apntag && isFn(window.apntag.setKeywords)) {\n        return true;\n      }\n    }\n  };\n  function addBidToTargeting(bids) {\n    let enableSendAllBids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let deals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const standardKeys = TARGETING_KEYS_ARR.slice();\n    const allowSendAllBidsTargetingKeys = config.getConfig('targetingControls.allowSendAllBidsTargetingKeys');\n    const allowedSendAllBidTargeting = allowSendAllBidsTargetingKeys ? allowSendAllBidsTargetingKeys.map(key => TARGETING_KEYS[key]) : standardKeys;\n    return bids.reduce((result, bid) => {\n      if (enableSendAllBids || deals && bid.dealId) {\n        const targetingValue = getTargetingMap(bid, standardKeys.filter(key => typeof bid.adserverTargeting[key] !== 'undefined' && (deals || allowedSendAllBidTargeting.indexOf(key) !== -1)));\n        if (targetingValue) {\n          result.push({\n            [bid.adUnitCode]: targetingValue\n          });\n        }\n      }\n      return result;\n    }, []);\n  }\n  function getBidderTargeting(bids) {\n    const alwaysIncludeDeals = config.getConfig('targetingControls.alwaysIncludeDeals');\n    const enableSendAllBids = config.getConfig('enableSendAllBids');\n    return addBidToTargeting(bids, enableSendAllBids, alwaysIncludeDeals);\n  }\n\n  /**\n   * Returns filtered ad server targeting for custom and allowed keys.\n   * @param targeting\n   * @param allowedKeys\n   * @return filtered targeting\n   */\n  function getAllowedTargetingKeyValues(targeting, allowedKeys) {\n    const defaultKeyring = Object.assign({}, TARGETING_KEYS);\n    const defaultKeys = Object.keys(TARGETING_KEYS);\n    const keyDispositions = {};\n    logInfo(`allowTargetingKeys - allowed keys [ ${allowedKeys.map(k => defaultKeyring[k]).join(', ')} ]`);\n    targeting.map(adUnit => {\n      const adUnitCode = Object.keys(adUnit)[0];\n      const keyring = adUnit[adUnitCode];\n      const keys = keyring.filter(kvPair => {\n        const key = Object.keys(kvPair)[0];\n        // check if key is in default keys, if not, it's custom, we won't remove it.\n        const isCustom = defaultKeys.filter(defaultKey => key.indexOf(defaultKeyring[defaultKey]) === 0).length === 0;\n        // check if key explicitly allowed, if not, we'll remove it.\n        const found = isCustom || allowedKeys.find(allowedKey => {\n          const allowedKeyName = defaultKeyring[allowedKey];\n          // we're looking to see if the key exactly starts with one of our default keys.\n          // (which hopefully means it's not custom)\n          const found = key.indexOf(allowedKeyName) === 0;\n          return found;\n        });\n        keyDispositions[key] = !found;\n        return found;\n      });\n      adUnit[adUnitCode] = keys;\n    });\n    const removedKeys = Object.keys(keyDispositions).filter(d => keyDispositions[d]);\n    logInfo(`allowTargetingKeys - removed keys [ ${removedKeys.join(', ')} ]`);\n    // remove any empty targeting objects, as they're unnecessary.\n    const filteredTargeting = targeting.filter(adUnit => {\n      const adUnitCode = Object.keys(adUnit)[0];\n      const keyring = adUnit[adUnitCode];\n      return keyring.length > 0;\n    });\n    return filteredTargeting;\n  }\n  function updatePBTargetingKeys(adUnitCode) {\n    Object.keys(adUnitCode).forEach(key => {\n      adUnitCode[key].forEach(targetKey => {\n        const targetKeys = Object.keys(targetKey);\n        if (pbTargetingKeys.indexOf(targetKeys[0]) === -1) {\n          pbTargetingKeys = targetKeys.concat(pbTargetingKeys);\n        }\n      });\n    });\n  }\n  function getTargetingLevels(bidsSorted, customKeysByUnit, adUnitCodes) {\n    const useAllBidsCustomTargeting = config.getConfig('targetingControls.allBidsCustomTargeting') === true;\n    const targeting = getWinningBidTargeting(bidsSorted, adUnitCodes).concat(getBidderTargeting(bidsSorted)).concat(getAdUnitTargeting(adUnitCodes));\n    if (useAllBidsCustomTargeting) {\n      targeting.push(...getCustomBidTargeting(bidsSorted, customKeysByUnit));\n    }\n    targeting.forEach(adUnitCode => {\n      updatePBTargetingKeys(adUnitCode);\n    });\n    return targeting;\n  }\n  function getfilteredBidsAndCustomKeys(adUnitCodes, bidsReceived) {\n    const filteredBids = [];\n    const customKeysByUnit = {};\n    const alwaysIncludeDeals = config.getConfig('targetingControls.alwaysIncludeDeals');\n    bidsReceived.forEach(bid => {\n      const adUnitIsEligible = adUnitCodes.includes(bid.adUnitCode);\n      const cpmAllowed = bidderSettings.get(bid.bidderCode, 'allowZeroCpmBids') === true ? bid.cpm >= 0 : bid.cpm > 0;\n      const isPreferredDeal = alwaysIncludeDeals && bid.dealId;\n      if (adUnitIsEligible && (isPreferredDeal || cpmAllowed)) {\n        filteredBids.push(bid);\n        Object.keys(bid.adserverTargeting).filter(getCustomKeys()).forEach(key => {\n          const truncKey = key.substring(0, MAX_DFP_KEYLENGTH);\n          const data = customKeysByUnit[bid.adUnitCode] || {};\n          const value = [bid.adserverTargeting[key]];\n          if (data[truncKey]) {\n            data[truncKey] = data[truncKey].concat(value).filter(uniques);\n          } else {\n            data[truncKey] = value;\n          }\n          customKeysByUnit[bid.adUnitCode] = data;\n        });\n      }\n    });\n    return {\n      filteredBids,\n      customKeysByUnit\n    };\n  }\n\n  // warn about conflicting configuration\n  config.getConfig('targetingControls', function (config) {\n    if (deepAccess(config, CFG_ALLOW_TARGETING_KEYS) != null && deepAccess(config, CFG_ADD_TARGETING_KEYS) != null) {\n      logError(TARGETING_KEY_CONFIGURATION_ERROR_MSG);\n    }\n  });\n\n  // create an encoded string variant based on the keypairs of the provided object\n  //  - note this will encode the characters between the keys (ie = and &)\n  function convertKeysToQueryForm(keyMap) {\n    return Object.keys(keyMap).reduce(function (queryString, key) {\n      const encodedKeyPair = `${key}%3d${encodeURIComponent(keyMap[key])}%26`;\n      queryString += encodedKeyPair;\n      return queryString;\n    }, '');\n  }\n  function filterTargetingKeys(targeting, auctionKeysThreshold) {\n    // read each targeting.adUnit object and sort the adUnits into a list of adUnitCodes based on priorization setting (eg CPM)\n    const targetingCopy = deepClone(targeting);\n    const targetingMap = Object.keys(targetingCopy).map(adUnitCode => {\n      return {\n        adUnitCode,\n        adserverTargeting: targetingCopy[adUnitCode]\n      };\n    }).sort(sortByDealAndPriceBucketOrCpm());\n\n    // iterate through the targeting based on above list and transform the keys into the query-equivalent and count characters\n    return targetingMap.reduce(function (accMap, currMap, index, arr) {\n      let adUnitQueryString = convertKeysToQueryForm(currMap.adserverTargeting);\n\n      // for the last adUnit - trim last encoded ampersand from the converted query string\n      if (index + 1 === arr.length) {\n        adUnitQueryString = adUnitQueryString.slice(0, -3);\n      }\n\n      // if under running threshold add to result\n      const code = currMap.adUnitCode;\n      const querySize = adUnitQueryString.length;\n      if (querySize <= auctionKeysThreshold) {\n        auctionKeysThreshold -= querySize;\n        logInfo(`AdUnit '${code}' auction keys comprised of ${querySize} characters.  Deducted from running threshold; new limit is ${auctionKeysThreshold}`, targetingCopy[code]);\n        accMap[code] = targetingCopy[code];\n      } else {\n        logWarn(`The following keys for adUnitCode '${code}' exceeded the current limit of the 'auctionKeyMaxChars' setting.\\nThe key-set size was ${querySize}, the current allotted amount was ${auctionKeysThreshold}.\\n`, targetingCopy[code]);\n      }\n      if (index + 1 === arr.length && Object.keys(accMap).length === 0) {\n        logError('No auction targeting keys were permitted due to the setting in setConfig(targetingControls.auctionKeyMaxChars).  Please review setup and consider adjusting.');\n      }\n      return accMap;\n    }, {});\n  }\n\n  /**\n   * Converts targeting array and flattens to make it easily iteratable\n   * e.g: Sample input to this function\n   * ```\n   * [\n   *    {\n   *      \"div-gpt-ad-1460505748561-0\": [{\"hb_bidder\": [\"appnexusAst\"]}]\n   *    },\n   *    {\n   *      \"div-gpt-ad-1460505748561-0\": [{\"hb_bidder_appnexusAs\": [\"appnexusAst\", \"other\"]}]\n   *    }\n   * ]\n   * ```\n   * Resulting array\n   * ```\n   * {\n   *  \"div-gpt-ad-1460505748561-0\": {\n   *    \"hb_bidder\": \"appnexusAst\",\n   *    \"hb_bidder_appnexusAs\": \"appnexusAst,other\"\n   *  }\n   * }\n   * ```\n   *\n   * @param targeting\n   * @return targeting\n   */\n  function flattenTargeting(targeting) {\n    return targeting.map(targeting => {\n      return {\n        [Object.keys(targeting)[0]]: targeting[Object.keys(targeting)[0]].map(target => {\n          return {\n            [Object.keys(target)[0]]: target[Object.keys(target)[0]].join(',')\n          };\n        }).reduce((p, c) => Object.assign(c, p), {})\n      };\n    }).reduce(function (accumulator, targeting) {\n      var key = Object.keys(targeting)[0];\n      accumulator[key] = Object.assign({}, accumulator[key], targeting[key]);\n      return accumulator;\n    }, {});\n  }\n\n  /**\n   * normlizes input to a `adUnit.code` array\n   * @param  adUnitCode\n   * @return AdUnit code array\n   */\n  function getAdUnitCodes(adUnitCode) {\n    if (typeof adUnitCode === 'string') {\n      return [adUnitCode];\n    } else if (isArray(adUnitCode)) {\n      return adUnitCode;\n    }\n    return auctionManager.getAdUnitCodes() || [];\n  }\n  function getBidsReceived() {\n    let winReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getOldestHighestCpmBid;\n    let winSorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    const bidsReceived = auctionManager.getBidsReceived().reduce((bids, bid) => {\n      const bidCacheEnabled = config.getConfig('useBidCache');\n      const filterFunction = config.getConfig('bidCacheFilterFunction');\n      const isBidFromLastAuction = latestAuctionForAdUnit[bid.adUnitCode] === bid.auctionId;\n      const filterFunctionResult = bidCacheEnabled && !isBidFromLastAuction && typeof filterFunction === 'function' ? !!filterFunction(bid) : true;\n      const cacheFilter = bidCacheEnabled || isBidFromLastAuction;\n      const bidFilter = cacheFilter && filterFunctionResult;\n      if (bidFilter && bid?.video?.context !== ADPOD && isBidUsable(bid)) {\n        bid.latestTargetedAuctionId = latestAuctionForAdUnit[bid.adUnitCode];\n        bids.push(bid);\n      }\n      return bids;\n    }, []);\n    return getHighestCpmBidsFromBidPool(bidsReceived, winReducer, undefined, undefined, winSorter);\n  }\n\n  /**\n   * Get targeting key value pairs for winning bid.\n   * @param bidsReceived code array\n   * @param adUnitCodes code array\n   * @return winning bids targeting\n   */\n  function getWinningBidTargeting(bidsReceived, adUnitCodes) {\n    const winners = targeting.getWinningBids(adUnitCodes, bidsReceived);\n    const standardKeys = getStandardKeys();\n    return winners.map(winner => {\n      return {\n        [winner.adUnitCode]: Object.keys(winner.adserverTargeting).filter(key => typeof winner.sendStandardTargeting === 'undefined' || winner.sendStandardTargeting || standardKeys.indexOf(key) === -1).reduce((acc, key) => {\n          const targetingValue = [winner.adserverTargeting[key]];\n          const targeting = {\n            [key.substring(0, MAX_DFP_KEYLENGTH)]: targetingValue\n          };\n          if (key === TARGETING_KEYS.DEAL) {\n            const bidderCodeTargetingKey = `${key}_${winner.bidderCode}`.substring(0, MAX_DFP_KEYLENGTH);\n            const bidderCodeTargeting = {\n              [bidderCodeTargetingKey]: targetingValue\n            };\n            return [...acc, targeting, bidderCodeTargeting];\n          }\n          return [...acc, targeting];\n        }, [])\n      };\n    });\n  }\n  function getStandardKeys() {\n    return auctionManager.getStandardBidderAdServerTargeting() // in case using a custom standard key set\n    .map(targeting => targeting.key).concat(TARGETING_KEYS_ARR).filter(uniques); // standard keys defined in the library.\n  }\n  function getCustomKeys() {\n    const standardKeys = getStandardKeys();\n    return function (key) {\n      return standardKeys.indexOf(key) === -1;\n    };\n  }\n\n  /**\n   * Get custom targeting key value pairs for bids.\n   * @param {Array<Object>} bidsSorted code array\n   * @param {Object} customKeysByUnit code array\n   * @return bids with custom targeting defined in bidderSettings\n   */\n  function getCustomBidTargeting(bidsSorted, customKeysByUnit) {\n    return bidsSorted.reduce((acc, bid) => {\n      const newBid = Object.assign({}, bid);\n      const customKeysForUnit = customKeysByUnit[newBid.adUnitCode];\n      const targeting = [];\n      if (customKeysForUnit) {\n        Object.keys(customKeysForUnit).forEach(key => {\n          if (key && customKeysForUnit[key]) targeting.push({\n            [key]: customKeysForUnit[key]\n          });\n        });\n      }\n      acc.push({\n        [newBid.adUnitCode]: targeting\n      });\n      return acc;\n    }, []);\n  }\n  function getTargetingMap(bid, keys) {\n    return keys.reduce((targeting, key) => {\n      const value = bid.adserverTargeting[key];\n      if (value) {\n        targeting.push({\n          [`${key}_${bid.bidderCode}`.substring(0, MAX_DFP_KEYLENGTH)]: [bid.adserverTargeting[key]]\n        });\n      }\n      return targeting;\n    }, []);\n  }\n  function getAdUnitTargeting(adUnitCodes) {\n    function getTargetingObj(adUnit) {\n      return adUnit?.[JSON_MAPPING.ADSERVER_TARGETING];\n    }\n    function getTargetingValues(adUnit) {\n      const aut = getTargetingObj(adUnit);\n      return Object.keys(aut).map(function (key) {\n        if (isStr(aut[key])) aut[key] = aut[key].split(',').map(s => s.trim());\n        if (!isArray(aut[key])) aut[key] = [aut[key]];\n        return {\n          [key]: aut[key]\n        };\n      });\n    }\n    return auctionManager.getAdUnits().filter(adUnit => adUnitCodes.includes(adUnit.code) && getTargetingObj(adUnit)).reduce((result, adUnit) => {\n      const targetingValues = getTargetingValues(adUnit);\n      if (targetingValues) result.push({\n        [adUnit.code]: targetingValues\n      });\n      return result;\n    }, []);\n  }\n  return targeting;\n}\nexport const targeting = newTargeting(auctionManager);\n//# sourceMappingURL=targeting.js.map\n","import { deepClone, isPlainObject, logError, shuffle, logMessage, triggerPixel, insertUserSyncIframe, isArray, logWarn, isStr, isSafariBrowser } from './utils.js';\nimport { config } from './config.js';\nimport { getCoreStorageManager } from './storageManager.js';\nimport { isActivityAllowed, registerActivityControl } from './activities/rules.js';\nimport { ACTIVITY_SYNC_USER } from './activities/activities.js';\nimport { ACTIVITY_PARAM_COMPONENT_NAME, ACTIVITY_PARAM_COMPONENT_TYPE, ACTIVITY_PARAM_SYNC_TYPE, ACTIVITY_PARAM_SYNC_URL } from './activities/params.js';\nimport { MODULE_TYPE_BIDDER } from './activities/modules.js';\nimport { activityParams } from './activities/activityParams.js';\nexport const USERSYNC_DEFAULT_CONFIG = {\n  syncEnabled: true,\n  filterSettings: {\n    image: {\n      bidders: '*',\n      filter: 'include'\n    }\n  },\n  syncsPerBidder: 5,\n  syncDelay: 3000,\n  auctionDelay: 500\n};\n\n// Set userSync default values\nconfig.setDefaults({\n  'userSync': deepClone(USERSYNC_DEFAULT_CONFIG)\n});\nconst storage = getCoreStorageManager('usersync');\n\n/**\n * Factory function which creates a new UserSyncPool.\n *\n * @param {} deps Configuration options and dependencies which the\n *   UserSync object needs in order to behave properly.\n */\nexport function newUserSync(deps) {\n  const publicApi = {};\n  // A queue of user syncs for each adapter\n  // Let getDefaultQueue() set the defaults\n  let queue = getDefaultQueue();\n\n  // Whether or not user syncs have been trigger on this page load for a specific bidder\n  const hasFiredBidder = new Set();\n  // How many bids for each adapter\n  let numAdapterBids = {};\n\n  // for now - default both to false in case filterSettings config is absent/misconfigured\n  const permittedPixels = {\n    image: true,\n    iframe: false\n  };\n\n  // Use what is in config by default\n  let usConfig = deps.config;\n  // Update if it's (re)set\n  config.getConfig('userSync', conf => {\n    // Added this logic for https://github.com/prebid/Prebid.js/issues/4864\n    // if userSync.filterSettings does not contain image/all configs, merge in default image config to ensure image pixels are fired\n    if (conf.userSync) {\n      const fs = conf.userSync.filterSettings;\n      if (isPlainObject(fs)) {\n        if (!fs.image && !fs.all) {\n          conf.userSync.filterSettings.image = {\n            bidders: '*',\n            filter: 'include'\n          };\n        }\n      }\n    }\n    usConfig = Object.assign(usConfig, conf.userSync);\n  });\n  deps.regRule(ACTIVITY_SYNC_USER, 'userSync config', params => {\n    if (!usConfig.syncEnabled) {\n      return {\n        allow: false,\n        reason: 'syncs are disabled'\n      };\n    }\n    if (params[ACTIVITY_PARAM_COMPONENT_TYPE] === MODULE_TYPE_BIDDER) {\n      const syncType = params[ACTIVITY_PARAM_SYNC_TYPE];\n      const bidder = params[ACTIVITY_PARAM_COMPONENT_NAME];\n      if (!publicApi.canBidderRegisterSync(syncType, bidder)) {\n        return {\n          allow: false,\n          reason: `${syncType} syncs are not enabled for ${bidder}`\n        };\n      }\n    }\n  });\n\n  /**\n   * @function getDefaultQueue\n   * @summary Returns the default empty queue\n   * @private\n   * @return {object} A queue with no syncs\n   */\n  function getDefaultQueue() {\n    return {\n      image: [],\n      iframe: []\n    };\n  }\n\n  /**\n   * @function fireSyncs\n   * @summary Trigger all user syncs in the queue\n   * @private\n   */\n  function fireSyncs() {\n    if (!usConfig.syncEnabled || !deps.browserSupportsCookies) {\n      return;\n    }\n    try {\n      // Iframe syncs\n      loadIframes();\n      // Image pixels\n      fireImagePixels();\n    } catch (e) {\n      return logError('Error firing user syncs', e);\n    }\n    // Reset the user sync queue\n    queue = getDefaultQueue();\n  }\n  function forEachFire(queue, fn) {\n    // Randomize the order of the pixels before firing\n    // This is to avoid giving any bidder who has registered multiple syncs\n    // any preferential treatment and balancing them out\n    shuffle(queue).forEach(fn);\n  }\n\n  /**\n   * @function fireImagePixels\n   * @summary Loops through user sync pixels and fires each one\n   * @private\n   */\n  function fireImagePixels() {\n    if (!permittedPixels.image) {\n      return;\n    }\n    forEachFire(queue.image, sync => {\n      const [bidderName, trackingPixelUrl] = sync;\n      logMessage(`Invoking image pixel user sync for bidder: ${bidderName}`);\n      // Create image object and add the src url\n      triggerPixel(trackingPixelUrl);\n    });\n  }\n\n  /**\n   * @function loadIframes\n   * @summary Loops through iframe syncs and loads an iframe element into the page\n   * @private\n   */\n  function loadIframes() {\n    if (!permittedPixels.iframe) {\n      return;\n    }\n    forEachFire(queue.iframe, sync => {\n      const [bidderName, iframeUrl] = sync;\n      logMessage(`Invoking iframe user sync for bidder: ${bidderName}`);\n      // Insert iframe into DOM\n      insertUserSyncIframe(iframeUrl);\n      // for a bidder, if iframe sync is present then remove image pixel\n      removeImagePixelsForBidder(queue, bidderName);\n    });\n  }\n  function removeImagePixelsForBidder(queue, iframeSyncBidderName) {\n    queue.image = queue.image.filter(imageSync => {\n      const imageSyncBidderName = imageSync[0];\n      return imageSyncBidderName !== iframeSyncBidderName;\n    });\n  }\n\n  /**\n   * @function incrementAdapterBids\n   * @summary Increment the count of user syncs queue for the adapter\n   * @private\n   * @param {object} numAdapterBids The object contain counts for all adapters\n   * @param {string} bidder The name of the bidder adding a sync\n   * @returns {object} The updated version of numAdapterBids\n   */\n  function incrementAdapterBids(numAdapterBids, bidder) {\n    if (!numAdapterBids[bidder]) {\n      numAdapterBids[bidder] = 1;\n    } else {\n      numAdapterBids[bidder] += 1;\n    }\n    return numAdapterBids;\n  }\n\n  /**\n   * @function registerSync\n   * @summary Add sync for this bidder to a queue to be fired later\n   * @public\n   * @param {string} type The type of the sync including image, iframe\n   * @param {string} bidder The name of the adapter. e.g. \"rubicon\"\n   * @param {string} url Either the pixel url or iframe url depending on the type\n   * @example <caption>Using Image Sync</caption>\n   * // registerSync(type, adapter, pixelUrl)\n   * userSync.registerSync('image', 'rubicon', 'http://example.com/pixel')\n   */\n  publicApi.registerSync = (type, bidder, url) => {\n    if (hasFiredBidder.has(bidder)) {\n      return logMessage(`already fired syncs for \"${bidder}\", ignoring registerSync call`);\n    }\n    if (!usConfig.syncEnabled || !isArray(queue[type])) {\n      return logWarn(`User sync type \"${type}\" not supported`);\n    }\n    if (!bidder) {\n      return logWarn(`Bidder is required for registering sync`);\n    }\n    if (usConfig.syncsPerBidder !== 0 && Number(numAdapterBids[bidder]) >= usConfig.syncsPerBidder) {\n      return logWarn(`Number of user syncs exceeded for \"${bidder}\"`);\n    }\n    if (deps.isAllowed(ACTIVITY_SYNC_USER, activityParams(MODULE_TYPE_BIDDER, bidder, {\n      [ACTIVITY_PARAM_SYNC_TYPE]: type,\n      [ACTIVITY_PARAM_SYNC_URL]: url\n    }))) {\n      // the bidder's pixel has passed all checks and is allowed to register\n      queue[type].push([bidder, url]);\n      numAdapterBids = incrementAdapterBids(numAdapterBids, bidder);\n    }\n  };\n\n  /**\n   * Mark a bidder as done with its user syncs - no more will be accepted from them in this session.\n   * @param {string} bidderCode\n   */\n  publicApi.bidderDone = hasFiredBidder.add.bind(hasFiredBidder);\n\n  /**\n   * @function shouldBidderBeBlocked\n   * @summary Check filterSettings logic to determine if the bidder should be prevented from registering their userSync tracker\n   * @private\n   * @param {string} type The type of the sync; either image or iframe\n   * @param {string} bidder The name of the adapter. e.g. \"rubicon\"\n   * @returns {boolean} true => bidder is not allowed to register; false => bidder can register\n   */\n  function shouldBidderBeBlocked(type, bidder) {\n    const filterConfig = usConfig.filterSettings;\n\n    // apply the filter check if the config object is there (eg filterSettings.iframe exists) and if the config object is properly setup\n    if (isFilterConfigValid(filterConfig, type)) {\n      permittedPixels[type] = true;\n      const activeConfig = filterConfig.all ? filterConfig.all : filterConfig[type];\n      const biddersToFilter = activeConfig.bidders === '*' ? [bidder] : activeConfig.bidders;\n      const filterType = activeConfig.filter || 'include'; // set default if undefined\n\n      // return true if the bidder is either: not part of the include (ie outside the whitelist) or part of the exclude (ie inside the blacklist)\n      const checkForFiltering = {\n        'include': (bidders, bidder) => !bidders.includes(bidder),\n        'exclude': (bidders, bidder) => bidders.includes(bidder)\n      };\n      return checkForFiltering[filterType](biddersToFilter, bidder);\n    }\n    return !permittedPixels[type];\n  }\n\n  /**\n   * @function isFilterConfigValid\n   * @summary Check if the filterSettings object in the userSync config is setup properly\n   * @private\n   * @param {object} filterConfig sub-config object taken from filterSettings\n   * @param {string} type The type of the sync; either image or iframe\n   * @returns {boolean} true => config is setup correctly, false => setup incorrectly or filterConfig[type] is not present\n   */\n  function isFilterConfigValid(filterConfig, type) {\n    if (filterConfig.all && filterConfig[type]) {\n      logWarn(`Detected presence of the \"filterSettings.all\" and \"filterSettings.${type}\" in userSync config.  You cannot mix \"all\" with \"iframe/image\" configs; they are mutually exclusive.`);\n      return false;\n    }\n    const activeConfig = filterConfig.all ? filterConfig.all : filterConfig[type];\n    const activeConfigName = filterConfig.all ? 'all' : type;\n\n    // if current pixel type isn't part of the config's logic, skip rest of the config checks...\n    // we return false to skip subsequent filter checks in shouldBidderBeBlocked() function\n    if (!activeConfig) {\n      return false;\n    }\n    const filterField = activeConfig.filter;\n    const biddersField = activeConfig.bidders;\n    if (filterField && filterField !== 'include' && filterField !== 'exclude') {\n      logWarn(`UserSync \"filterSettings.${activeConfigName}.filter\" setting '${filterField}' is not a valid option; use either 'include' or 'exclude'.`);\n      return false;\n    }\n    if (biddersField !== '*' && !(Array.isArray(biddersField) && biddersField.length > 0 && biddersField.every(bidderInList => isStr(bidderInList) && bidderInList !== '*'))) {\n      logWarn(`Detected an invalid setup in userSync \"filterSettings.${activeConfigName}.bidders\"; use either '*' (to represent all bidders) or an array of bidders.`);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @function syncUsers\n   * @summary Trigger all the user syncs based on publisher-defined timeout\n   * @public\n   * @param {number} timeout The delay in ms before syncing data - default 0\n   */\n  publicApi.syncUsers = function () {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (timeout) {\n      return setTimeout(fireSyncs, Number(timeout));\n    }\n    fireSyncs();\n  };\n\n  /**\n   * @function triggerUserSyncs\n   * @summary A `syncUsers` wrapper for determining if enableOverride has been turned on\n   * @public\n   */\n  publicApi.triggerUserSyncs = () => {\n    if (usConfig.enableOverride) {\n      publicApi.syncUsers();\n    }\n  };\n  publicApi.canBidderRegisterSync = (type, bidder) => {\n    if (usConfig.filterSettings) {\n      if (shouldBidderBeBlocked(type, bidder)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  return publicApi;\n}\nexport const userSync = newUserSync(Object.defineProperties({\n  config: config.getConfig('userSync'),\n  isAllowed: isActivityAllowed,\n  regRule: registerActivityControl\n}, {\n  browserSupportsCookies: {\n    get: function () {\n      // call storage lazily to give time for consent data to be available\n      return !isSafariBrowser() && storage.cookiesAreEnabled();\n    }\n  }\n}));\n\n/**\n * @typedef {Object} UserSyncConfig\n *\n * @property {boolean} enableOverride\n * @property {boolean} syncEnabled\n * @property {number} syncsPerBidder\n * @property {string[]} enabledBidders\n * @property {Object} filterSettings\n */\n//# sourceMappingURL=userSync.js.map\n","import { config } from './config.js';\nimport { EVENTS } from './constants.js';\nimport { PbPromise } from './utils/promise.js';\nimport deepAccess from 'dlv/index.js';\nimport { isArray, isFn, isStr, isPlainObject } from './utils/objects.js';\nexport { deepAccess };\nexport { dset as deepSetValue } from 'dset';\nexport * from './utils/objects.js';\nconst consoleExists = Boolean(window.console);\nconst consoleLogExists = Boolean(consoleExists && window.console.log);\nconst consoleInfoExists = Boolean(consoleExists && window.console.info);\nconst consoleWarnExists = Boolean(consoleExists && window.console.warn);\nconst consoleErrorExists = Boolean(consoleExists && window.console.error);\nlet eventEmitter;\nlet windowDimensions;\nexport function _setEventEmitter(emitFn) {\n  // called from events.js - this hoop is to avoid circular imports\n  eventEmitter = emitFn;\n}\nfunction emitEvent() {\n  if (eventEmitter != null) {\n    eventEmitter(...arguments);\n  }\n}\nexport const getWinDimensions = function () {\n  let lastCheckTimestamp;\n  const CHECK_INTERVAL_MS = 20;\n  return () => {\n    if (!windowDimensions || !lastCheckTimestamp || Date.now() - lastCheckTimestamp > CHECK_INTERVAL_MS) {\n      internal.resetWinDimensions();\n      lastCheckTimestamp = Date.now();\n    }\n    return windowDimensions;\n  };\n}();\nexport function resetWinDimensions() {\n  const top = canAccessWindowTop() ? internal.getWindowTop() : internal.getWindowSelf();\n  windowDimensions = {\n    screen: {\n      width: top.screen?.width,\n      height: top.screen?.height,\n      availWidth: top.screen?.availWidth,\n      availHeight: top.screen?.availHeight,\n      colorDepth: top.screen?.colorDepth\n    },\n    innerHeight: top.innerHeight,\n    innerWidth: top.innerWidth,\n    outerWidth: top.outerWidth,\n    outerHeight: top.outerHeight,\n    visualViewport: {\n      height: top.visualViewport?.height,\n      width: top.visualViewport?.width\n    },\n    document: {\n      documentElement: {\n        clientWidth: top.document?.documentElement?.clientWidth,\n        clientHeight: top.document?.documentElement?.clientHeight,\n        scrollTop: top.document?.documentElement?.scrollTop,\n        scrollLeft: top.document?.documentElement?.scrollLeft\n      },\n      body: {\n        scrollTop: document.body?.scrollTop,\n        scrollLeft: document.body?.scrollLeft,\n        clientWidth: document.body?.clientWidth,\n        clientHeight: document.body?.clientHeight\n      }\n    }\n  };\n}\n\n// this allows stubbing of utility functions that are used internally by other utility functions\nexport const internal = {\n  checkCookieSupport,\n  createTrackPixelIframeHtml,\n  getWindowSelf,\n  getWindowTop,\n  canAccessWindowTop,\n  getWindowLocation,\n  insertUserSyncIframe,\n  insertElement,\n  isFn,\n  triggerPixel,\n  logError,\n  logWarn,\n  logMessage,\n  logInfo,\n  parseQS,\n  formatQS,\n  deepEqual,\n  resetWinDimensions\n};\nconst prebidInternal = {};\n/**\n * Returns object that is used as internal prebid namespace\n */\nexport function getPrebidInternal() {\n  return prebidInternal;\n}\n\n/* utility method to get incremental integer starting from 1 */\nvar getIncrementalInteger = function () {\n  var count = 0;\n  return function () {\n    count++;\n    return count;\n  };\n}();\n\n// generate a random string (to be used as a dynamic JSONP callback)\nexport function getUniqueIdentifierStr() {\n  return getIncrementalInteger() + Math.random().toString(16).substr(2);\n}\n\n/**\n * Returns a random v4 UUID of the form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx,\n * where each x is replaced with a random hexadecimal digit from 0 to f,\n * and y is replaced with a random hexadecimal digit from 8 to b.\n * https://gist.github.com/jed/982883 via node-uuid\n */\nexport function generateUUID(placeholder) {\n  return placeholder ? (placeholder ^ _getRandomData() >> placeholder / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, generateUUID);\n}\n\n/**\n * Returns random data using the Crypto API if available and Math.random if not\n * Method is from https://gist.github.com/jed/982883 like generateUUID, direct link https://gist.github.com/jed/982883#gistcomment-45104\n */\nfunction _getRandomData() {\n  if (window && window.crypto && window.crypto.getRandomValues) {\n    return crypto.getRandomValues(new Uint8Array(1))[0] % 16;\n  } else {\n    return Math.random() * 16;\n  }\n}\nexport function getBidIdParameter(key, paramsObj) {\n  return paramsObj?.[key] || '';\n}\n\n// parse a query string object passed in bid params\n// bid params should be an object such as {key: \"value\", key1 : \"value1\"}\n// aliases to formatQS\nexport function parseQueryStringParameters(queryObj) {\n  let result = '';\n  for (var k in queryObj) {\n    if (queryObj.hasOwnProperty(k)) {\n      result += k + '=' + encodeURIComponent(queryObj[k]) + '&';\n    }\n  }\n  result = result.replace(/&$/, '');\n  return result;\n}\n\n// transform an AdServer targeting bids into a query string to send to the adserver\nexport function transformAdServerTargetingObj(targeting) {\n  // we expect to receive targeting for a single slot at a time\n  if (targeting && Object.getOwnPropertyNames(targeting).length > 0) {\n    return Object.keys(targeting).map(key => `${key}=${encodeURIComponent(targeting[key])}`).join('&');\n  } else {\n    return '';\n  }\n}\n\n/**\n * Parse a GPT-Style general size Array like `[[300, 250]]` or `\"300x250,970x90\"` into an array of width, height tuples `[[300, 250]]` or '[[300,250], [970,90]]'\n */\nexport function sizesToSizeTuples(sizes) {\n  if (typeof sizes === 'string') {\n    // multiple sizes will be comma-separated\n    return sizes.split(/\\s*,\\s*/).map(sz => sz.match(/^(\\d+)x(\\d+)$/i)).filter(match => match).map(_ref => {\n      let [_, w, h] = _ref;\n      return [parseInt(w, 10), parseInt(h, 10)];\n    });\n  } else if (Array.isArray(sizes)) {\n    if (isValidGPTSingleSize(sizes)) {\n      return [sizes];\n    }\n    return sizes.filter(isValidGPTSingleSize);\n  }\n  return [];\n}\n\n/**\n * Parse a GPT-Style general size Array like `[[300, 250]]` or `\"300x250,970x90\"` into an array of sizes `[\"300x250\"]` or '['300x250', '970x90']'\n * @param  {(Array.<number[]>|Array.<number>)} sizeObj Input array or double array [300,250] or [[300,250], [728,90]]\n * @return {Array.<string>}  Array of strings like `[\"300x250\"]` or `[\"300x250\", \"728x90\"]`\n */\nexport function parseSizesInput(sizeObj) {\n  return sizesToSizeTuples(sizeObj).map(sizeTupleToSizeString);\n}\nexport function sizeTupleToSizeString(size) {\n  return size[0] + 'x' + size[1];\n}\n\n// Parse a GPT style single size array, (i.e [300, 250])\n// into an AppNexus style string, (i.e. 300x250)\nexport function parseGPTSingleSizeArray(singleSize) {\n  if (isValidGPTSingleSize(singleSize)) {\n    return sizeTupleToSizeString(singleSize);\n  }\n}\nexport function sizeTupleToRtbSize(size) {\n  return {\n    w: size[0],\n    h: size[1]\n  };\n}\n\n// Parse a GPT style single size array, (i.e [300, 250])\n// into OpenRTB-compatible (imp.banner.w/h, imp.banner.format.w/h, imp.video.w/h) object(i.e. {w:300, h:250})\nexport function parseGPTSingleSizeArrayToRtbSize(singleSize) {\n  if (isValidGPTSingleSize(singleSize)) {\n    return sizeTupleToRtbSize(singleSize);\n  }\n}\nfunction isValidGPTSingleSize(singleSize) {\n  // if we aren't exactly 2 items in this array, it is invalid\n  return isArray(singleSize) && singleSize.length === 2 && !isNaN(singleSize[0]) && !isNaN(singleSize[1]);\n}\nexport function getWindowTop() {\n  return window.top;\n}\nexport function getWindowSelf() {\n  return window.self;\n}\nexport function getWindowLocation() {\n  return window.location;\n}\nexport function getDocument() {\n  return document;\n}\nexport function canAccessWindowTop() {\n  try {\n    if (internal.getWindowTop().location.href) {\n      return true;\n    }\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Wrappers to console.(log | info | warn | error). Takes N arguments, the same as the native methods\n */\n// eslint-disable-next-line no-restricted-syntax\nexport function logMessage() {\n  if (debugTurnedOn() && consoleLogExists) {\n    // eslint-disable-next-line no-console\n    console.log.apply(console, decorateLog(arguments, 'MESSAGE:'));\n  }\n}\n\n// eslint-disable-next-line no-restricted-syntax\nexport function logInfo() {\n  if (debugTurnedOn() && consoleInfoExists) {\n    // eslint-disable-next-line no-console\n    console.info.apply(console, decorateLog(arguments, 'INFO:'));\n  }\n}\n\n// eslint-disable-next-line no-restricted-syntax\nexport function logWarn() {\n  if (debugTurnedOn() && consoleWarnExists) {\n    // eslint-disable-next-line no-console\n    console.warn.apply(console, decorateLog(arguments, 'WARNING:'));\n  }\n  emitEvent(EVENTS.AUCTION_DEBUG, {\n    type: 'WARNING',\n    arguments: arguments\n  });\n}\n\n// eslint-disable-next-line no-restricted-syntax\nexport function logError() {\n  if (debugTurnedOn() && consoleErrorExists) {\n    // eslint-disable-next-line no-console\n    console.error.apply(console, decorateLog(arguments, 'ERROR:'));\n  }\n  emitEvent(EVENTS.AUCTION_DEBUG, {\n    type: 'ERROR',\n    arguments: arguments\n  });\n}\nexport function prefixLog(prefix) {\n  function decorate(fn) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      fn(prefix, ...args);\n    };\n  }\n  return {\n    logError: decorate(logError),\n    logWarn: decorate(logWarn),\n    logMessage: decorate(logMessage),\n    logInfo: decorate(logInfo)\n  };\n}\nfunction decorateLog(args, prefix) {\n  args = [].slice.call(args);\n  const bidder = config.getCurrentBidder();\n  prefix && args.unshift(prefix);\n  if (bidder) {\n    args.unshift(label('#aaa'));\n  }\n  args.unshift(label('#3b88c3'));\n  args.unshift('%cPrebid' + (bidder ? `%c${bidder}` : ''));\n  return args;\n  function label(color) {\n    return `display: inline-block; color: #fff; background: ${color}; padding: 1px 4px; border-radius: 3px;`;\n  }\n}\nexport function hasConsoleLogger() {\n  return consoleLogExists;\n}\nexport function debugTurnedOn() {\n  return !!config.getConfig('debug');\n}\nexport const createIframe = (() => {\n  const DEFAULTS = {\n    border: '0px',\n    hspace: '0',\n    vspace: '0',\n    marginWidth: '0',\n    marginHeight: '0',\n    scrolling: 'no',\n    frameBorder: '0',\n    allowtransparency: 'true'\n  };\n  return function (doc, attrs) {\n    let style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const f = doc.createElement('iframe');\n    Object.assign(f, Object.assign({}, DEFAULTS, attrs));\n    Object.assign(f.style, style);\n    return f;\n  };\n})();\nexport function createInvisibleIframe() {\n  return createIframe(document, {\n    id: getUniqueIdentifierStr(),\n    width: 0,\n    height: 0,\n    src: 'about:blank'\n  }, {\n    display: 'none',\n    height: '0px',\n    width: '0px',\n    border: '0px'\n  });\n}\n\n/*\n *   Check if a given parameter name exists in query string\n *   and if it does return the value\n */\nexport function getParameterByName(name) {\n  return parseQS(getWindowLocation().search)[name] || '';\n}\n\n/**\n * Return if the object is \"empty\";\n * this includes falsey, no keys, or no items at indices\n * @param {*} object object to test\n * @return {Boolean} if object is empty\n */\nexport function isEmpty(object) {\n  if (!object) return true;\n  if (isArray(object) || isStr(object)) {\n    return !(object.length > 0);\n  }\n  return Object.keys(object).length <= 0;\n}\n\n/**\n * Return if string is empty, null, or undefined\n * @param str string to test\n * @returns {boolean} if string is empty\n */\nexport function isEmptyStr(str) {\n  return isStr(str) && (!str || str.length === 0);\n}\n\n/**\n * Iterate object with the function\n * falls back to es5 `forEach`\n * @param {Array|Object} object\n * @param {Function} fn - The function to execute for each element. It receives three arguments: value, key, and the original object.\n * @returns {void}\n */\nexport function _each(object, fn) {\n  if (isFn(object?.forEach)) return object.forEach(fn, this);\n  Object.entries(object || {}).forEach(_ref2 => {\n    let [k, v] = _ref2;\n    return fn.call(this, v, k);\n  });\n}\nexport function contains(a, obj) {\n  return isFn(a?.includes) && a.includes(obj);\n}\n\n/**\n * Map an array or object into another array\n * given a function\n * @param {Array|Object} object\n * @param {Function} callback - The function to execute for each element. It receives three arguments: value, key, and the original object.\n * @return {Array}\n */\nexport function _map(object, callback) {\n  if (isFn(object?.map)) return object.map(callback);\n  return Object.entries(object || {}).map(_ref3 => {\n    let [k, v] = _ref3;\n    return callback(v, k, object);\n  });\n}\n\n/*\n* Inserts an element(elm) as targets child, by default as first child\n* @param {HTMLElement} elm\n* @param {HTMLElement} [doc]\n* @param {HTMLElement} [target]\n* @param {Boolean} [asLastChildChild]\n* @return {HTML Element}\n*/\nexport function insertElement(elm, doc, target, asLastChildChild) {\n  doc = doc || document;\n  let parentEl;\n  if (target) {\n    parentEl = doc.getElementsByTagName(target);\n  } else {\n    parentEl = doc.getElementsByTagName('head');\n  }\n  try {\n    parentEl = parentEl.length ? parentEl : doc.getElementsByTagName('body');\n    if (parentEl.length) {\n      parentEl = parentEl[0];\n      const insertBeforeEl = asLastChildChild ? null : parentEl.firstChild;\n      return parentEl.insertBefore(elm, insertBeforeEl);\n    }\n  } catch (e) {}\n}\n\n/**\n * Returns a promise that completes when the given element triggers a 'load' or 'error' DOM event, or when\n * `timeout` milliseconds have elapsed.\n *\n * @param {HTMLElement} element\n * @param {Number} [timeout]\n * @returns {Promise}\n */\nexport function waitForElementToLoad(element, timeout) {\n  let timer = null;\n  return new PbPromise(resolve => {\n    const onLoad = function () {\n      element.removeEventListener('load', onLoad);\n      element.removeEventListener('error', onLoad);\n      if (timer != null) {\n        window.clearTimeout(timer);\n      }\n      resolve();\n    };\n    element.addEventListener('load', onLoad);\n    element.addEventListener('error', onLoad);\n    if (timeout != null) {\n      timer = window.setTimeout(onLoad, timeout);\n    }\n  });\n}\n\n/**\n * Inserts an image pixel with the specified `url` for cookie sync\n * @param {string} url URL string of the image pixel to load\n * @param  {function} [done] an optional exit callback, used when this usersync pixel is added during an async process\n * @param  {Number} [timeout] an optional timeout in milliseconds for the image to load before calling `done`\n */\nexport function triggerPixel(url, done, timeout) {\n  const img = new Image();\n  if (done && internal.isFn(done)) {\n    waitForElementToLoad(img, timeout).then(done);\n  }\n  img.src = url;\n}\n\n/**\n * Inserts an empty iframe with the specified `html`, primarily used for tracking purposes\n * (though could be for other purposes)\n * @param {string} htmlCode snippet of HTML code used for tracking purposes\n */\nexport function insertHtmlIntoIframe(htmlCode) {\n  if (!htmlCode) {\n    return;\n  }\n  const iframe = createInvisibleIframe();\n  internal.insertElement(iframe, document, 'body');\n  (doc => {\n    doc.open();\n    doc.write(htmlCode);\n    doc.close();\n  })(iframe.contentWindow.document);\n}\n\n/**\n * Inserts empty iframe with the specified `url` for cookie sync\n * @param  {string} url URL to be requested\n * @param  {function} [done] an optional exit callback, used when this usersync pixel is added during an async process\n * @param  {Number} [timeout] an optional timeout in milliseconds for the iframe to load before calling `done`\n */\nexport function insertUserSyncIframe(url, done, timeout) {\n  const iframeHtml = internal.createTrackPixelIframeHtml(url, false, 'allow-scripts allow-same-origin');\n  const div = document.createElement('div');\n  div.innerHTML = iframeHtml;\n  const iframe = div.firstChild;\n  if (done && internal.isFn(done)) {\n    waitForElementToLoad(iframe, timeout).then(done);\n  }\n  internal.insertElement(iframe, document, 'html', true);\n}\n\n/**\n * Creates a snippet of HTML that retrieves the specified `url`\n * @param  {string} url URL to be requested\n * @param encode\n * @return {string}     HTML snippet that contains the img src = set to `url`\n */\nexport function createTrackPixelHtml(url) {\n  let encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : encodeURI;\n  if (!url) {\n    return '';\n  }\n  const escapedUrl = encode(url);\n  let img = '<div style=\"position:absolute;left:0px;top:0px;visibility:hidden;\">';\n  img += '<img src=\"' + escapedUrl + '\"></div>';\n  return img;\n}\n;\n\n/**\n * encodeURI, but preserves macros of the form '${MACRO}' (e.g. '${AUCTION_PRICE}')\n * @param url\n * @return {string}\n */\nexport function encodeMacroURI(url) {\n  const macros = Array.from(url.matchAll(/\\$({[^}]+})/g)).map(match => match[1]);\n  return macros.reduce((str, macro) => {\n    return str.replace('$' + encodeURIComponent(macro), '$' + macro);\n  }, encodeURI(url));\n}\n\n/**\n * Creates a snippet of Iframe HTML that retrieves the specified `url`\n * @param  {string} url plain URL to be requested\n * @param  {string} encodeUri boolean if URL should be encoded before inserted. Defaults to true\n * @param  {string} sandbox string if provided the sandbox attribute will be included with the given value\n * @return {string}     HTML snippet that contains the iframe src = set to `url`\n */\nexport function createTrackPixelIframeHtml(url) {\n  let encodeUri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let sandbox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (!url) {\n    return '';\n  }\n  if (encodeUri) {\n    url = encodeURI(url);\n  }\n  if (sandbox) {\n    sandbox = `sandbox=\"${sandbox}\"`;\n  }\n  return `<iframe ${sandbox} id=\"${getUniqueIdentifierStr()}\"\n      frameborder=\"0\"\n      allowtransparency=\"true\"\n      marginheight=\"0\" marginwidth=\"0\"\n      width=\"0\" hspace=\"0\" vspace=\"0\" height=\"0\"\n      style=\"height:0px;width:0px;display:none;\"\n      scrolling=\"no\"\n      src=\"${url}\">\n    </iframe>`;\n}\nexport function uniques(value, index, arry) {\n  return arry.indexOf(value) === index;\n}\nexport function flatten(a, b) {\n  return a.concat(b);\n}\nexport function getBidRequest(id, bidderRequests) {\n  if (!id) {\n    return;\n  }\n  return bidderRequests.flatMap(br => br.bids).find(bid => ['bidId', 'adId', 'bid_id'].some(prop => bid[prop] === id));\n}\nexport function getValue(obj, key) {\n  return obj[key];\n}\nexport function getBidderCodes(adUnits) {\n  // this could memoize adUnits\n  return adUnits.map(unit => unit.bids.map(bid => bid.bidder).reduce(flatten, [])).reduce(flatten, []).filter(bidder => typeof bidder !== 'undefined').filter(uniques);\n}\nexport function isGptPubadsDefined() {\n  if (window.googletag && isFn(window.googletag.pubads) && isFn(window.googletag.pubads().getSlots)) {\n    return true;\n  }\n}\nexport function isApnGetTagDefined() {\n  if (window.apntag && isFn(window.apntag.getTag)) {\n    return true;\n  }\n}\nexport const sortByHighestCpm = (a, b) => {\n  return b.cpm - a.cpm;\n};\n\n/**\n * FisherYates shuffle\n * http://stackoverflow.com/a/6274398\n * https://bost.ocks.org/mike/shuffle/\n * istanbul ignore next\n */\nexport function shuffle(array) {\n  let counter = array.length;\n\n  // while there are elements in the array\n  while (counter > 0) {\n    // pick a random index\n    const index = Math.floor(Math.random() * counter);\n\n    // decrease counter by 1\n    counter--;\n\n    // and swap the last element with it\n    const temp = array[counter];\n    array[counter] = array[index];\n    array[index] = temp;\n  }\n  return array;\n}\nexport function inIframe() {\n  try {\n    return internal.getWindowSelf() !== internal.getWindowTop();\n  } catch (e) {\n    return true;\n  }\n}\n\n/**\n * https://iabtechlab.com/wp-content/uploads/2016/03/SafeFrames_v1.1_final.pdf\n */\nexport function isSafeFrameWindow() {\n  if (!inIframe()) {\n    return false;\n  }\n  const ws = internal.getWindowSelf();\n  return !!(ws.$sf && ws.$sf.ext);\n}\n\n/**\n * Returns the result of calling the function $sf.ext.geom() if it exists\n * @see https://iabtechlab.com/wp-content/uploads/2016/03/SafeFrames_v1.1_final.pdf  5.4 Function $sf.ext.geom\n * @returns {Object | undefined} geometric information about the container\n */\nexport function getSafeframeGeometry() {\n  try {\n    const ws = getWindowSelf();\n    return typeof ws.$sf.ext.geom === 'function' ? ws.$sf.ext.geom() : undefined;\n  } catch (e) {\n    logError('Error getting SafeFrame geometry', e);\n    return undefined;\n  }\n}\nexport function isSafariBrowser() {\n  return /^((?!chrome|android|crios|fxios).)*safari/i.test(navigator.userAgent);\n}\nexport function replaceMacros(str, subs) {\n  if (!str) return;\n  return Object.entries(subs).reduce((str, _ref4) => {\n    let [key, val] = _ref4;\n    return str.replace(new RegExp('\\\\$\\\\{' + key + '\\\\}', 'g'), val || '');\n  }, str);\n}\nexport function replaceAuctionPrice(str, cpm) {\n  return replaceMacros(str, {\n    AUCTION_PRICE: cpm\n  });\n}\nexport function replaceClickThrough(str, clicktag) {\n  if (!str || !clicktag || typeof clicktag !== 'string') return;\n  return str.replace(/\\${CLICKTHROUGH}/g, clicktag);\n}\nexport function timestamp() {\n  return new Date().getTime();\n}\n\n/**\n * The returned value represents the time elapsed since the time origin. @see https://developer.mozilla.org/en-US/docs/Web/API/Performance/now\n * @returns {number}\n */\nexport function getPerformanceNow() {\n  return window.performance && window.performance.now && window.performance.now() || 0;\n}\n\n/**\n * Retuns the difference between `timing.domLoading` and `timing.navigationStart`.\n * This function uses the deprecated `Performance.timing` API and should be removed in future.\n * It has not been updated yet because it is still used in some modules.\n * @deprecated\n * @param {Window} w The window object used to perform the api call. default to window.self\n * @returns {number}\n */\nexport function getDomLoadingDuration(w) {\n  let domLoadingDuration = -1;\n  w = w || getWindowSelf();\n  const performance = w.performance;\n  if (w.performance?.timing) {\n    if (w.performance.timing.navigationStart > 0) {\n      const val = performance.timing.domLoading - performance.timing.navigationStart;\n      if (val > 0) {\n        domLoadingDuration = val;\n      }\n    }\n  }\n  return domLoadingDuration;\n}\n\n/**\n * When the deviceAccess flag config option is false, no cookies should be read or set\n * @returns {boolean}\n */\nexport function hasDeviceAccess() {\n  return config.getConfig('deviceAccess') !== false;\n}\n\n/**\n * @returns {(boolean|undefined)}\n */\nexport function checkCookieSupport() {\n  // eslint-disable-next-line no-restricted-properties\n  if (window.navigator.cookieEnabled || !!document.cookie.length) {\n    return true;\n  }\n}\n\n/**\n * Given a function, return a function which only executes the original after\n * it's been called numRequiredCalls times.\n *\n * Note that the arguments from the previous calls will *not* be forwarded to the original function.\n * Only the final call's arguments matter.\n *\n * @param {function} func The function which should be executed, once the returned function has been executed\n *   numRequiredCalls times.\n * @param {number} numRequiredCalls The number of times which the returned function needs to be called before\n *   func is.\n */\nexport function delayExecution(func, numRequiredCalls) {\n  if (numRequiredCalls < 1) {\n    throw new Error(`numRequiredCalls must be a positive number. Got ${numRequiredCalls}`);\n  }\n  let numCalls = 0;\n  return function () {\n    numCalls++;\n    if (numCalls === numRequiredCalls) {\n      func.apply(this, arguments);\n    }\n  };\n}\n\n/**\n * https://stackoverflow.com/a/34890276/428704\n * @param {Array} xs\n * @param {string} key\n * @returns {Object} {${key_value}: ${groupByArray}, key_value: {groupByArray}}\n */\nexport function groupBy(xs, key) {\n  return xs.reduce(function (rv, x) {\n    (rv[x[key]] = rv[x[key]] || []).push(x);\n    return rv;\n  }, {});\n}\n\n/**\n * Validates an adunit's `mediaTypes` parameter\n * @param mediaTypes mediaTypes parameter to validate\n * @return If object is valid\n */\nexport function isValidMediaTypes(mediaTypes) {\n  const SUPPORTED_MEDIA_TYPES = ['banner', 'native', 'video', 'audio'];\n  const SUPPORTED_STREAM_TYPES = ['instream', 'outstream', 'adpod'];\n  const types = Object.keys(mediaTypes);\n  if (!types.every(type => SUPPORTED_MEDIA_TYPES.includes(type))) {\n    return false;\n  }\n  if (true && mediaTypes.video && mediaTypes.video.context) {\n    return SUPPORTED_STREAM_TYPES.includes(mediaTypes.video.context);\n  }\n  return true;\n}\n\n/**\n * Returns user configured bidder params from adunit\n * @param {Object} adUnits\n * @param {string} adUnitCode code\n * @param {string} bidder code\n * @return {Array} user configured param for the given bidder adunit configuration\n */\nexport function getUserConfiguredParams(adUnits, adUnitCode, bidder) {\n  return adUnits.filter(adUnit => adUnit.code === adUnitCode).flatMap(adUnit => adUnit.bids).filter(bidderData => bidderData.bidder === bidder).map(bidderData => bidderData.params || {});\n}\n\n/**\n * Returns Do Not Track state\n */\nexport function getDNT() {\n  return navigator.doNotTrack === '1' || window.doNotTrack === '1' || navigator.msDoNotTrack === '1' || navigator.doNotTrack === 'yes';\n}\nexport const compareCodeAndSlot = (slot, adUnitCode) => slot.getAdUnitPath() === adUnitCode || slot.getSlotElementId() === adUnitCode;\n\n/**\n * Returns filter function to match adUnitCode in slot\n * @param slot GoogleTag slot\n * @return filter function\n */\nexport function isAdUnitCodeMatchingSlot(slot) {\n  return adUnitCode => compareCodeAndSlot(slot, adUnitCode);\n}\n\n/**\n * Constructs warning message for when unsupported bidders are dropped from an adunit\n * @param {Object} adUnit ad unit from which the bidder is being dropped\n * @param {string} bidder bidder code that is not compatible with the adUnit\n * @return {string} warning message to display when condition is met\n */\nexport function unsupportedBidderMessage(adUnit, bidder) {\n  const mediaType = Object.keys(adUnit.mediaTypes || {\n    'banner': 'banner'\n  }).join(', ');\n  return `\n    ${adUnit.code} is a ${mediaType} ad unit\n    containing bidders that don't support ${mediaType}: ${bidder}.\n    This bidder won't fetch demand.\n  `;\n}\n\n/**\n * Returns a new object with undefined properties removed from given object\n * @param obj the object to clean\n */\nexport function cleanObj(obj) {\n  return Object.fromEntries(Object.entries(obj).filter(_ref5 => {\n    let [_, v] = _ref5;\n    return typeof v !== 'undefined';\n  }));\n}\n\n/**\n * Create a new object with selected properties.  Also allows property renaming and transform functions.\n * @param obj the original object\n * @param properties An array of desired properties\n */\nexport function pick(obj, properties) {\n  if (typeof obj !== 'object') {\n    return {};\n  }\n  return properties.reduce((newObj, prop, i) => {\n    if (typeof prop === 'function') {\n      return newObj;\n    }\n    let newProp = prop;\n    const match = prop.match(/^(.+?)\\sas\\s(.+?)$/i);\n    if (match) {\n      prop = match[1];\n      newProp = match[2];\n    }\n    let value = obj[prop];\n    if (typeof properties[i + 1] === 'function') {\n      value = properties[i + 1](value, newObj);\n    }\n    if (typeof value !== 'undefined') {\n      newObj[newProp] = value;\n    }\n    return newObj;\n  }, {});\n}\nexport function parseQS(query) {\n  return !query ? {} : query.replace(/^\\?/, '').split('&').reduce((acc, criteria) => {\n    let [k, v] = criteria.split('=');\n    if (/\\[\\]$/.test(k)) {\n      k = k.replace('[]', '');\n      acc[k] = acc[k] || [];\n      acc[k].push(v);\n    } else {\n      acc[k] = v || '';\n    }\n    return acc;\n  }, {});\n}\nexport function formatQS(query) {\n  return Object.keys(query).map(k => Array.isArray(query[k]) ? query[k].map(v => `${k}[]=${v}`).join('&') : `${k}=${query[k]}`).join('&');\n}\nexport function parseUrl(url, options) {\n  const parsed = document.createElement('a');\n  if (options && 'noDecodeWholeURL' in options && options.noDecodeWholeURL) {\n    parsed.href = url;\n  } else {\n    parsed.href = decodeURIComponent(url);\n  }\n  // in window.location 'search' is string, not object\n  const qsAsString = options && 'decodeSearchAsString' in options && options.decodeSearchAsString;\n  return {\n    href: parsed.href,\n    protocol: (parsed.protocol || '').replace(/:$/, ''),\n    hostname: parsed.hostname,\n    port: +parsed.port,\n    pathname: parsed.pathname.replace(/^(?!\\/)/, '/'),\n    search: qsAsString ? parsed.search : internal.parseQS(parsed.search || ''),\n    hash: (parsed.hash || '').replace(/^#/, ''),\n    host: parsed.host || window.location.host\n  };\n}\nexport function buildUrl(obj) {\n  return (obj.protocol || 'http') + '://' + (obj.host || obj.hostname + (obj.port ? `:${obj.port}` : '')) + (obj.pathname || '') + (obj.search ? `?${internal.formatQS(obj.search || '')}` : '') + (obj.hash ? `#${obj.hash}` : '');\n}\n\n/**\n * This function deeply compares two objects checking for their equivalence.\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Object} [options] - Options for comparison.\n * @param {boolean} [options.checkTypes=false] - If set, two objects with identical properties but different constructors will *not* be considered equivalent.\n * @returns {boolean} - Returns `true` if the objects are equivalent, `false` otherwise.\n */\nexport function deepEqual(obj1, obj2) {\n  let {\n    checkTypes = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Quick reference check\n  if (obj1 === obj2) return true;\n\n  // If either is null or not an object, do a direct equality check\n  if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {\n    return false;\n  }\n  // Cache the Array checks\n  const isArr1 = Array.isArray(obj1);\n  const isArr2 = Array.isArray(obj2);\n  // Special case: both are arrays\n  if (isArr1 && isArr2) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!deepEqual(obj1[i], obj2[i], {\n        checkTypes\n      })) {\n        return false;\n      }\n    }\n    return true;\n  } else if (isArr1 || isArr2) {\n    return false;\n  }\n\n  // If were checking types, compare constructors (e.g., plain object vs. Date)\n  if (checkTypes && obj1.constructor !== obj2.constructor) {\n    return false;\n  }\n\n  // Compare object keys. Cache keys for both to avoid repeated calls.\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n  for (const key of keys1) {\n    // If `obj2` doesn't have this key or sub-values aren't equal, bail out.\n    if (!Object.prototype.hasOwnProperty.call(obj2, key)) {\n      return false;\n    }\n    if (!deepEqual(obj1[key], obj2[key], {\n      checkTypes\n    })) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function mergeDeep(target) {\n  for (let i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {\n    const source = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!isPlainObject(source)) {\n      continue;\n    }\n    mergeDeepHelper(target, source);\n  }\n  return target;\n}\nfunction mergeDeepHelper(target, source) {\n  // quick check\n  if (!isPlainObject(target) || !isPlainObject(source)) {\n    return;\n  }\n  const keys = Object.keys(source);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key === '__proto__' || key === 'constructor') {\n      continue;\n    }\n    const val = source[key];\n    if (isPlainObject(val)) {\n      if (!target[key]) {\n        target[key] = {};\n      }\n      mergeDeepHelper(target[key], val);\n    } else if (Array.isArray(val)) {\n      if (!Array.isArray(target[key])) {\n        target[key] = [...val];\n      } else {\n        // deduplicate\n        val.forEach(obj => {\n          if (!target[key].some(item => deepEqual(item, obj))) {\n            target[key].push(obj);\n          }\n        });\n      }\n    } else {\n      // direct assignment\n      target[key] = val;\n    }\n  }\n}\n\n/**\n * returns a hash of a string using a fast algorithm\n * source: https://stackoverflow.com/a/52171480/845390\n * @param str\n * @param seed (optional)\n * @returns {string}\n */\nexport function cyrb53Hash(str) {\n  let seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // IE doesn't support imul\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul#Polyfill\n  const imul = function (opA, opB) {\n    if (isFn(Math.imul)) {\n      return Math.imul(opA, opB);\n    } else {\n      opB |= 0; // ensure that opB is an integer. opA will automatically be coerced.\n      // floating points give us 53 bits of precision to work with plus 1 sign bit\n      // automatically handled for our convienence:\n      // 1. 0x003fffff /*opA & 0x000fffff*/ * 0x7fffffff /*opB*/ = 0x1fffff7fc00001\n      //    0x1fffff7fc00001 < Number.MAX_SAFE_INTEGER /*0x1fffffffffffff*/\n      var result = (opA & 0x003fffff) * opB;\n      // 2. We can remove an integer coersion from the statement above because:\n      //    0x1fffff7fc00001 + 0xffc00000 = 0x1fffffff800001\n      //    0x1fffffff800001 < Number.MAX_SAFE_INTEGER /*0x1fffffffffffff*/\n      if (opA & 0xffc00000) result += (opA & 0xffc00000) * opB | 0;\n      return result | 0;\n    }\n  };\n  let h1 = 0xdeadbeef ^ seed;\n  let h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = imul(h1 ^ ch, 2654435761);\n    h2 = imul(h2 ^ ch, 1597334677);\n  }\n  h1 = imul(h1 ^ h1 >>> 16, 2246822507) ^ imul(h2 ^ h2 >>> 13, 3266489909);\n  h2 = imul(h2 ^ h2 >>> 16, 2246822507) ^ imul(h1 ^ h1 >>> 13, 3266489909);\n  return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString();\n}\n\n/**\n * returns the result of `JSON.parse(data)`, or undefined if that throws an error.\n * @param data\n * @returns {any}\n */\nexport function safeJSONParse(data) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {}\n}\nexport function safeJSONEncode(data) {\n  try {\n    return JSON.stringify(data);\n  } catch (e) {\n    return '';\n  }\n}\n\n/**\n * Returns a memoized version of `fn`.\n *\n * @param fn\n * @param key cache key generator, invoked with the same arguments passed to `fn`.\n *        By default, the first argument is used as key.\n * @return {*}\n */\nexport function memoize(fn) {\n  let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (arg) {\n    return arg;\n  };\n  const cache = new Map();\n  const memoized = function () {\n    const cacheKey = key.apply(this, arguments);\n    if (!cache.has(cacheKey)) {\n      cache.set(cacheKey, fn.apply(this, arguments));\n    }\n    return cache.get(cacheKey);\n  };\n  memoized.clear = cache.clear.bind(cache);\n  return memoized;\n}\n\n/**\n * Returns a Unix timestamp for given time value and unit.\n * @param {number} timeValue numeric value, defaults to 0 (which means now)\n * @param {string} timeUnit defaults to days (or 'd'), use 'm' for minutes. Any parameter that isn't 'd' or 'm' will return Date.now().\n * @returns {number}\n */\nexport function getUnixTimestampFromNow() {\n  let timeValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let timeUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';\n  const acceptableUnits = ['m', 'd'];\n  if (acceptableUnits.indexOf(timeUnit) < 0) {\n    return Date.now();\n  }\n  const multiplication = timeValue / (timeUnit === 'm' ? 1440 : 1);\n  return Date.now() + (timeValue && timeValue > 0 ? 1000 * 60 * 60 * 24 * multiplication : 0);\n}\n\n/**\n * Converts given object into an array, so {key: 1, anotherKey: 'fred', third: ['fred']} is turned\n * into [{key: 1}, {anotherKey: 'fred'}, {third: ['fred']}]\n * @param {Object} obj the object\n * @returns {Array}\n */\nexport function convertObjectToArray(obj) {\n  return Object.keys(obj).map(key => {\n    return {\n      [key]: obj[key]\n    };\n  });\n}\n\n/**\n * Sets dataset attributes on a script\n * @param {HTMLScriptElement} script\n * @param {object} attributes\n */\nexport function setScriptAttributes(script, attributes) {\n  Object.entries(attributes).forEach(_ref6 => {\n    let [k, v] = _ref6;\n    return script.setAttribute(k, v);\n  });\n}\n\n/**\n * Perform a binary search for `el` on an ordered array `arr`.\n *\n * @returns the lowest nonnegative integer I that satisfies:\n *   key(arr[i]) >= key(el) for each i between I and arr.length\n *\n *   (if one or more matches are found for `el`, returns the index of the first;\n *   if the element is not found, return the index of the first element that's greater;\n *   if no greater element exists, return `arr.length`)\n */\nexport function binarySearch(arr, el) {\n  let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : el => el;\n  let left = 0;\n  let right = arr.length && arr.length - 1;\n  const target = key(el);\n  while (right - left > 1) {\n    const middle = left + Math.round((right - left) / 2);\n    if (target > key(arr[middle])) {\n      left = middle;\n    } else {\n      right = middle;\n    }\n  }\n  while (arr.length > left && target > key(arr[left])) {\n    left++;\n  }\n  return left;\n}\n\n/**\n * Checks if an object has non-serializable properties.\n * Non-serializable properties are functions and RegExp objects.\n *\n * @param {Object} obj - The object to check.\n * @param {Set} checkedObjects - A set of properties that have already been checked.\n * @returns {boolean} - Returns true if the object has non-serializable properties, false otherwise.\n */\nexport function hasNonSerializableProperty(obj) {\n  let checkedObjects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  for (const key in obj) {\n    const value = obj[key];\n    const type = typeof value;\n    if (value === undefined || type === 'function' || type === 'symbol' || value instanceof RegExp || value instanceof Map || value instanceof Set || value instanceof Date || value !== null && type === 'object' && value.hasOwnProperty('toJSON')) {\n      return true;\n    }\n    if (value !== null && type === 'object' && value.constructor === Object) {\n      if (checkedObjects.has(value)) {\n        // circular reference, means we have a non-serializable property\n        return true;\n      }\n      checkedObjects.add(value);\n      if (hasNonSerializableProperty(value, checkedObjects)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Returns the value of a nested property in an array of objects.\n *\n * @param {Array} collection - Array of objects.\n * @param {String} key - Key of nested property.\n * @returns {any|undefined} - Value of nested property.\n */\nexport function setOnAny(collection, key) {\n  for (let i = 0, result; i < collection.length; i++) {\n    result = deepAccess(collection[i], key);\n    if (result) {\n      return result;\n    }\n  }\n  return undefined;\n}\nexport function extractDomainFromHost(pageHost) {\n  let domain = null;\n  try {\n    const domains = /[-\\w]+\\.([-\\w]+|[-\\w]{3,}|[-\\w]{1,3}\\.[-\\w]{2})$/i.exec(pageHost);\n    if (domains != null && domains.length > 0) {\n      domain = domains[0];\n      for (let i = 1; i < domains.length; i++) {\n        if (domains[i].length > domain.length) {\n          domain = domains[i];\n        }\n      }\n    }\n  } catch (e) {\n    domain = null;\n  }\n  return domain;\n}\nexport function triggerNurlWithCpm(bid, cpm) {\n  if (isStr(bid.nurl) && bid.nurl !== '') {\n    bid.nurl = bid.nurl.replace(/\\${AUCTION_PRICE}/, cpm);\n    triggerPixel(bid.nurl);\n  }\n}\n\n// To ensure that isGzipCompressionSupported() doesnt become an overhead, we have used memoization to cache the result after the first execution.\n// This way, even if the function is called multiple times, it will only perform the actual check once and return the cached result in subsequent calls.\nexport const isGzipCompressionSupported = function () {\n  let cachedResult; // Store the result\n\n  return function () {\n    if (cachedResult !== undefined) {\n      return cachedResult; // Return cached result if already computed\n    }\n    try {\n      if (typeof window.CompressionStream === 'undefined') {\n        cachedResult = false;\n      } else {\n        (() => new window.CompressionStream('gzip'))();\n        cachedResult = true;\n      }\n    } catch (error) {\n      cachedResult = false;\n    }\n    return cachedResult;\n  };\n}();\n\n// Make sure to use isGzipCompressionSupported before calling this function\nexport async function compressDataWithGZip(data) {\n  if (typeof data !== 'string') {\n    // TextEncoder (below) expects a string\n    data = JSON.stringify(data);\n  }\n  const encoder = new TextEncoder();\n  const encodedData = encoder.encode(data);\n  const compressedStream = new Blob([encodedData]).stream().pipeThrough(new window.CompressionStream('gzip'));\n  const compressedBlob = await new Response(compressedStream).blob();\n  const compressedArrayBuffer = await compressedBlob.arrayBuffer();\n  return new Uint8Array(compressedArrayBuffer);\n}\n//# sourceMappingURL=utils.js.map\n","import { auctionManager } from '../auctionManager.js';\nimport { bidderSettings } from '../bidderSettings.js';\nimport { logError } from '../utils.js';\nexport function adjustCpm(cpm, bidResponse, bidRequest) {\n  let {\n    index = auctionManager.index,\n    bs = bidderSettings\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  bidRequest = bidRequest || index.getBidRequest(bidResponse);\n  const adapterCode = bidResponse?.adapterCode;\n  const bidderCode = bidResponse?.bidderCode || bidRequest?.bidder;\n  const adjustAlternateBids = bs.get(bidResponse?.adapterCode, 'adjustAlternateBids');\n  const bidCpmAdjustment = bs.getOwn(bidderCode, 'bidCpmAdjustment') || bs.get(adjustAlternateBids ? adapterCode : bidderCode, 'bidCpmAdjustment');\n  if (bidCpmAdjustment && typeof bidCpmAdjustment === 'function') {\n    try {\n      return bidCpmAdjustment(cpm, Object.assign({}, bidResponse), bidRequest);\n    } catch (e) {\n      logError('Error during bid adjustment', e);\n    }\n  }\n  return cpm;\n}\n//# sourceMappingURL=cpm.js.map\n","let outOfFocusStart = null; // enforce null otherwise it could be undefined and the callback wouldn't execute\nlet timeOutOfFocus = 0;\nlet suspendedTimeouts = [];\nfunction trackTimeOutOfFocus() {\n  if (document.hidden) {\n    outOfFocusStart = Date.now();\n  } else {\n    timeOutOfFocus += Date.now() - (outOfFocusStart ?? 0); // when the page is loaded in hidden state outOfFocusStart is undefined, which results in timeoutOffset being NaN\n    outOfFocusStart = null;\n    suspendedTimeouts.forEach(_ref => {\n      let {\n        callback,\n        startTime,\n        setTimerId\n      } = _ref;\n      return setTimerId(setFocusTimeout(callback, timeOutOfFocus - startTime)());\n    });\n    suspendedTimeouts = [];\n  }\n}\ndocument.addEventListener('visibilitychange', trackTimeOutOfFocus);\nexport function reset() {\n  outOfFocusStart = null;\n  timeOutOfFocus = 0;\n  suspendedTimeouts = [];\n  document.removeEventListener('visibilitychange', trackTimeOutOfFocus);\n  document.addEventListener('visibilitychange', trackTimeOutOfFocus);\n}\n\n/**\n * Wraps native setTimeout function in order to count time only when page is focused\n *\n * @param {function(void): void} [callback] - A function that will be invoked after passed time\n * @param {number} [milliseconds] - Minimum duration (in milliseconds) that the callback will be executed after\n * @returns {function(): number} - Getter function for current timer id\n */\nexport function setFocusTimeout(callback, milliseconds) {\n  const startTime = timeOutOfFocus;\n  let timerId = setTimeout(() => {\n    if (timeOutOfFocus === startTime && outOfFocusStart == null) {\n      callback();\n    } else if (outOfFocusStart != null) {\n      // case when timeout ended during page is out of focus\n      suspendedTimeouts.push({\n        callback,\n        startTime,\n        setTimerId(newId) {\n          timerId = newId;\n        }\n      });\n    } else {\n      timerId = setFocusTimeout(callback, timeOutOfFocus - startTime)();\n    }\n  }, milliseconds);\n  return () => timerId;\n}\n//# sourceMappingURL=focusTimeout.js.map\n","export function scrubIPv4(ip) {\n  if (!ip) {\n    return null;\n  }\n  const ones = 24;\n  const ipParts = ip.split('.').map(Number);\n  if (ipParts.length != 4) {\n    return null;\n  }\n  const mask = [];\n  for (let i = 0; i < 4; i++) {\n    const n = Math.max(0, Math.min(8, ones - i * 8));\n    mask.push(0xff << 8 - n & 0xff);\n  }\n  const maskedIP = ipParts.map((part, i) => part & mask[i]);\n  return maskedIP.join('.');\n}\nexport function scrubIPv6(ip) {\n  if (!ip) {\n    return null;\n  }\n  const ones = 64;\n  let ipParts = ip.split(':').map(part => parseInt(part, 16));\n  ipParts = ipParts.map(part => isNaN(part) ? 0 : part);\n  while (ipParts.length < 8) {\n    ipParts.push(0);\n  }\n  if (ipParts.length != 8) {\n    return null;\n  }\n  const mask = [];\n  for (let i = 0; i < 8; i++) {\n    const n = Math.max(0, Math.min(16, ones - i * 16));\n    mask.push(0xffff << 16 - n & 0xffff);\n  }\n  const maskedIP = ipParts.map((part, i) => part & mask[i]);\n  return maskedIP.map(part => part.toString(16)).join(':');\n}\n//# sourceMappingURL=ipUtils.js.map\n","import { klona } from \"klona/json\";\nexport function deepClone(obj) {\n  return klona(obj) || {};\n}\n\n/**\n * Build an object consisting of only defined parameters to avoid creating an\n * object with defined keys and undefined values.\n * @param object The object to pick defined params out of\n * @param params An array of strings representing properties to look for in the object\n * @returns An object containing all the specified values that are defined\n */\nexport function getDefinedParams(object, params) {\n  return params.filter(param => object[param]).reduce((bid, param) => Object.assign(bid, {\n    [param]: object[param]\n  }), {});\n}\nconst tStr = 'String';\nconst tFn = 'Function';\nconst tNumb = 'Number';\nconst tObject = 'Object';\nconst tBoolean = 'Boolean';\nconst toString = Object.prototype.toString;\n\n/**\n * Return if the object is of the\n * given type.\n * @param {*} object to test\n * @param {String} _t type string (e.g., Array)\n * @return {Boolean} if object is of type _t\n */\nexport function isA(object, _t) {\n  return toString.call(object) === '[object ' + _t + ']';\n}\nexport function isFn(object) {\n  return isA(object, tFn);\n}\nexport function isStr(object) {\n  return isA(object, tStr);\n}\nexport const isArray = Array.isArray.bind(Array);\nexport function isNumber(object) {\n  return isA(object, tNumb);\n}\nexport function isPlainObject(object) {\n  return isA(object, tObject);\n}\nexport function isBoolean(object) {\n  return isA(object, tBoolean);\n}\n\n/**\n * Checks input is integer or not\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n */\nexport const isInteger = Number.isInteger.bind(Number);\nexport function isArrayOfNums(val, size) {\n  return isArray(val) && (size ? val.length === size : true) && val.every(v => isInteger(v));\n}\n//# sourceMappingURL=objects.js.map\n","import { config } from '../config.js';\nexport const CONFIG_TOGGLE = 'performanceMetrics';\nconst getTime = window.performance && window.performance.now ? () => window.performance.now() : () => Date.now();\nconst NODES = new WeakMap();\n\n/**\n * A function that, when called, stops a time measure and saves it as a metric.\n */\n\nfunction wrapFn(fn, before, after) {\n  return function () {\n    before && before();\n    try {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return fn.apply(this, args);\n    } finally {\n      after && after();\n    }\n  };\n}\nexport function metricsFactory() {\n  let {\n    now = getTime,\n    mkNode = makeNode,\n    mkTimer = makeTimer,\n    mkRenamer = rename => rename,\n    nodes = NODES\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function newMetrics() {\n    function makeMetrics(self) {\n      let rename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : n => ({\n        forEach(fn) {\n          fn(n);\n        }\n      });\n      rename = mkRenamer(rename);\n      function accessor(slot) {\n        return function (name) {\n          return self.dfWalk({\n            visit(edge, node) {\n              const obj = node[slot];\n              if (obj.hasOwnProperty(name)) {\n                return obj[name];\n              }\n            }\n          });\n        };\n      }\n      const getTimestamp = accessor('timestamps');\n\n      /**\n       * Register a metric.\n       *\n       * @param name metric name\n       * @param value metric valiue\n       */\n      function setMetric(name, value) {\n        const names = rename(name);\n        self.dfWalk({\n          follow(inEdge, outEdge) {\n            return outEdge.propagate && (!inEdge || !inEdge.stopPropagation);\n          },\n          visit(edge, node) {\n            names.forEach(name => {\n              if (edge == null) {\n                node.metrics[name] = value;\n              } else {\n                if (!node.groups.hasOwnProperty(name)) {\n                  node.groups[name] = [];\n                }\n                node.groups[name].push(value);\n              }\n            });\n          }\n        });\n      }\n\n      /**\n       * Mark the current time as a checkpoint with the given name, to be referenced later\n       * by `timeSince` or `timeBetween`.\n       *\n       * @param name checkpoint name\n       */\n      function checkpoint(name) {\n        self.timestamps[name] = now();\n      }\n\n      /**\n       * Get the tame passed since `checkpoint`, and optionally save it as a metric.\n       *\n       * @param checkpoint checkpoint name\n       * @param metric The name of the metric to save. Optional.\n       * @return The time in milliseconds between now and the checkpoint, or `null` if the checkpoint is not found.\n       */\n      function timeSince(checkpoint, metric) {\n        const ts = getTimestamp(checkpoint);\n        const elapsed = ts != null ? now() - ts : null;\n        if (metric != null) {\n          setMetric(metric, elapsed);\n        }\n        return elapsed;\n      }\n\n      /**\n       * Get the time passed between `startCheckpoint` and `endCheckpoint`, optionally saving it as a metric.\n       *\n       * @param startCheckpoint - The name of the starting checkpoint.\n       * @param endCheckpoint - The name of the ending checkpoint.\n       * @param metric - The name of the metric to save.\n       * @return The time in milliseconds between `startCheckpoint` and `endCheckpoint`, or `null` if either checkpoint is not found.\n       */\n      function timeBetween(startCheckpoint, endCheckpoint, metric) {\n        const start = getTimestamp(startCheckpoint);\n        const end = getTimestamp(endCheckpoint);\n        const elapsed = start != null && end != null ? end - start : null;\n        if (metric != null) {\n          setMetric(metric, elapsed);\n        }\n        return elapsed;\n      }\n\n      /**\n       * Start measuring a time metric with the given name.\n       *\n       * @param name metric name\n       */\n      function startTiming(name) {\n        return mkTimer(now, val => setMetric(name, val));\n      }\n\n      /**\n       * Run fn and measure the time spent in it.\n       *\n       * @param name the name to use for the measured time metric\n       * @param fn the function to run\n       * @return the return value of `fn`\n       */\n      function measureTime(name, fn) {\n        return startTiming(name).stopAfter(fn)();\n      }\n\n      /**\n       * Convenience method for measuring time spent in a `.before` or `.after` hook.\n       *\n       * @param name - The metric name.\n       * @param next - The hook's `next` (first) argument.\n       * @param fn   - A function that will be run immediately; it takes `next`, where both `next` and\n       *               `next.bail` automatically call `stopTiming` before continuing with the original hook.\n       * @return The return value of `fn`.\n       */\n      function measureHookTime(name, next, fn) {\n        const stopTiming = startTiming(name);\n        return fn(function (orig) {\n          const next = stopTiming.stopBefore(orig);\n          next.bail = orig.bail && stopTiming.stopBefore(orig.bail);\n          next.stopTiming = stopTiming;\n          next.untimed = orig;\n          return next;\n        }(next));\n      }\n\n      /**\n       * Get all registered metrics.\n       */\n      function getMetrics() {\n        let result = {};\n        self.dfWalk({\n          visit(edge, node) {\n            result = Object.assign({}, !edge || edge.includeGroups ? node.groups : null, node.metrics, result);\n          }\n        });\n        return result;\n      }\n      /**\n       * Create and return a new metrics object that starts as a view on all metrics registered here,\n       * and - by default - also propagates all new metrics here.\n       *\n       * Propagated metrics are grouped together, and intended for repeated operations. For example, with the following:\n       *\n       * ```\n       * const metrics = newMetrics();\n       * const requests = metrics.measureTime('buildRequests', buildRequests)\n       * requests.forEach((req) => {\n       *   const requestMetrics = metrics.fork();\n       *   requestMetrics.measureTime('processRequest', () => processRequest(req);\n       * })\n       * ```\n       *\n       * if `buildRequests` takes 10ms and returns 3 objects, which respectively take 100, 200, and 300ms in `processRequest`, then\n       * the final `metrics.getMetrics()` would be:\n       *\n       * ```\n       * {\n       *    buildRequests: 10,\n       *    processRequest: [100, 200, 300]\n       * }\n       * ```\n       *\n       * while the inner `requestMetrics.getMetrics()` would be:\n       *\n       * ```\n       * {\n       *   buildRequests: 10,\n       *   processRequest: 100 // or 200 for the 2nd loop, etc\n       * }\n       * ```\n       */\n      function fork() {\n        let {\n          propagate = true,\n          stopPropagation = false,\n          includeGroups = false\n        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return makeMetrics(mkNode([[self, {\n          propagate,\n          stopPropagation,\n          includeGroups\n        }]]), rename);\n      }\n\n      /**\n       * Join `otherMetrics` with these; all metrics from `otherMetrics` will (by default) be propagated here,\n       * and all metrics from here will be included in `otherMetrics`.\n       */\n      function join(otherMetrics) {\n        let {\n          propagate = true,\n          stopPropagation = false,\n          includeGroups = false\n        } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const other = nodes.get(otherMetrics);\n        if (other != null) {\n          other.addParent(self, {\n            propagate,\n            stopPropagation,\n            includeGroups\n          });\n        }\n      }\n\n      /**\n       * @return a version of these metrics with the same propagation rules, but:\n       *  - all metrics are renamed according to `renameFn`, or\n       *  - without these metrics' rename rule (if `renameFn` is omitted).\n       */\n      function renameWith(renameFn) {\n        return makeMetrics(self, renameFn);\n      }\n\n      /**\n       * @return a new metrics object that uses the same propagation and renaming rules as this one.\n       */\n      function newMetrics() {\n        return makeMetrics(self.newSibling(), rename);\n      }\n      const metrics = {\n        startTiming,\n        measureTime,\n        measureHookTime,\n        checkpoint,\n        timeSince,\n        timeBetween,\n        setMetric,\n        getMetrics,\n        fork,\n        join,\n        newMetrics,\n        renameWith,\n        toJSON() {\n          return getMetrics();\n        }\n      };\n      nodes.set(metrics, self);\n      return metrics;\n    }\n    return makeMetrics(mkNode([]));\n  };\n}\nfunction makeTimer(now, cb) {\n  const start = now();\n  let done = false;\n  function stopTiming() {\n    if (!done) {\n      cb(now() - start);\n      done = true;\n    }\n  }\n  stopTiming.stopBefore = fn => wrapFn(fn, stopTiming);\n  stopTiming.stopAfter = fn => wrapFn(fn, null, stopTiming);\n  return stopTiming;\n}\nfunction makeNode(parents) {\n  return {\n    metrics: {},\n    timestamps: {},\n    groups: {},\n    addParent(node, edge) {\n      parents.push([node, edge]);\n    },\n    newSibling() {\n      return makeNode(parents.slice());\n    },\n    dfWalk() {\n      let {\n        visit,\n        follow = () => true,\n        visited = new Set(),\n        inEdge\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let res;\n      if (!visited.has(this)) {\n        visited.add(this);\n        res = visit(inEdge, this);\n        if (res != null) return res;\n        for (const [parent, outEdge] of parents) {\n          if (follow(inEdge, outEdge)) {\n            res = parent.dfWalk({\n              visit,\n              follow,\n              visited,\n              inEdge: outEdge\n            });\n            if (res != null) return res;\n          }\n        }\n      }\n    }\n  };\n}\nconst nullMetrics = (() => {\n  const nop = function () {};\n  const empty = () => ({});\n  const none = {\n    forEach: nop\n  };\n  const nullTimer = () => null;\n  nullTimer.stopBefore = fn => fn;\n  nullTimer.stopAfter = fn => fn;\n  const nullNode = Object.defineProperties({\n    dfWalk: nop,\n    newSibling: () => nullNode,\n    addParent: nop\n  }, Object.fromEntries(['metrics', 'timestamps', 'groups'].map(prop => [prop, {\n    get: empty\n  }])));\n  return metricsFactory({\n    now: () => 0,\n    mkNode: () => nullNode,\n    mkRenamer: () => () => none,\n    mkTimer: () => nullTimer,\n    nodes: {\n      get: nop,\n      set: nop\n    }\n  })();\n})();\nlet enabled = true;\nconfig.getConfig(CONFIG_TOGGLE, cfg => {\n  enabled = !!cfg[CONFIG_TOGGLE];\n});\n\n/**\n * convenience fallback function for metrics that may be undefined, especially during tests.\n */\nexport function useMetrics(metrics) {\n  return enabled && metrics || nullMetrics;\n}\nexport const newMetrics = (() => {\n  const makeMetrics = metricsFactory();\n  return function () {\n    return enabled ? makeMetrics() : nullMetrics;\n  };\n})();\nexport function hookTimer(prefix, getMetrics) {\n  return function (name, hookFn) {\n    var _this = this;\n    return function (next) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      return useMetrics(getMetrics.apply(_this, args)).measureHookTime(prefix + name, next, next => {\n        return hookFn.call(_this, next, ...args);\n      });\n    };\n  };\n}\nexport const timedAuctionHook = hookTimer('requestBids.', req => req.metrics);\nexport const timedBidResponseHook = hookTimer('addBidResponse.', (_, bid) => bid.metrics);\n//# sourceMappingURL=perfMetrics.js.map\n","import { GreedyPromise, greedySetTimeout } from '../../libraries/greedy/greedyPromise.js';\nimport { getGlobal } from '../prebidGlobal.js';\nexport const pbSetTimeout = getGlobal().setTimeout ?? (false ? greedySetTimeout : setTimeout);\nexport const PbPromise = getGlobal().Promise ?? (false ? GreedyPromise : Promise);\nexport function delay() {\n  let delayMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return new PbPromise(resolve => {\n    pbSetTimeout(resolve, delayMs);\n  });\n}\n/**\n * @returns a {promise, resolve, reject} trio where `promise` is resolved by calling `resolve` or `reject`.\n */\nexport function defer() {\n  let {\n    promiseFactory = resolver => new PbPromise(resolver)\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  function invoker(delegate) {\n    return val => delegate(val);\n  }\n  let resolveFn, rejectFn;\n  return {\n    promise: promiseFactory((resolve, reject) => {\n      resolveFn = resolve;\n      rejectFn = reject;\n    }),\n    resolve: invoker(resolveFn),\n    reject: invoker(rejectFn)\n  };\n}\n//# sourceMappingURL=promise.js.map\n","export function simpleCompare(a, b) {\n  if (a === b) return 0;\n  return a < b ? -1 : 1;\n}\nexport function keyCompare() {\n  let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : item => item;\n  return (a, b) => simpleCompare(key(a), key(b));\n}\nexport function reverseCompare() {\n  let compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : simpleCompare;\n  return (a, b) => -compare(a, b) || 0;\n}\nexport function tiebreakCompare() {\n  for (var _len = arguments.length, compares = new Array(_len), _key = 0; _key < _len; _key++) {\n    compares[_key] = arguments[_key];\n  }\n  return function (a, b) {\n    for (const cmp of compares) {\n      const val = cmp(a, b);\n      if (val !== 0) return val;\n    }\n    return 0;\n  };\n}\nexport function minimum() {\n  let compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : simpleCompare;\n  return (min, item) => compare(item, min) < 0 ? item : min;\n}\nexport function maximum() {\n  let compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : simpleCompare;\n  return minimum(reverseCompare(compare));\n}\nconst cpmCompare = keyCompare(bid => bid.cpm);\nconst timestampCompare = keyCompare(bid => bid.responseTimestamp);\n\n// This function will get highest cpm value bid, in case of tie it will return the bid with lowest timeToRespond\nexport const getHighestCpm = maximum(tiebreakCompare(cpmCompare, reverseCompare(keyCompare(bid => bid.timeToRespond))));\n\n// This function will get the oldest hightest cpm value bid, in case of tie it will return the bid which came in first\n// Use case for tie: https://github.com/prebid/Prebid.js/issues/2448\nexport const getOldestHighestCpmBid = maximum(tiebreakCompare(cpmCompare, reverseCompare(timestampCompare)));\n\n// This function will get the latest hightest cpm value bid, in case of tie it will return the bid which came in last\n// Use case for tie: https://github.com/prebid/Prebid.js/issues/2539\nexport const getLatestHighestCpmBid = maximum(tiebreakCompare(cpmCompare, timestampCompare));\n//# sourceMappingURL=reducers.js.map\n","import { PbPromise } from './promise.js';\nimport { binarySearch, logError, timestamp } from '../utils.js';\nimport { setFocusTimeout } from './focusTimeout.js';\n/**\n * Create a set-like collection that automatically forgets items after a certain time.\n */\nexport function ttlCollection() {\n  let {\n    startTime = timestamp,\n    ttl = () => null,\n    monotonic = false,\n    slack = 5000\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const items = new Map();\n  const callbacks = [];\n  const pendingPurge = [];\n  const markForPurge = monotonic ? entry => pendingPurge.push(entry) : entry => pendingPurge.splice(binarySearch(pendingPurge, entry, el => el.expiry), 0, entry);\n  let nextPurge, task;\n  function reschedulePurge() {\n    task && clearTimeout(task);\n    if (pendingPurge.length > 0) {\n      const now = timestamp();\n      nextPurge = Math.max(now, pendingPurge[0].expiry + slack);\n      task = setFocusTimeout(() => {\n        const now = timestamp();\n        let cnt = 0;\n        for (const entry of pendingPurge) {\n          if (entry.expiry > now) break;\n          callbacks.forEach(cb => {\n            try {\n              cb(entry.item);\n            } catch (e) {\n              logError(e);\n            }\n          });\n          items.delete(entry.item);\n          cnt++;\n        }\n        pendingPurge.splice(0, cnt);\n        task = null;\n        reschedulePurge();\n      }, nextPurge - now);\n    } else {\n      task = null;\n    }\n  }\n  function mkEntry(item) {\n    const values = {};\n    const thisCohort = currentCohort;\n    let expiry;\n    function update() {\n      if (thisCohort === currentCohort && values.start != null && values.delta != null) {\n        expiry = values.start + values.delta;\n        markForPurge(entry);\n        if (task == null || nextPurge > expiry + slack) {\n          reschedulePurge();\n        }\n      }\n    }\n    const [init, refresh] = Object.entries({\n      start: startTime,\n      delta: ttl\n    }).map(_ref => {\n      let [field, getter] = _ref;\n      let currentCall;\n      return function () {\n        const thisCall = currentCall = {};\n        PbPromise.resolve(getter(item)).then(val => {\n          if (thisCall === currentCall) {\n            values[field] = val;\n            update();\n          }\n        });\n      };\n    });\n    const entry = {\n      item,\n      refresh,\n      get expiry() {\n        return expiry;\n      }\n    };\n    init();\n    refresh();\n    return entry;\n  }\n  let currentCohort = {};\n  return {\n    [Symbol.iterator]: () => items.keys(),\n    /**\n     * Add an item to this collection.\n     * @param item\n     */\n    add(item) {\n      !items.has(item) && items.set(item, mkEntry(item));\n    },\n    /**\n     * Clear this collection.\n     */\n    clear() {\n      pendingPurge.length = 0;\n      reschedulePurge();\n      items.clear();\n      currentCohort = {};\n    },\n    /**\n     * @returns {[]} all the items in this collection, in insertion order.\n     */\n    toArray() {\n      return Array.from(items.keys());\n    },\n    /**\n     * Refresh the TTL for each item in this collection.\n     */\n    refresh() {\n      pendingPurge.length = 0;\n      reschedulePurge();\n      for (const entry of items.values()) {\n        entry.refresh();\n      }\n    },\n    /**\n     * Register a callback to be run when an item has expired and is about to be\n     * removed the from the collection.\n     * @param cb a callback that takes the expired item as argument\n     * @return an unregistration function.\n     */\n    onExpiry(cb) {\n      callbacks.push(cb);\n      return () => {\n        const idx = callbacks.indexOf(cb);\n        if (idx >= 0) {\n          callbacks.splice(idx, 1);\n        }\n      };\n    }\n  };\n}\n//# sourceMappingURL=ttlCollection.js.map\n","import { isArrayOfNums, isInteger, isNumber, isStr, logError, logWarn } from './utils.js';\nimport { config } from './config.js';\nimport { hook } from './hook.js';\nimport { auctionManager } from './auctionManager.js';\nimport { getGlobalVarName } from \"./buildOptions.js\";\nexport const OUTSTREAM = 'outstream';\nexport const INSTREAM = 'instream';\nconst ORTB_PARAMS = [['mimes', value => Array.isArray(value) && value.length > 0 && value.every(v => typeof v === 'string')], ['minduration', isInteger], ['maxduration', isInteger], ['startdelay', isInteger], ['maxseq', isInteger], ['poddur', isInteger], ['protocols', isArrayOfNums], ['w', isInteger], ['h', isInteger], ['podid', isStr], ['podseq', isInteger], ['rqddurs', isArrayOfNums], ['placement', isInteger],\n// deprecated, see plcmt\n['plcmt', isInteger], ['linearity', isInteger], ['skip', value => [1, 0].includes(value)], ['skipmin', isInteger], ['skipafter', isInteger], ['sequence', isInteger],\n// deprecated\n['slotinpod', isInteger], ['mincpmpersec', isNumber], ['battr', isArrayOfNums], ['maxextended', isInteger], ['minbitrate', isInteger], ['maxbitrate', isInteger], ['boxingallowed', isInteger], ['playbackmethod', isArrayOfNums], ['playbackend', isInteger], ['delivery', isArrayOfNums], ['pos', isInteger], ['api', isArrayOfNums], ['companiontype', isArrayOfNums], ['poddedupe', isArrayOfNums]];\n\n/**\n * List of OpenRTB 2.x video object properties with simple validators.\n * Not included: `companionad`, `durfloors`, `ext`\n * reference: https://github.com/InteractiveAdvertisingBureau/openrtb2.x/blob/main/2.6.md\n */\nexport const ORTB_VIDEO_PARAMS = new Map(ORTB_PARAMS);\nexport function fillVideoDefaults(adUnit) {\n  const video = adUnit?.mediaTypes?.video;\n  if (video != null) {\n    if (video.plcmt == null) {\n      if (video.context === OUTSTREAM || [2, 3, 4].includes(video.placement)) {\n        video.plcmt = 4;\n      } else if (video.playbackmethod?.some?.(method => [2, 6].includes(method))) {\n        video.plcmt = 2;\n      }\n    }\n    const playerSize = isArrayOfNums(video.playerSize, 2) ? video.playerSize : Array.isArray(video.playerSize) && isArrayOfNums(video.playerSize[0]) ? video.playerSize[0] : null;\n    const size = isNumber(video.w) && isNumber(video.h) ? [video.w, video.h] : null;\n    let conflict = false;\n    if (playerSize == null) {\n      if (size != null) {\n        if (video.playerSize != null) {\n          conflict = true;\n        } else {\n          video.playerSize = [size];\n        }\n      }\n    } else {\n      ['w', 'h'].forEach((prop, i) => {\n        if (video[prop] != null && video[prop] !== playerSize[i]) {\n          conflict = true;\n        } else {\n          video[prop] = playerSize[i];\n        }\n      });\n    }\n    if (conflict) {\n      logWarn(`Ad unit \"${adUnit.code} has conflicting playerSize and w/h`, adUnit);\n    }\n  }\n}\n\n/**\n * Validate that the assets required for video context are present on the bid\n */\nexport function isValidVideoBid(bid) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const videoMediaType = index.getMediaTypes(bid)?.video;\n  const context = videoMediaType && videoMediaType?.context;\n  const useCacheKey = videoMediaType && videoMediaType?.useCacheKey;\n  const adUnit = index.getAdUnit(bid);\n\n  // if context not defined assume default 'instream' for video bids\n  // instream bids require a vast url or vast xml content\n  return checkVideoBidSetup(bid, adUnit, videoMediaType, context, useCacheKey);\n}\nexport const checkVideoBidSetup = hook('sync', function (bid, adUnit, videoMediaType, context, useCacheKey) {\n  if (videoMediaType && (useCacheKey || context !== OUTSTREAM)) {\n    // xml-only video bids require a prebid cache url\n    const {\n      url,\n      useLocal\n    } = config.getConfig('cache') || {};\n    if (!url && !useLocal && bid.vastXml && !bid.vastUrl) {\n      logError(`\n        This bid contains only vastXml and will not work when a prebid cache url is not specified.\n        Try enabling either prebid cache with ${getGlobalVarName()}.setConfig({ cache: {url: \"...\"} });\n        or local cache with ${getGlobalVarName()}.setConfig({ cache: { useLocal: true }});\n      `);\n      return false;\n    }\n    return !!(bid.vastUrl || bid.vastXml);\n  }\n\n  // outstream bids require a renderer on the bid or pub-defined on adunit\n  if (context === OUTSTREAM && !useCacheKey) {\n    return !!(bid.renderer || adUnit && adUnit.renderer || videoMediaType.renderer);\n  }\n  return true;\n}, 'checkVideoBidSetup');\n//# sourceMappingURL=video.js.map\n","/**\n * This module interacts with the server used to cache video ad content to be restored later.\n * At a high level, the expected workflow goes like this:\n *\n *   - Request video ads from Bidders\n *   - Generate IDs for each valid bid, and cache the key/value pair on the server.\n *   - Return these IDs so that publishers can use them to fetch the bids later.\n *\n * This trickery helps integrate with ad servers, which set character limits on request params.\n */\n\nimport { ajaxBuilder } from './ajax.js';\nimport { config } from './config.js';\nimport { auctionManager } from './auctionManager.js';\nimport { generateUUID, logError, logWarn } from './utils.js';\nimport { addBidToAuction } from './auction.js';\n/**\n * Might be useful to be configurable in the future\n * Depending on publisher needs\n */\n// TODO: we have a `ttlBuffer` setting\nconst ttlBufferInSeconds = 15;\nexport const vastLocalCache = new Map();\n\n/**\n * Function which wraps a URI that serves VAST XML, so that it can be loaded.\n *\n * @param uri The URI where the VAST content can be found.\n * @param impTrackerURLs An impression tracker URL for the delivery of the video ad\n * @return A VAST URL which loads XML from the given URI.\n */\nfunction wrapURI(uri, impTrackerURLs) {\n  impTrackerURLs = impTrackerURLs && (Array.isArray(impTrackerURLs) ? impTrackerURLs : [impTrackerURLs]);\n  // Technically, this is vulnerable to cross-script injection by sketchy vastUrl bids.\n  // We could make sure it's a valid URI... but since we're loading VAST XML from the\n  // URL they provide anyway, that's probably not a big deal.\n  const impressions = impTrackerURLs ? impTrackerURLs.map(trk => `<Impression><![CDATA[${trk}]]></Impression>`).join('') : '';\n  return `<VAST version=\"3.0\">\n    <Ad>\n      <Wrapper>\n        <AdSystem>prebid.org wrapper</AdSystem>\n        <VASTAdTagURI><![CDATA[${uri}]]></VASTAdTagURI>\n        ${impressions}\n        <Creatives></Creatives>\n      </Wrapper>\n    </Ad>\n  </VAST>`;\n}\n/**\n * Wraps a bid in the format expected by the prebid-server endpoints, or returns null if\n * the bid can't be converted cleanly.\n *\n * @return {Object|null} - The payload to be sent to the prebid-server endpoints, or null if the bid can't be converted cleanly.\n */\nfunction toStorageRequest(bid) {\n  let {\n    index = auctionManager.index\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const vastValue = getVastXml(bid);\n  const auction = index.getAuction(bid);\n  const ttlWithBuffer = Number(bid.ttl) + ttlBufferInSeconds;\n  const payload = {\n    type: 'xml',\n    value: vastValue,\n    ttlseconds: ttlWithBuffer\n  };\n  if (config.getConfig('cache.vasttrack')) {\n    payload.bidder = bid.bidder;\n    payload.bidid = bid.requestId;\n    payload.aid = bid.auctionId;\n  }\n  if (auction != null) {\n    payload.timestamp = auction.getAuctionStart();\n  }\n  if (typeof bid.customCacheKey === 'string' && bid.customCacheKey !== '') {\n    payload.key = bid.customCacheKey;\n  }\n  return payload;\n}\n/**\n * A function which bridges the APIs between the videoCacheStoreCallback and our ajax function's API.\n *\n * @param done A callback to the \"store\" function.\n */\nfunction shimStorageCallback(done) {\n  return {\n    success: function (responseBody) {\n      let ids;\n      try {\n        ids = JSON.parse(responseBody).responses;\n      } catch (e) {\n        done(e, []);\n        return;\n      }\n      if (ids) {\n        done(null, ids);\n      } else {\n        done(new Error(\"The cache server didn't respond with a responses property.\"), []);\n      }\n    },\n    error: function (statusText, responseBody) {\n      done(new Error(`Error storing video ad in the cache: ${statusText}: ${JSON.stringify(responseBody)}`), []);\n    }\n  };\n}\nfunction getVastXml(bid) {\n  return bid.vastXml ? bid.vastXml : wrapURI(bid.vastUrl, bid.vastImpUrl);\n}\n;\n\n/**\n * If the given bid is for a Video ad, generate a unique ID and cache it somewhere server-side.\n *\n * @param bids A list of bid objects which should be cached.\n * @param done An optional callback which should be executed after\n * @param getAjax\n * the data has been stored in the cache.\n */\nexport function store(bids, done) {\n  let getAjax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ajaxBuilder;\n  const requestData = {\n    puts: bids.map(bid => toStorageRequest(bid))\n  };\n  const ajax = getAjax(config.getConfig('cache.timeout'));\n  ajax(config.getConfig('cache.url'), shimStorageCallback(done), JSON.stringify(requestData), {\n    contentType: 'text/plain',\n    withCredentials: true\n  });\n}\nexport function getCacheUrl(id) {\n  return `${config.getConfig('cache.url')}?uuid=${id}`;\n}\nexport const storeLocally = bid => {\n  const vastXml = getVastXml(bid);\n  const bidVastUrl = URL.createObjectURL(new Blob([vastXml], {\n    type: 'text/xml'\n  }));\n  assignVastUrlAndCacheId(bid, bidVastUrl);\n  vastLocalCache.set(bid.videoCacheKey, bidVastUrl);\n};\nconst assignVastUrlAndCacheId = (bid, vastUrl, videoCacheKey) => {\n  bid.videoCacheKey = videoCacheKey || generateUUID();\n  if (!bid.vastUrl) {\n    bid.vastUrl = vastUrl;\n  }\n};\nexport const _internal = {\n  store\n};\nexport function storeBatch(batch) {\n  const bids = batch.map(entry => entry.bidResponse);\n  function err(msg) {\n    logError(`Failed to save to the video cache: ${msg}. Video bids will be discarded:`, bids);\n  }\n  _internal.store(bids, function (error, cacheIds) {\n    if (error) {\n      err(error);\n    } else if (batch.length !== cacheIds.length) {\n      logError(`expected ${batch.length} cache IDs, got ${cacheIds.length} instead`);\n    } else {\n      cacheIds.forEach((cacheId, i) => {\n        const {\n          auctionInstance,\n          bidResponse,\n          afterBidAdded\n        } = batch[i];\n        if (cacheId.uuid === '') {\n          logWarn(`Supplied video cache key was already in use by Prebid Cache; caching attempt was rejected. Video bid must be discarded.`);\n        } else {\n          assignVastUrlAndCacheId(bidResponse, getCacheUrl(cacheId.uuid), cacheId.uuid);\n          addBidToAuction(auctionInstance, bidResponse);\n          afterBidAdded();\n        }\n      });\n    }\n  });\n}\n;\nlet batchSize, batchTimeout, cleanupHandler;\nif (true || true) {\n  config.getConfig('cache', _ref => {\n    let {\n      cache\n    } = _ref;\n    batchSize = typeof cache.batchSize === 'number' && cache.batchSize > 0 ? cache.batchSize : 1;\n    batchTimeout = typeof cache.batchTimeout === 'number' && cache.batchTimeout > 0 ? cache.batchTimeout : 0;\n\n    // removing blobs that are not going to be used\n    if (cache.useLocal && !cleanupHandler) {\n      cleanupHandler = auctionManager.onExpiry(auction => {\n        auction.getBidsReceived().forEach(bid => {\n          const vastUrl = vastLocalCache.get(bid.videoCacheKey);\n          if (vastUrl && vastUrl.startsWith('blob')) {\n            URL.revokeObjectURL(vastUrl);\n          }\n          vastLocalCache.delete(bid.videoCacheKey);\n        });\n      });\n    }\n  });\n}\nexport const batchingCache = function () {\n  let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : setTimeout;\n  let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : storeBatch;\n  let batches = [[]];\n  let debouncing = false;\n  const noTimeout = cb => cb();\n  return function (auctionInstance, bidResponse, afterBidAdded) {\n    const batchFunc = batchTimeout > 0 ? timeout : noTimeout;\n    if (batches[batches.length - 1].length >= batchSize) {\n      batches.push([]);\n    }\n    batches[batches.length - 1].push({\n      auctionInstance,\n      bidResponse,\n      afterBidAdded\n    });\n    if (!debouncing) {\n      debouncing = true;\n      batchFunc(() => {\n        batches.forEach(cache);\n        batches = [[]];\n        debouncing = false;\n      }, batchTimeout);\n    }\n  };\n};\nexport const batchAndStore = batchingCache();\n//# sourceMappingURL=videoCache.js.map\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","/*\n* @license MIT\n* Fun Hooks v1.1.0\n* (c) @snapwich\n*/\ncreate.SYNC = 1;\ncreate.ASYNC = 2;\ncreate.QUEUE = 4;\n\nvar packageName = \"fun-hooks\";\n\nvar defaults = Object.freeze({\n  ready: 0\n});\n\nvar hookableMap = new WeakMap();\n\nfunction rest(args, skip) {\n  return Array.prototype.slice.call(args, skip);\n}\n\nfunction runAll(queue) {\n  var queued;\n  // eslint-disable-next-line no-cond-assign\n  while ((queued = queue.shift())) {\n    queued();\n  }\n}\n\nfunction create(config) {\n  var hooks = {};\n  var postReady = [];\n\n  config = Object.assign({}, defaults, config);\n\n  function dispatch(arg1, arg2) {\n    if (typeof arg1 === \"function\") {\n      return hookFn.call(null, \"sync\", arg1, arg2);\n    } else if (typeof arg1 === \"string\" && typeof arg2 === \"function\") {\n      return hookFn.apply(null, arguments);\n    } else if (typeof arg1 === \"object\") {\n      return hookObj.apply(null, arguments);\n    }\n  }\n\n  var ready;\n  if (config.ready) {\n    dispatch.ready = function() {\n      ready = true;\n      runAll(postReady);\n    };\n  } else {\n    ready = true;\n  }\n\n  function hookObj(obj, props, objName) {\n    var walk = true;\n    if (typeof props === \"undefined\") {\n      props = Object.getOwnPropertyNames(obj).filter(prop => !prop.match(/^_/));\n      walk = false;\n    }\n    var objHooks = {};\n    var doNotHook = [\"constructor\"];\n    do {\n      props.forEach(function(prop) {\n        var parts = prop.match(/(?:(sync|async):)?(.+)/);\n        var type = parts[1] || \"sync\";\n        var name = parts[2];\n        if (\n          !objHooks[name] &&\n          typeof obj[name] === \"function\" &&\n          !(doNotHook.indexOf(name) !== -1)\n        ) {\n          var fn = obj[name];\n          objHooks[name] = obj[name] = hookFn(\n            type,\n            fn,\n            objName ? [objName, name] : undefined\n          );\n        }\n      });\n      obj = Object.getPrototypeOf(obj);\n    } while (walk && obj);\n    return objHooks;\n  }\n\n  /**\n   * Navigates a string path to return a hookable function.  If not found, creates a placeholder for hooks.\n   * @param {(Array<string> | string)} path\n   */\n  function get(path) {\n    var parts = Array.isArray(path) ? path : path.split(\".\");\n    return parts.reduce(function(memo, part, i) {\n      var item = memo[part];\n      var installed = false;\n      if (item) {\n        return item;\n      } else if (i === parts.length - 1) {\n        if (!ready) {\n          postReady.push(function() {\n            if (!installed) {\n              // eslint-disable-next-line no-console\n              console.warn(\n                packageName +\n                  \": referenced '\" +\n                  path +\n                  \"' but it was never created\"\n              );\n            }\n          });\n        }\n        return (memo[part] = newHookable(function(fn) {\n          memo[part] = fn;\n          installed = true;\n        }));\n      }\n      return (memo[part] = {});\n    }, hooks);\n  }\n\n  function newHookable(onInstall) {\n    var before = [];\n    var after = [];\n    var generateTrap = function() {};\n\n    var api = {\n      before: function(hook, priority) {\n        return add.call(this, before, \"before\", hook, priority);\n      },\n      after: function(hook, priority) {\n        return add.call(this, after, \"after\", hook, priority);\n      },\n      getHooks: function(match) {\n        var hooks = before.concat(after);\n        if (typeof match === \"object\") {\n          hooks = hooks.filter(function(entry) {\n            return Object.keys(match).every(function(prop) {\n              return entry[prop] === match[prop];\n            });\n          });\n        }\n        try {\n          Object.assign(hooks, {\n            remove: function() {\n              hooks.forEach(function(entry) {\n                entry.remove();\n              });\n              return this;\n            }\n          });\n        } catch (e) {\n          console.error(\n            \"error adding `remove` to array, did you modify Array.prototype?\"\n          );\n        }\n        return hooks;\n      },\n      removeAll: function() {\n        return this.getHooks().remove();\n      }\n    };\n\n    var meta = {\n      install: function(type, fn, generate) {\n        this.type = type;\n        generateTrap = generate;\n        generate(before, after);\n        onInstall && onInstall(fn);\n      }\n    };\n\n    // store meta data related to hookable. use `api.after` since `api` reference is not available on our proxy.\n    hookableMap.set(api.after, meta);\n\n    return api;\n\n    function add(store, type, hook, priority) {\n      var entry = {\n        hook: hook,\n        type: type,\n        priority: priority || 10,\n        remove: function() {\n          var index = store.indexOf(entry);\n          if (index !== -1) {\n            store.splice(index, 1);\n            generateTrap(before, after);\n          }\n        }\n      };\n      store.push(entry);\n      store.sort(function(a, b) {\n        return b.priority - a.priority;\n      });\n      generateTrap(before, after);\n      return this;\n    }\n  }\n\n  function hookFn(type, fn, name) {\n    // check if function has already been wrapped\n    var meta = fn.after && hookableMap.get(fn.after);\n    if (meta) {\n      if (meta.type !== type) {\n        throw packageName + \": recreated hookable with different type\";\n      } else {\n        return fn;\n      }\n    }\n\n    var hookable = name ? get(name) : newHookable();\n\n    var trap;\n\n    var handlers = {\n      get: function(target, prop) {\n        return hookable[prop] || Reflect.get.apply(Reflect, arguments);\n      }\n    };\n\n    if (!ready) {\n      postReady.push(setTrap);\n    }\n\n    var hookedFn = new Proxy(fn, handlers);\n\n    hookableMap.get(hookedFn.after).install(type, hookedFn, generateTrap);\n\n    return hookedFn;\n\n    // eslint-disable-next-line no-redeclare\n    function generateTrap(before, after) {\n      var order = [];\n      var targetIndex;\n      if (before.length || after.length) {\n        before.forEach(addToOrder);\n        // placeholder for target function wrapper\n        targetIndex = order.push(undefined) - 1;\n        after.forEach(addToOrder);\n        trap = function(target, thisArg, args) {\n          var localOrder = order.slice();\n          var curr = 0;\n          var result;\n          var callback =\n            type === \"async\" &&\n            typeof args[args.length - 1] === \"function\" &&\n            args.pop();\n          function bail(value) {\n            if (type === \"sync\") {\n              result = value;\n            } else if (callback) {\n              callback.apply(null, arguments);\n            }\n          }\n          function next(value) {\n            if (localOrder[curr]) {\n              var args = rest(arguments);\n              next.bail = bail;\n              args.unshift(next);\n              return localOrder[curr++].apply(thisArg, args);\n            }\n            if (type === \"sync\") {\n              result = value;\n            } else if (callback) {\n              callback.apply(null, arguments);\n            }\n          }\n          localOrder[targetIndex] = function() {\n            var args = rest(arguments, 1);\n            if (type === \"async\" && callback) {\n              delete next.bail;\n              args.push(next);\n            }\n            var result = target.apply(thisArg, args);\n            if (type === \"sync\") {\n              next(result);\n            }\n          };\n          next.apply(null, args);\n          return result;\n        };\n      } else {\n        trap = undefined;\n      }\n      setTrap();\n\n      function addToOrder(entry) {\n        order.push(entry.hook);\n      }\n    }\n\n    function setTrap() {\n      if (\n        ready ||\n        (type === \"sync\" && !(config.ready & create.SYNC)) ||\n        (type === \"async\" && !(config.ready & create.ASYNC))\n      ) {\n        handlers.apply = trap;\n      } else if (type === \"sync\" || !(config.ready & create.QUEUE)) {\n        handlers.apply = function() {\n          throw packageName + \": hooked function not ready\";\n        };\n      } else {\n        handlers.apply = function() {\n          var args = arguments;\n          postReady.push(function() {\n            hookedFn.apply(args[1], args[2]);\n          });\n        };\n      }\n    }\n  }\n\n  dispatch.get = get;\n  return dispatch;\n}\n\n/* global module */\nmodule.exports = create;\n","export default {\n  \"pbGlobal\": \"pbjs\",\n  \"defineGlobal\": true,\n  \"features\": {\n    \"NATIVE\": true,\n    \"VIDEO\": true,\n    \"UID2_CSTG\": true,\n    \"GREEDY\": false,\n    \"AUDIO\": true,\n    \"LOG_NON_ERROR\": true,\n    \"LOG_ERROR\": true\n  },\n  \"distUrlBase\": \"https://cdn.jsdelivr.net/npm/prebid.js@latest/dist/chunks/\",\n  \"skipCalls\": {}\n}","export function dset(obj, keys, val) {\n\tkeys.split && (keys=keys.split('.'));\n\tvar i=0, l=keys.length, t=obj, x, k;\n\twhile (i < l) {\n\t\tk = ''+keys[i++];\n\t\tif (k === '__proto__' || k === 'constructor' || k === 'prototype') break;\n\t\tt = t[k] = (i === l) ? val : (typeof(x=t[k])===typeof(keys)) ? x : (keys[i]*0 !== 0 || !!~(''+keys[i]).indexOf('.')) ? {} : [];\n\t}\n}\n","export function klona(val) {\n\tvar k, out, tmp;\n\n\tif (Array.isArray(val)) {\n\t\tout = Array(k=val.length);\n\t\twhile (k--) out[k] = (tmp=val[k]) && typeof tmp === 'object' ? klona(tmp) : tmp;\n\t\treturn out;\n\t}\n\n\tif (Object.prototype.toString.call(val) === '[object Object]') {\n\t\tout = {}; // null\n\t\tfor (k in val) {\n\t\t\tif (k === '__proto__') {\n\t\t\t\tObject.defineProperty(out, k, {\n\t\t\t\t\tvalue: klona(val[k]),\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tout[k] = (tmp=val[k]) && typeof tmp === 'object' ? klona(tmp) : tmp;\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\treturn val;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { install } from './debugging.js';\nwindow._pbjsGlobals.forEach(name => {\n  if (window[name] && window[name]._installDebugging === true) {\n    window[name]._installDebugging = install;\n  }\n});\n//# sourceMappingURL=standalone.js.map\n"],"names":[],"sourceRoot":""}