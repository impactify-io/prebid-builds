{"version":3,"file":"consentManagementGpp.js","mappings":"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","sources":["webpack://prebid.js/../../modules/consentManagementGpp.ts"],"sourcesContent":["/**\n * This module adds GPP consentManagement support to prebid.js.  It interacts with\n * supported CMPs (Consent Management Platforms) to grab the user's consent information\n * and make it available for any GPP supported adapters to read/pass this information to\n * their system and for various other features/modules in Prebid.js.\n */\nimport {deepSetValue, isEmpty, isPlainObject, isStr, logInfo, logWarn} from '../src/utils.js';\nimport {config} from '../src/config.js';\nimport {gppDataHandler} from '../src/adapterManager.js';\nimport {enrichFPD} from '../src/fpd/enrichment.js';\nimport {cmpClient, MODE_CALLBACK} from '../libraries/cmp/cmpClient.js';\nimport {PbPromise, defer} from '../src/utils/promise.js';\nimport {type CMConfig, configParser} from '../libraries/consentManagement/cmUtils.js';\nimport {CONSENT_GPP} from \"../src/consentHandler.ts\";\n\nexport let consentConfig = {} as any;\n\ntype RelevantCMPData = {\n  applicableSections: number[]\n  gppString: string;\n  parsedSections: Record<string, unknown>\n}\n\ntype CMPData = RelevantCMPData & { [key: string]: unknown };\n\nexport type GPPConsentData = RelevantCMPData & {\n  gppData: CMPData;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface GPPConfig {\n  // this is here to be extended by the control modules\n}\n\nexport type GPPCMConfig = GPPConfig & CMConfig<RelevantCMPData>;\n\ndeclare module '../src/consentHandler' {\n  interface ConsentData {\n    [CONSENT_GPP]: GPPConsentData;\n  }\n  interface ConsentManagementConfig {\n    [CONSENT_GPP]?: GPPCMConfig;\n  }\n}\n\nclass GPPError {\n  message;\n  args;\n  constructor(message, arg?) {\n    this.message = message;\n    this.args = arg == null ? [] : [arg];\n  }\n}\n\nexport class GPPClient {\n  apiVersion = '1.1';\n  cmp;\n  static INST;\n\n  static get(mkCmp = cmpClient) {\n    if (this.INST == null) {\n      const cmp = mkCmp({\n        apiName: '__gpp',\n        apiArgs: ['command', 'callback', 'parameter'], // do not pass version - not clear what it's for (or what we should use),\n        mode: MODE_CALLBACK\n      });\n      if (cmp == null) {\n        throw new GPPError('GPP CMP not found');\n      }\n      this.INST = new this(cmp);\n    }\n    return this.INST;\n  }\n\n  #resolve;\n  #reject;\n  #pending = [];\n\n  initialized = false;\n\n  constructor(cmp) {\n    this.cmp = cmp;\n    [this.#resolve, this.#reject] = ['resolve', 'reject'].map(slot => (result) => {\n      while (this.#pending.length) {\n        this.#pending.pop()[slot](result);\n      }\n    });\n  }\n\n  /**\n   * initialize this client - update consent data if already available,\n   * and set up event listeners to also update on CMP changes\n   *\n   * @param pingData\n   * @returns {Promise<{}>} a promise to GPP consent data\n   */\n  init(pingData) {\n    const ready = this.updateWhenReady(pingData);\n    if (!this.initialized) {\n      if (pingData.gppVersion !== this.apiVersion) {\n        logWarn(`Unrecognized GPP CMP version: ${pingData.apiVersion}. Continuing using GPP API version ${this.apiVersion}...`);\n      }\n      this.initialized = true;\n      this.cmp({\n        command: 'addEventListener',\n        callback: (event, success) => {\n          if (success != null && !success) {\n            this.#reject(new GPPError('Received error response from CMP', event));\n          } else if (event?.pingData?.cmpStatus === 'error') {\n            this.#reject(new GPPError('CMP status is \"error\"; please check CMP setup', event));\n          } else if (this.isCMPReady(event?.pingData || {}) && ['sectionChange', 'signalStatus'].includes(event?.eventName)) {\n            this.#resolve(this.updateConsent(event.pingData));\n          }\n          // NOTE: according to https://github.com/InteractiveAdvertisingBureau/Global-Privacy-Platform/blob/main/Core/CMP%20API%20Specification.md,\n          // > [signalStatus] Event is called whenever the display status of the CMP changes (e.g. the CMP shows the consent layer).\n          //\n          // however, from real world testing, at least some CMPs only trigger 'cmpDisplayStatus'\n          // other CMPs may do something else yet; here we just look for 'signalStatus: not ready' on any event\n          // to decide if consent data is likely to change\n          if (gppDataHandler.getConsentData() != null && event?.pingData != null && !this.isCMPReady(event.pingData)) {\n            gppDataHandler.setConsentData(null);\n          }\n        }\n      });\n    }\n    return ready;\n  }\n\n  refresh() {\n    return this.cmp({command: 'ping'}).then(this.init.bind(this));\n  }\n\n  /**\n   * Retrieve and store GPP consent data.\n   *\n   * @param pingData\n   * @returns {Promise<{}>} a promise to GPP consent data\n   */\n  updateConsent(pingData) {\n    return new PbPromise(resolve => {\n      if (pingData == null || isEmpty(pingData)) {\n        throw new GPPError('Received empty response from CMP', pingData);\n      }\n      const consentData = parseConsentData(pingData);\n      logInfo('Retrieved GPP consent from CMP:', consentData);\n      gppDataHandler.setConsentData(consentData);\n      resolve(consentData);\n    });\n  }\n\n  /**\n   * Return a promise to GPP consent data, to be retrieved the next time the CMP signals it's ready.\n   *\n   * @returns {Promise<{}>}\n   */\n  nextUpdate() {\n    const def = defer();\n    this.#pending.push(def);\n    return def.promise;\n  }\n\n  /**\n   * Return a promise to GPP consent data, to be retrieved immediately if the CMP is ready according to `pingData`,\n   * or as soon as it signals that it's ready otherwise.\n   *\n   * @param pingData\n   * @returns {Promise<{}>}\n   */\n  updateWhenReady(pingData) {\n    return this.isCMPReady(pingData) ? this.updateConsent(pingData) : this.nextUpdate();\n  }\n\n  isCMPReady(pingData) {\n    return pingData.signalStatus === 'ready';\n  }\n}\n\nfunction lookupIabConsent() {\n  return new PbPromise((resolve) => resolve(GPPClient.get().refresh()))\n}\n\n// add new CMPs here, with their dedicated lookup function\nconst cmpCallMap = {\n  'iab': lookupIabConsent,\n};\n\nfunction parseConsentData(cmpData) {\n  if (\n    (cmpData?.applicableSections != null && !Array.isArray(cmpData.applicableSections)) ||\n    (cmpData?.gppString != null && !isStr(cmpData.gppString)) ||\n    (cmpData?.parsedSections != null && !isPlainObject(cmpData.parsedSections))\n  ) {\n    throw new GPPError('CMP returned unexpected value during lookup process.', cmpData);\n  }\n  ['usnatv1', 'uscav1'].forEach(section => {\n    if (cmpData?.parsedSections?.[section]) {\n      logWarn(`Received invalid section from cmp: '${section}'. Some functionality may not work as expected`, cmpData);\n    }\n  });\n  return toConsentData(cmpData);\n}\n\nexport function toConsentData(gppData = {} as any): GPPConsentData {\n  return {\n    gppString: gppData?.gppString,\n    applicableSections: gppData?.applicableSections || [],\n    parsedSections: gppData?.parsedSections || {},\n    gppData: gppData\n  };\n}\n\n/**\n * Simply resets the module's consentData variable back to undefined, mainly for testing purposes\n */\nexport function resetConsentData() {\n  consentConfig = {};\n  gppDataHandler.reset();\n  GPPClient.INST = null;\n}\n\nconst parseConfig = configParser({\n  namespace: 'gpp',\n  displayName: 'GPP',\n  consentDataHandler: gppDataHandler,\n  parseConsentData,\n  getNullConsent: () => toConsentData(null),\n  cmpHandlers: cmpCallMap\n});\n\nexport function setConsentConfig(config) {\n  consentConfig = parseConfig(config);\n  return consentConfig.loadConsentData?.()?.catch?.(() => null);\n}\nconfig.getConfig('consentManagement', config => setConsentConfig(config.consentManagement));\n\nexport function enrichFPDHook(next, fpd) {\n  return next(fpd.then(ortb2 => {\n    const consent = gppDataHandler.getConsentData();\n    if (consent) {\n      if (Array.isArray(consent.applicableSections)) {\n        deepSetValue(ortb2, 'regs.gpp_sid', consent.applicableSections);\n      }\n      deepSetValue(ortb2, 'regs.gpp', consent.gppString);\n    }\n    return ortb2;\n  }));\n}\n\nenrichFPD.before(enrichFPDHook);\n"],"names":["registerModule","__r0","deepSetValue","isEmpty","isPlainObject","isStr","logInfo","logWarn","config","gppDataHandler","enrichFPD","cmpClient","MODE_CALLBACK","PbPromise","defer","configParser","CONSENT_GPP","consentConfig","GPPError","constructor","message","arg","args","GPPClient","apiVersion","get","mkCmp","arguments","length","undefined","INST","cmp","apiName","apiArgs","mode","resolve","reject","pending","initialized","map","slot","result","pop","init","pingData","ready","updateWhenReady","gppVersion","command","callback","event","success","cmpStatus","isCMPReady","includes","eventName","updateConsent","getConsentData","setConsentData","refresh","then","bind","consentData","parseConsentData","nextUpdate","def","push","promise","signalStatus","lookupIabConsent","cmpCallMap","cmpData","applicableSections","Array","isArray","gppString","parsedSections","forEach","section","toConsentData","gppData","resetConsentData","reset","parseConfig","namespace","displayName","consentDataHandler","getNullConsent","cmpHandlers","setConsentConfig","loadConsentData","catch","getConfig","consentManagement","enrichFPDHook","next","fpd","ortb2","consent","before"],"sourceRoot":""}